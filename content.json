{"meta":{"title":"夏南瓜的小站","subtitle":"","description":"记录学习中遇到的问题和思考","author":"夏南瓜","url":"https://blog.zucchiniy.com","root":"/"},"pages":[{"title":"","date":"2021-07-02T15:43:09.537Z","updated":"2021-07-02T15:43:09.537Z","comments":true,"path":"README.html","permalink":"https://blog.zucchiniy.com/README.html","excerpt":"","text":"markdown学习笔记、总结、相关内容"},{"title":"关于","date":"2021-07-02T15:43:09.559Z","updated":"2021-07-02T15:43:09.559Z","comments":true,"path":"about/index.html","permalink":"https://blog.zucchiniy.com/about/index.html","excerpt":"","text":"个人信息 Dylan Yang 邮箱：banshiliuli1990@sina.com 技术博客：https://www.zucchiniy.cn GitHub：https://github.com/zucchiniy Emacs 用户，喜欢学习，喜欢折腾 重度手残，五笔用户 学习 Python 中希望能成为 Pythonista 。 技能清单以下内容评级按照 简历中的技术水平 进行评定 熟悉 Linux 系统 熟悉 Mac、Linux 下的环境配置 熟悉 MySQL 了解 Java、C、C++ 熟练使用 Vim、Emacs 熟悉 Python 并努力上升到熟练中","author":"zucchini"},{"title":"所有分类","date":"2021-07-02T15:43:09.559Z","updated":"2021-07-02T15:43:09.559Z","comments":true,"path":"categories/index.html","permalink":"https://blog.zucchiniy.com/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2021-07-02T15:43:09.559Z","updated":"2021-07-02T15:43:09.559Z","comments":true,"path":"friends/index.html","permalink":"https://blog.zucchiniy.com/friends/index.html","excerpt":"","text":"希望交换友链的朋友请联系我。谢谢~"},{"title":"所有标签","date":"2021-07-02T15:43:09.559Z","updated":"2021-07-02T15:43:09.559Z","comments":true,"path":"tags/index.html","permalink":"https://blog.zucchiniy.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-02T15:43:09.560Z","updated":"2021-07-02T15:43:09.560Z","comments":true,"path":"timeline/index.html","permalink":"https://blog.zucchiniy.com/timeline/index.html","excerpt":"","text":"夏南瓜的小破站记事 2021年6月28日 重新将博客迁移到 Hexo，并使用 Volantis 主题。 2021年2月5日 使用 django 重新实现了博客系统。 2020年5月29日 使用 Flask 实现静态博客系统。 2018年8月22日 为 Hugo 实现了一个主题 paladin 。 2018年7月15日 从 Hexo 迁移到 Hugo 。 2017年7月8日 迁移博客到 Hexo 。 2015年12月23日 第一次知道静态博客，利用 Org Mode 实现第一版。 这里是时间线的起点~"}],"posts":[{"title":"利用 find 命令查找并删除文件","slug":"tools/linux/delete-file-in-path","date":"2021-07-04T12:56:09.000Z","updated":"2021-07-04T12:56:09.000Z","comments":true,"path":"posts/215ae710.html","link":"","permalink":"https://blog.zucchiniy.com/posts/215ae710.html","excerpt":"","text":"单纯删除文件利用 find 命令查找所有的文件并将其删除。 1find . -name &#x27;*.DS_Store&#x27; -type f -delete 删除 Git 项目中的内容删除项目中的所有 .DS_Store 。 先从项目中将所有的 .DS_Store 查找出来，然后利用命令将文件从 Git 管理中删除。 1find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 然后将 .DS_Store 加入到 .gitignore 中。 1echo .DS_Store &gt;&gt; ~/.gitignore 最后再把删除后的版本库提交到远程就可以了。 12git add --allgit commit -m &#x27;.DS_Store banished!&#x27;","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"find","slug":"find","permalink":"https://blog.zucchiniy.com/tags/find/"},{"name":"delete","slug":"delete","permalink":"https://blog.zucchiniy.com/tags/delete/"}]},{"title":"清理 Git 项目的大小","slug":"tools/git/git-filter-repo","date":"2021-07-03T13:04:41.000Z","updated":"2021-07-03T13:04:41.000Z","comments":true,"path":"posts/5ea56af6.html","link":"","permalink":"https://blog.zucchiniy.com/posts/5ea56af6.html","excerpt":"","text":"起因一直使用 Emacs 作为自己的编辑器，在单位电脑进行下载配置的时候发现项目的大小竟然已经到了 67M ，在下载过程中太长了，就看了一下目录，主要是因为之前在使用 lsp-mode 和 rime 输入法的时候，项目中引入了许多二进制文件，而在 Git 的管理中，二进制文件是无法跟踪其变化的，所以在后面移除了相关的配置，但二进制文件还在项目中，就想在整个项目之中删除相关的文件和文件夹。 方法之前整理过 Git 相关的命令，其中推荐的方法是使用 filter-branch 命令进行删除，在使用命令中发现提示我使用 git-filter-repo 来修改，就查看了一下命令，使用了一下，感觉很简单，现在把处理过程记录下来。 安装命令是 Python 实现的，所以安装的时候也需要在环境上配置过 Python 环境，安装命令 pip install filter-repo 。 如果是 Mac 的话，可以通过 brew install git-filter-repo 来安装。 使用可以利用 filter-repo 命令分析整个项目中的文件，找到已经删除掉的文件是项目中比较大的文件。 1git filter-repo --analyze 然后再利用生成的文件，可以通过另一个命令清理掉对应的文件。 1git filter-repo --invert-paths --paths-from-file file-want-to-delete.txt 一般我是利用在 .git/filter-repo/analysis/ 目录下 path-all-sizes.txt 文件和 path-deleted-sizes.txt 两个文件，找到希望不再跟踪的文件，另存到一个文件 file-want-to-delete.txt 中。 然后通过第二个命令，将需要删除的文件可以清理掉，然后再强制推到远程就可以了。 建议对于一些多人合作的项目，不建议进行清理的，因为有一些文件会登录有具体的项目流程等内容，所以尽量不要清理文本文件，而二进制文件，其实最好在一开始就不要纳入到 Git 进行管理，而且作为单独的文件管理就比较好。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.zucchiniy.com/tags/git/"},{"name":"git-filter-repo","slug":"git-filter-repo","permalink":"https://blog.zucchiniy.com/tags/git-filter-repo/"}]},{"title":"因为生活感到了焦虑","slug":"journal/anxiety-from-life","date":"2021-03-29T07:33:00.000Z","updated":"2021-07-04T13:38:30.283Z","comments":true,"path":"posts/d554c002.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d554c002.html","excerpt":"","text":"前几天一个同时说有一个焦虑，感觉自己的生活没什么目标，完全是日复一日的循环。 之前我也遇到这种心情，感觉生活就像脱缰的野马一下，忽然就不在自己的可控范围内了。 每个人都会在生活中遇到焦虑，如何正确的面对焦虑是一个值得反复探讨的问题。 在焦虑的时候，最可怕的就是不知道自己为什么焦虑，只是觉得做任何事都提不起劲。这种时候往往是很难解决的，因为无法得知自己焦虑的原因，也就不能正确的面对自己的焦虑。 现在回头看一下自己的焦虑的原因，主要集中在几个地方，最大的原因就是因为生活的不可控，当生活中出现了某些自己不能掌握的事的时候，最有可能出现这种问题。面对生活中变化，自己不能解决的时候，就会有这种感觉。 这种焦虑主要是因为不自信造成的。面对一个问题，感觉超出了自己的掌握范围，找不到自己能力范围内的解决方案。 这种焦虑是最容易解决的，如果是工作相关的，就是到了自己的提升的时侯了，可以在工作中定一个新的学习目标，利用获得一个小成果的成功感来帮助调整自己的心态。 另外一些可能源自于自己的内心，来自于生活中的不可抗力，这种事儿可能就需要和自己的亲属、朋友进行一些交谈，让他们帮忙解决或者帮你开解。 等事情结束或者结束了这种焦虑之后，可能会发现，你为之焦虑的事情，并不是真的需要解决的事情。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"焦虑","slug":"焦虑","permalink":"https://blog.zucchiniy.com/tags/%E7%84%A6%E8%99%91/"},{"name":"面对焦虑","slug":"面对焦虑","permalink":"https://blog.zucchiniy.com/tags/%E9%9D%A2%E5%AF%B9%E7%84%A6%E8%99%91/"}]},{"title":"conda activate 不生效","slug":"backends/python/conda-activate-cannot-effect","date":"2021-03-26T08:27:00.000Z","updated":"2021-07-02T15:43:09.540Z","comments":true,"path":"posts/5adf061e.html","link":"","permalink":"https://blog.zucchiniy.com/posts/5adf061e.html","excerpt":"","text":"今天重新看了一下 conda 环境的问题，之前的理解是错误的，因为默认的环境变量配置在不启动 Tmux 的时候是能正常使用的，现在看主要原因是在启动 Tmux 的过程中。 重新检查了一下启动前后的环境变量，发现在启动 Tmux 之后，conda 的相关内容被转移到最后的，导致前面的环境变更覆盖掉了 conda 的环境变量。 正确的方法应该是在 $HOME 下新增一个 .zprofile 文件，然后再在文件中增加下面的内容： 1234if [ -x /usr/libexec/path_helper ]; then PATH=&quot;&quot; # &lt;- ADD THIS LINE (right before path_helper call) eval `/usr/libexec/path_helper -s`fi 重新加载一下配置文件，就可以正常的使用 conda 命令切换环境了。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"conda","slug":"conda","permalink":"https://blog.zucchiniy.com/tags/conda/"},{"name":"conda activate","slug":"conda-activate","permalink":"https://blog.zucchiniy.com/tags/conda-activate/"}]},{"title":"Plotly_express 保存图片","slug":"backends/python/plotly-express-save-image","date":"2021-03-18T08:26:00.000Z","updated":"2021-07-02T15:43:09.542Z","comments":true,"path":"posts/3f467d49.html","link":"","permalink":"https://blog.zucchiniy.com/posts/3f467d49.html","excerpt":"","text":"在使用 Plotly_express 快速绘图的时候，希望将生成的图片保存到本地。 首先需要安装必须的配置，因为我是使用的 anaconda 所以使用 Conda 进行安装。 1conda install -c conda-forge python-kaleido 如果是使用的 pip 管理的话，可以使用 pip install kaleido 直接安装。 然后在代码中增加下面的代码段： 123import plotly.graph_objects as gofig = go.Figure()fig.write_image(&quot;image.png&quot;) 如果希望保存的是其它类型的图片，则可以修改对应的后缀，包括 png/jpeg/wdbp/svg/pdf 等类型。 如果使用其它引擎进行图片生成的话，可以使用 fig.to_image(format=&#39;png&#39;, engine=&#39;kaleido&#39;)进行生成。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"Plotly express","slug":"Plotly-express","permalink":"https://blog.zucchiniy.com/tags/Plotly-express/"},{"name":"保存成图片","slug":"保存成图片","permalink":"https://blog.zucchiniy.com/tags/%E4%BF%9D%E5%AD%98%E6%88%90%E5%9B%BE%E7%89%87/"}]},{"title":"忘记 Django admin 管理员用户密码","slug":"backends/python/django-amdin-password","date":"2021-03-17T05:56:00.000Z","updated":"2021-07-02T15:43:09.540Z","comments":true,"path":"posts/9658455d.html","link":"","permalink":"https://blog.zucchiniy.com/posts/9658455d.html","excerpt":"","text":"通过 orm 修改用户密码首先通过 python manage.py shell 启动 django shell 环境。 然后通过下面的代码修改用户密码： 1234from django.contrib.auth.models import Useruser = User.objects.get(username = &#x27;username&#x27;)user.set_password(&#x27;new_password&#x27;)user.save() 执行上面的代码，就可以直接修改对应的密码了。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"Django admin","slug":"Django-admin","permalink":"https://blog.zucchiniy.com/tags/Django-admin/"}]},{"title":"Matplotlib 的使用及问题解决","slug":"backends/python/matplotlib-chinese-garbled","date":"2021-03-16T07:08:00.000Z","updated":"2021-07-02T15:43:09.541Z","comments":true,"path":"posts/1c5c5ae6.html","link":"","permalink":"https://blog.zucchiniy.com/posts/1c5c5ae6.html","excerpt":"","text":"安装安装的时候最好选择将 anaconda 加入到环境变量中，这样可以直接使用 conda 命令来管理包，而不需要增加额外的配置。 国内源镜像国内使用的话，镜像就还是用 清华大学开源软件镜像站 ，按步骤安装： 123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes 就可以了，如果是 conda 不包含的库的话，还是需要使用 pip 命令进行安装的，可以同样配置成清华源 1234567# 临时使用pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package# 设为默认值pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple# 但是这个需要 pip 版本在 10.0.0 以上，如果低的话，可以临时升级pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U 包管理12345678conda list #查看所有的包conda install package_name #安装包conda remove package_name #移除包conda update package_name #升级包conda search search_term #模糊查询包名conda update conda #更新 conda 本身conda update anaconda #更新 anacondaconda update python #更新 Python 中文乱码使用 Anaconda 进行数据处理后生成图片的时候，如果不指定对应字体会导致中文乱码，可以通过下面的方案进行解决。 12345from pylab import mpl# 指定默认字体：解决plot不能显示中文问题mpl.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;Microsoft YaHei&#x27;]# 解决保存图像是负号&#x27;-&#x27;显示为方块的问题mpl.raParams[&#x27;axes.unicode_minus&#x27;] = False Mac 下查找字体可以利用 font_manager 将所有 matplotlib 能使用的字体打印出来。 1234from matplotlib import font_managera = sorted([f.name for f in font_manager.fontManager.ttflist])for i in a: print(i) 如果 matplotlib 中无中文字体，则需要下载对应的 tff 字体只在到 matplotlib/mpl-data/fonts/tff 中，然后使用 font_manager 重新编译一下。 123from matplotlib.font_manager import _rebuild_rebuild() 之后就可以利用上面的方法，将使用新的字体了。 12plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;STFangsong&#x27;]plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://blog.zucchiniy.com/tags/Matplotlib/"}]},{"title":"二叉树前序序列化","slug":"backends/python/verify-preorder-serialization-of-a-binary-tree","date":"2021-03-12T05:04:00.000Z","updated":"2021-07-02T15:43:09.543Z","comments":true,"path":"posts/58e0c645.html","link":"","permalink":"https://blog.zucchiniy.com/posts/58e0c645.html","excerpt":"","text":"序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 1234567 _9_ / \\ 3 2 / \\ / \\ 4 1 # 6/ \\ / \\ / \\# # # # # # 例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。 LeetCode331. 验证二叉树的前序序列化 今天在力扣上看到一道二叉树的题，使用入度和出度的方法编写了实现的代码，如下： 1234567891011121314def isValidSerialization(preorder): s = preorder.split(&#x27;,&#x27;) length = len(s) res,i = 0,0 for c in s: if c != &#x27;#&#x27;: res += 1 else: res -= 1 i += 1 if(res&lt;0 and i &lt; length): return False return res == -1 在看其它人的题解思路的时候，发现一个使用栈替换的实现方法，非常巧妙，具体的思路是发现「A,#,#」的串的时候，则认为是一个正确的二叉树。 然后将其替换为 「#」，利用栈的进出策略，可以简单的实现代码： 123456789class Solution: def isValidSerialization(self, preorder): stack = [] for node in preorder.split(&#x27;,&#x27;): stack.append(node) while len(stack) &gt;= 3 and stack[-1] == stack[-2] == &#x27;#&#x27; and stack[-3] != &#x27;#&#x27;: stack.pop(), stack.pop(), stack.pop() stack.append(&#x27;#&#x27;) return len(stack) == 1 and stack.pop() == &#x27;#&#x27;","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.zucchiniy.com/tags/Leetcode/"}]},{"title":"微信读书阅读","slug":"journal/investment-learning-book-list","date":"2020-12-23T16:00:00.000Z","updated":"2021-07-02T15:43:09.546Z","comments":true,"path":"posts/5d589b9d.html","link":"","permalink":"https://blog.zucchiniy.com/posts/5d589b9d.html","excerpt":"","text":"股票期货 第 89 本：稳定获利3 [2020-12-16] 第 88 本：海龟交易法则 [2020-12-03] 第 87 本：趋势永存：打败市场的动量策略 [2020-12-03] 第 86 本：聪明的投资 [2020-11-22] 第 85 本：指数基金投资从入门到精通 [2020-11-14] 第 84 本：小散逆袭：手把手教你做量化定投 [2020-11-10] 第 83 本：指数基金投资指南（雪球【岛】系列） [2020-11-10] 第 82 本：小散逆袭：手把手教你做量化定投 [2020-11-10] 第 80 本：雪球专刊161期：小白必备：指数基金投资指南 [2020-11-08] 第 78 本：基金定投：让财富滚雪球 [2020-11-06] 程序员的自我修养 第 81 本：Python Django Web 典型模块开发实战 [2020-11-08] 第 79 本：Django 2.0 入门与实践 [2020-11-06] 第 77 本：深入核心的敏捷开发 [2020-11-04] 第 76 本：研发质量保障与工程效率 [2020-11-01] 第 75 本：Python 量化交易 [2020-10-31] 推理小说的补充 第 74 本：超杀人事件-推理作家的苦恼 [2020-10-29] 第 73 本：天使之耳：交通警察之夜 [2020-10-28] 第 72 本：遗忘者 [2020-10-18]","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"微信读书清单","slug":"微信读书清单","permalink":"https://blog.zucchiniy.com/tags/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"}],"author":"夏南瓜"},{"title":"股票数据库构建","slug":"backends/python/backtrader/build-stock-database-pool","date":"2020-10-07T18:06:00.000Z","updated":"2021-07-02T15:43:09.540Z","comments":true,"path":"posts/ed8ff4e7.html","link":"","permalink":"https://blog.zucchiniy.com/posts/ed8ff4e7.html","excerpt":"","text":"构建本地数据库123456789101112131415161718192021222324252627282930313233343536373839404142* 沪深所有股票 * 表中的字段对应tushare的stock_basic接口返回字段，可以查看此接口对应的字段解释 */CREATE TABLE `stocks` ( `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, `ts_code` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `symbol` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `area` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `industry` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `fullname` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `market` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `list_status` varchar(2) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL, `list_date` timestamp(0) NULL DEFAULT NULL, `delist_date` timestamp(0) NULL DEFAULT NULL, `is_hs` varchar(2) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `idx_stocks_ts_code`(`ts_code`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3836 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;/* * 沪深所有股票日交易数据 * 表中的字段解释对应tushare的daily接口返回字段，可以查看此接口对应的字段解释*/CREATE TABLE `trade_data` ( `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT, `ts_code` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `trade_date` timestamp(0) NULL DEFAULT NULL, `open` float NOT NULL DEFAULT 0, `high` float NOT NULL DEFAULT 0, `low` float NOT NULL, `close` float NOT NULL, `pre_close` float NOT NULL, `change` float NOT NULL, `pct_chg` float NOT NULL, `vol` float NOT NULL, `amount` float NOT NULL DEFAULT 0, `cdate` timestamp(0) NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0), PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `idx_trade_code_date`(`ts_code`, `trade_date`) USING BTREE, INDEX `idx_date_pct_chg`(`trade_date`, `pct_chg`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 7187583 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#x27;2002年至今日交易数据&#x27; ROW_FORMAT = Dynamic; 数据下载下载沪深所有股票基础信息 12data = pro.stock_basic(fields=&#x27;ts_code,symbol,name,fullname,area,industry,market,list_status,list_date,delist_date,is_hs&#x27;)pd.io.sql.to_sql(data, &#x27;stocks&#x27;, con=engine,index=False, if_exists=&#x27;append&#x27;,chunksize=500) 更新日交易数据 1234567891011121314# 批量更新日交易数据def update_trade(self,beg_id,end_id,start_date,end_date): session = DBSession() data = session.query(dbStock).filter(dbStock.id &lt; end_id+1, dbStock.id &gt; beg_id).all() for dt in data: daily = pro.daily(ts_code= dt.ts_code, start_date=start_date, end_date=end_date) print(&#x27;stock:%s,count:%s&#x27; % (dt.id,daily.shape[0])) pd.io.sql.to_sql(daily, &#x27;trade_data&#x27;, con=engine, index=False, if_exists=&#x27;append&#x27;, chunksize=500) print(&#x27;finshed&#x27;)# 调用方法id_ticket = 0 # id从1-50的股票，获取从20020418到2020601的交易数据update_trade(id_ticket, id_ticket + 50, &#x27;20020418&#x27;, &#x27;2020812&#x27;) 数据同步1234567891011# 每天更新股票交易数据def update_trade(): if is_holiday(): return False day = time.strftime(&#x27;%Y%m%d&#x27;, time.localtime()) daily = pro.daily(trade_date=day) pd.io.sql.to_sql(daily, &#x27;trade_data&#x27;, con=engine, index=False, if_exists=&#x27;append&#x27;, chunksize=500) print(&#x27;%s更新了%s条记录&#x27; % (day,len(daily)))# 定时任务设定每晚8:30更新schedule.every().day.at(&#x27;20:30&#x27;).do(on_timer, &#x27;update_trade&#x27;)","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"股票数据","slug":"股票数据","permalink":"https://blog.zucchiniy.com/tags/%E8%82%A1%E7%A5%A8%E6%95%B0%E6%8D%AE/"}]},{"title":"在 Windows 上安装 MySQL","slug":"backends/mysql/install-mysql-server-in-window","date":"2020-08-12T14:42:00.000Z","updated":"2021-07-02T15:43:09.539Z","comments":true,"path":"posts/a0232202.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a0232202.html","excerpt":"","text":"安装 MySQL从官方网站下载 MySQL 的安装包太慢了，这里推荐从 清华源 上下载，几分钟就能搞定。 下载之后，将 MySQL 安装对应的目录下，然后在其同级目录下建一个新的数据文件夹 mysqldata 。 配置 MySQL 文件在 MySQL 的目录下（bin 文件夹的同级目录）下新建一个空白 my.ini 文件。 文件内容如下： 12345678910111213141516171819202122232425262728[mysqld] # 设置mysql的安装目录，也就是刚才我们安装的目录basedir=&lt;安装目录&gt;# 设置mysql数据库的数据的存放目录，刚才创建的mysqldata目录datadir=&lt;新建目录&gt;# 设置默认使用的端口port=3306# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人试图攻击数据库max_connect_errors=10# 服务端使用的字符集character-set-server=utf8mb4# 数据库字符集对应一些排序等规则使用的字符集collation-server=utf8mb4_general_ci# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件作为认证加密方式# MySQL8.0默认认证加密方式为caching_sha2_passworddefault_authentication_plugin=mysql_native_password [mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4 [client]default-character-set=utf8mb4port=3306 初始化 MySQL 启动 命令提示符（管理员） mysqld --initialize-insecure --user=mysql --console 初始化 MySQL msyqld --install 安装 MySQL 的服务 启动 net start mysql 启动 MySQL 服务 注意：在启动服务前需要注意两点：1. 必须使用管理员权限；2. 必须在 mysql/bin 的目录下才能生效，否则会提示 系统错误2 这个时候 MySQL 就已经安装完毕，可以使用了。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"MySQL 安装","slug":"MySQL-安装","permalink":"https://blog.zucchiniy.com/tags/MySQL-%E5%AE%89%E8%A3%85/"}],"author":"zucchini"},{"title":"Emacs中配置使用Rime输入法","slug":"tools/emacs/emacs-rime-config","date":"2020-04-21T06:26:59.000Z","updated":"2021-07-02T15:43:09.551Z","comments":true,"path":"posts/2f2b0c30.html","link":"","permalink":"https://blog.zucchiniy.com/posts/2f2b0c30.html","excerpt":"","text":"在 Emacs 中使用外部输入法，最大的问题是在切换 evil 的模式的时候，对输入来说会有延迟，因为需要手工将输入法切换到对应的英文模式，才能正常使用快捷键。 但是如果使用的是 Emacs 自己的输入功能，则不需要做这些同步，只需要从 insert 模式中退出即可，这种操作对 Emacs 来说真的是太方便了。 之前使用的是 pyim + liberime 的方案，在今天更新了配置之后，无法再使用这个方案，调整配置之后，也无法正常使用，经过测试，将配置调整为 emacs-rime 的方案。 首先需要下载对应的内容：librime。 将解压之后的内容，放到 user-emacs-directory 路径下，然后增加配置。 1234567(use-package rime :config (setq rime-show-candidate &#x27;posframe) :custom (rime-librime-root (expand-file-name &quot;librime/dist&quot; user-emacs-directory)) (rime-emacs-module-header-root (expand-file-name &quot;extends&quot; user-emacs-directory)) (default-input-method &quot;rime&quot;)) 报错：Can’t find rime_api.h when compile 1(rime-librime-root (expand-file-name &quot;librime/dist&quot; user-emacs-directory)) 报错：Can’t find emacs-module.h when compile 先将 /Applications/Emacs.app/Contents/Resources/include/emacs-module.h 文件放到 .emacs.d/extends/ 下。 1(rime-emacs-module-header-root (expand-file-name &quot;extends&quot; user-emacs-directory)) 经过这样的配置之后，就能非常容易的在 Emacs 中使用 rime 输入法了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"librime","slug":"librime","permalink":"https://blog.zucchiniy.com/tags/librime/"},{"name":"emacs-rime","slug":"emacs-rime","permalink":"https://blog.zucchiniy.com/tags/emacs-rime/"}]},{"title":"编译 librime 和 liberime","slug":"tools/emacs/liberime-librime-compile","date":"2020-04-21T06:26:59.000Z","updated":"2021-07-02T15:43:09.551Z","comments":true,"path":"posts/b325b5d6.html","link":"","permalink":"https://blog.zucchiniy.com/posts/b325b5d6.html","excerpt":"","text":"编译 librime因为本人使用的是 Mac 系统，所以需要先安装一些工具。 1brew install cmake git boost 这三个工具是编译 liberime 用的，本来想从 GitHub 上下载，但是有问题，所以决定自己编译一份，这里测试了一下，只使用 CommandLineTools 是不行的，需要安全安装 xcode 才可以。 下载 librime 版本库 1git clone --recursive https://github.com/rime/librime.git 编译第三方库 12cd librimemake xcode/thirdparty 编译 librime 1make xcode 编译 liberime编译这个是依赖于 librime 文件的，需要先将依赖引进来。 下载 liberime 项目 1git clone git@github.com:merrickluo/liberime.git 引入 librime 依赖 1export RIME_PATH=~/DEV/librime 编译 liberime 文件 1make liberime-core","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"librime","slug":"librime","permalink":"https://blog.zucchiniy.com/tags/librime/"},{"name":"liberime","slug":"liberime","permalink":"https://blog.zucchiniy.com/tags/liberime/"}]},{"title":"面向对象设计原则笔记","slug":"backends/python/oop-solid-md","date":"2020-03-23T09:03:35.000Z","updated":"2021-07-02T15:43:09.541Z","comments":true,"path":"posts/cdbcd916.html","link":"","permalink":"https://blog.zucchiniy.com/posts/cdbcd916.html","excerpt":"","text":"Single responsibility principle 单一职责原则原理一个类应该仅仅只有一个被修改的理由，也就是一个类只有一个职责；而不是一种功能。 缺点 因为不同原因修改类的时候，也可能因为不相关的修改导致功能间的相互影响。 单个类承担的职责越多，意味着类的复杂度也就越高，维护成功也就越高。 如何解决 拆分大类为多个小类 将一些功能抽取为公共的函数 Open-closed principle 开放－关闭原则原理类应该对扩展开放，对修改封闭；应该可以在不修改某个类的前提下，扩展它的行为。 改造方法使用类继承来改造代码找到你类中会变动的部分，将其抽象成新的方法或者属性，最终允许新的子类来重写它以改变类似的行为。 使用组合与信赖注入来改造代码将需要变化的内容，抽象为类，并将不同的原则实现不同的类，在调用主类进行操作的时间，不同的继承结果会让类有不同的变化，但是这种方案，并不会修改主类，因为接受的类型为变化的类的祖先，也就是保证的类的不变，但是传入的内容变化却是变的。 使用数据驱动思想来改造代码数据驱动也就是将经常变化的东西完全以数据的方式抽离出来，当需求变动时，只改动数据，代码逻辑保持不变。 三种方案的区别类继承与依赖注入方式的区别两个原则都运用了继承来优化代码，第一个方案重点在于扩展类的行为，但是又保证父类的行为不变；第二种方案是将扩展行为的变量抽象出来，类本身的行为一直没有变化，主要都是接受抽象出来的类进行变化，保证可变量才能变。这种明显比第一种方案更为优越。但是理解和拆分也更有难度。 依赖注入与数据驱动方式的区别依赖注入和数据驱动的两种改造方案非常相似，主要方案就是将变的内容抽离到类的外部，区别主要在于依赖注入主要是抽离类，通过类的变化来控制行为变化，而数据驱动抽离的是数据内容。 数据驱动的特点与继承和依赖注入方式相比，数据驱动更简洁，不需地定义额外的类，但是同样也不缺点，也就是数据都是既定的内容，如果是传入的内容本身就是一种形态，数据的方案也就不可靠了。在使用中可以认为，如果是既定内容，可以简单的使用数据驱动来做，如果是某种类型，使用扩展类（依赖注入、类继承）的方式更好用。 Liskov Substitution Principle 里氏替换原则特点 继承、多态与封装，属于面向对象编程的几大核心特征。里氏替换原则对继承有指导意义。 使用继承时，子类对象应该可以在程序中替代父类对象使用，而不破坏程序原本的功能。 尽量将可变的行为做为类的一个属性（可变），并提供方法可以修改这个行为。 需要让子类方法和父类方法返回同一类型的结果，支持同样的操作。或者更进一步，返回支持更多种操作的子类型结果也是可以授受的。 子类方法参数应该和父类方法同名方法完全一致，或者更为宽松。 Interface Segregation Principle 接口隔离原则什么是接口接口是模块间相互交流的抽象协议。 遵守的原则 客户(client)应该不依赖于它不使用的方法。 一个接口所提供的方法，应该就是使用方所需要的方法。而更多的接口方法意味着更高的实现成本，给实现方带来更多的出错机率。 让客户（调用方）来驱动协议设计。在有多余的依赖时，找出最小类，然后依据不同的依赖关系，继承出更小的类。 Dependency Inversion Principle 依赖倒置原则特征 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。 通过编写测试反向推动设计改进。 抽象解耦了高层模块和低层模块间的依赖关系，让代码更灵活。但抽象同时也带来了额外的编程与理解成本。而只有对代码中现在或者未来会发生变化的东西进行抽象，才能获得最大的利益。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"https://blog.zucchiniy.com/tags/SOLID/"}]},{"title":"Hexo 引用自己撰写的文章","slug":"tools/hexo-post-link","date":"2020-01-15T06:20:52.000Z","updated":"2021-07-02T15:43:09.555Z","comments":true,"path":"posts/bd7386da.html","link":"","permalink":"https://blog.zucchiniy.com/posts/bd7386da.html","excerpt":"","text":"文章中，有时候需要自己给自己引流，所以经常要引用自己的文章，原来在使用 Hugo 的时候，是用的直接写入文章最终链接的方法引用，虽然可以成功的引用文章，但是如果原本的文章链接变化了，就不能使用了，所以最好的方法就是在生成系统之内直接引用。 Hexo 提供了 标签插件 来完成这个功能。 :::markdown &#123;% post_path filename %&#125; &#123;% post_link filename [title] [escape] %&#125; 比如想要引用我的某一篇文章，需要写 post_link &#39;工具环境/github-jsDelivr&#39; 就可以在文章中看到：Post not found: 工具环境/github-jsDelivr，这样就可以进行站内文章的引用了，这里展示的是文章中的 title 字段，而不是文件名，但是要注意的是，这里默认的路径是在 _post 路径下，如果不是默认路径，需要写上相对路径。 当然，也可以按自己的想法，定义一个名称，比如 post_link &#39;工具环境/github-jsDelivr&#39; &#39;测试&#39; 这样，我们看到的链接是有个人定义的名称的：Post not found: 工具环境/github-jsDelivr 测试。这两个展示的名称不同，但是最终指向的都是同一篇文章。 另外还有一种方案，是使用 post_path 指定文章的链接地址，但是不是链接，比如 post_path &#39;工具环境/github-jsDelivr&#39;，我们在文章中看到的是: ，主要可以直接插入文件链接，也很方便。 相比较而言，post_link 的方式更常用，但是有些时候，使用 post_path 也可以帮助我们获取信息。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Hexo","slug":"工具环境/Hexo","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Hexo/"}],"tags":[{"name":"post link","slug":"post-link","permalink":"https://blog.zucchiniy.com/tags/post-link/"},{"name":"post path","slug":"post-path","permalink":"https://blog.zucchiniy.com/tags/post-path/"}]},{"title":"GitHub 做为博客图床","slug":"tools/github-jsDelivr","date":"2020-01-15T02:48:57.000Z","updated":"2021-07-02T15:43:09.555Z","comments":true,"path":"posts/de549f00.html","link":"","permalink":"https://blog.zucchiniy.com/posts/de549f00.html","excerpt":"","text":"博客上传到 GitHub 之后，访问文章中的图片会有一些慢，如果是比较大的图片就更慢了。 之前是通过使用的一些公共的图床网站解决的，但是会有大小和数量的限制，最近看到一个图床应用jsDelivr，这个可以直接访问 GitHub 里的图片信息，所以调整了一下原本的图床方案。 使用也非常容易： 在 GitHub 上新建一个版本库，然后将图片放到项目中，上传到对应的分支，比如 master 分支，我的示例是在 blog-assets 项目，比如图片放在 avatar 路径下，文件名叫 _lvzai.jpg_——也就是我博客的用户头像，然后将相关内容上传到 GitHub 上之后，就可以通过 https://cdn.jsdelivr.net/gh/zucchiniy/blog-assets@master/avatar/lvzai.jpg 查看图片了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"GitHub","slug":"工具环境/GitHub","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/GitHub/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://blog.zucchiniy.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"jsdelivr","slug":"jsdelivr","permalink":"https://blog.zucchiniy.com/tags/jsdelivr/"},{"name":"github","slug":"github","permalink":"https://blog.zucchiniy.com/tags/github/"}]},{"title":"统计每天的工作时长","slug":"tools/emacs/emacs-clocktable","date":"2020-01-14T07:53:21.000Z","updated":"2021-07-02T15:43:09.549Z","comments":true,"path":"posts/12c28564.html","link":"","permalink":"https://blog.zucchiniy.com/posts/12c28564.html","excerpt":"","text":"作为一个 Emacs 的使用者，一直都希望可以完全的使用 Emacs 进行时间管理，而作为时间管理中的重头戏——番茄时间，在 Org 也是一个常用的功能。 按自己的工作专注程序，我用的更多的是 clock-in 和 clock-out 的功能来记录时间。然后在每周结束的时候，进行时间任务的复盘，虽然不能把所有的任务都放到 Org 中管理，但至少和电脑相关的任务都可以这么记录。 复盘的时候需要看在一段时间之内，到底都做了哪些事情，这里就需要用到 Org mode 中的 Clocktable 功能，对应的命令是 org-clock-report ，在这之后会生成一个对应的的时间表格： 1234567891011121314#+CAPTION: Clock summary at [2020-01-14 Tue 16:02], for January 2020.| File | Headline | Time | ||-------------------|-------------------------|------------|----------|| | ALL *Total time* | *2d 13:40* | ||-------------------|-------------------------|------------|----------|| tasks.org | *File time* | *2d 13:40* | || | Tasks | 2d 9:07 | || | \\_ Emacs 配置 | | 0:29 || | \\_ 调整 hexo 博客主题 | | 1d 10:21 || | \\_ markdown-it-plugins | | 22:17 || | Habits | 4:33 | || | \\_ 英语单词 | | 4:33 ||-------------------|-------------------------|------------|----------|| tasks.org_archive | *File time* | *0:00* | | 可以看到，这个是按文件进行的统计，目前都是在 task.org 文件中的任务。这里也可以选择按自己的想法进行统计。 1#+BEGIN: clocktable :scope agenda-with-archives :block thismonth :maxlevel 2 这里主要是几个参数： scope: 统计范围，可以按文件统计，也可以按其它的范围进行统计。 block: 时间跨度，可以是今天 today 本星期 thisweek 或者是本月 thismonth,当然也可以是今年 thisyear，或者是按季度进行统计 2020-Q1 当然也支持按星期统计 2020-W2 step: 跨度，可以是天 day，星期 week，年 year 其它的参数可以参照The clock table，常用的主要就是这几个参数。 这些配置之后，就可以看天看自己到底花了多少时间在正经事儿上了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[]},{"title":"XPath 使用笔记","slug":"fronts/xpath-basis","date":"2020-01-12T16:00:00.000Z","updated":"2021-07-02T15:43:09.544Z","comments":true,"path":"posts/488854a9.html","link":"","permalink":"https://blog.zucchiniy.com/posts/488854a9.html","excerpt":"","text":"xpath 的语法主要是使用的 /name/*[]|//*[@name] 的语法规则。 定位节点 节点主要是使用的 id 或者是 classname 进行匹配的，这种情况下，如果是 / 则表示找某一层，如果是 // 进行匹配，则表示是任意位置的某个层，如果用 * 则表示任意名称。 比如：/cd 是指的 classname 为 cd 的结构，而且是第一层就是 cd，如果是 //cd 则表示其中某层为 cd 但是可以不是最外层。 选择分支 使用中括号可以选择分支。以下的语法从 catalog 的子元素中取出第一个叫做 cd 的元素。XPath 的定义中没有第 0 元素这种东西。而且当我们想要选取某类值的时候，可以认为 [] 中的是属性的名称，比如 //cata[@name] 是找的任意 cata 层中包含 name 属性的元素位置。 在属性之外，还有一种是索引查找方式，比如 //cata[1] 表示查找任意 cata 层中的第一个分支，这里索引是从 1 开始，而不是 0 开始，如果查找最后一个，则需要使用 cata[last()] 去找，这里只有 last() 方法，不存在 first() 方法。 如果是 [] 中的内容没有 @ 符号，又不是索引值（数字）或者是 last() 方法的话，则表示找出包含某个子元素的情况，比如 //cata/cd[pr] 表示包含 pr 的 /cata/cd 层。如果想指定元素的值，则可以在括号中增加对应的匹配 //cata/cd[pr=1.0] 。 | 在 xpath 中表示或者关系，即符合前面的，或者后面的内容，比如 /cata/pr | /cata/pm 两种我全要的意思。 选择属性 如果某一个值是用 @ 作为开始，则表示是属性，基本的语法和层的 / 是一致的，区别是可以多个属性并存，即 /ca[@na=&#39;uu&#39;][@nb=&#39;zz&#39;] ，这样就是找到 cd 层中属性 na 是 uu 且 属性 nb 是 zz 的元素。 特殊方法 contains(): 包含语法，比如 /ca[contains(@name,&#39;na&#39;)] name 属性中包含 na 的元素text(): 显示文本信息，这里对应的可以用来查询，而且进行其它操作，是对元素属性的补充starts-with(): 开始于，比如 /ca[starts-with(@name,&#39;na&#39;)] name 属性开始位置包含 na","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"xpath","slug":"前端技术/xpath","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/xpath/"}],"tags":[{"name":"定位节点","slug":"定位节点","permalink":"https://blog.zucchiniy.com/tags/%E5%AE%9A%E4%BD%8D%E8%8A%82%E7%82%B9/"},{"name":"正则匹配","slug":"正则匹配","permalink":"https://blog.zucchiniy.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"}]},{"title":"Emacs Org mode 小技巧","slug":"tools/emacs/org-mode-use-tips","date":"2020-01-12T10:38:24.000Z","updated":"2021-07-02T15:43:09.552Z","comments":true,"path":"posts/5f8ba428.html","link":"","permalink":"https://blog.zucchiniy.com/posts/5f8ba428.html","excerpt":"","text":"启用转义符转义在 Org Mode 写一些笔记的时候，经常会用到下划线 -，而 a_b 总是会变成 ab 的形式，可以通过在文档的最上面，增加配置来关闭自动转义，对于在文章头部加上了 #+OPTIONS: ^:nil , 还可以通过配置 (setq org-use-sub-superscripts nil) 的方式来实现全局配置。 用 ditaa 绘制图形12345678910111213141516171819202122232425262728293031323334#+BEGIN_SRC ditaa :file ../images/linux-os.png :exports both :cmdline -E -r -s 1.0+---------------------------------------------------------+| Applications || +----------------------------------------------------+| | System Libraries |+----+----------------------------------------------------+| System Call Interface |+------------------------+--------------+-----------------+ +---------+| VFS | Socket | | | |+------------------------+--------------+ Scheduler +-------+ CPU || File Systems | TCP/UDP | | | |+------------------------+--------------+-----------------+ +----+----+| Volume Manager | IP | Virtual | |+------------------------+--------------+ Memory | || Block Device Interface | Ethernet | | |+------------------------+--------------+-----------------+ +----+----+| Device Driver | | DRAM |+-----------------------------+---------------------------+ +---------+ | | +-------+--------+ | I/O Bridge | +-------+--------+ | | ------+-----------------+--------------------+------ | | +---------+--------+ +----------+---------+ | I/O Controller | | Network Controller | +-+-------+------+-+ +----+----------+----+ | | | | |+---+---+ | +---+---+ +----+----+ +---+----+| Disk | ... | Swap | | Port | | Port |+-------+ +-------+ +---------+ +--------+","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"org mode","slug":"org-mode","permalink":"https://blog.zucchiniy.com/tags/org-mode/"},{"name":"use-sub-superscripts","slug":"use-sub-superscripts","permalink":"https://blog.zucchiniy.com/tags/use-sub-superscripts/"},{"name":"ditaa","slug":"ditaa","permalink":"https://blog.zucchiniy.com/tags/ditaa/"}]},{"title":"Emacs 扩展 Evil 功能","slug":"tools/emacs/evil-functions","date":"2020-01-12T10:21:13.000Z","updated":"2021-07-02T15:43:09.551Z","comments":true,"path":"posts/d51ccb9b.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d51ccb9b.html","excerpt":"","text":"Evil 多光标模式今天在修改代码的过程中，发现有一些地方，想使用多光标来修改，但是在使用的时候，感觉不太会用 evil mc ，中间切换到了 multiple-cursors 包上，但是在 evil 模式下使用，因为模式切换的情况，修改代码的时候会弹出一些奇怪的提示，因为模式的切换的问题，所以又换到了 evil-mc 上。 如果想要修改一个对应的内容，首先需要进行 visual 模式，然后使用 C-n 进行选择，然后修改，然后 grq 退出功能。 常用的快捷键如下：C-n: 标记当前，找下一个匹配值C-p: 标记肖前，找上一个匹配值M-n: 在已经标记的光标中向后跳转M-p: 向前C-t: 跳过这个，找下一个相同的内容，具体使用过之后，感觉不好用，没有grn: 同上grf: 跳到标记的第一个grl: 跳到标记的最后一个grj: 标记这个位置的的下一行的同一位置grk: 是标记上一行的相同位置grs: 暂停光标移动grr: 恢复光标移动 关闭 evil 功能在最近一段时间的使用过程中，发现 Evil 虽然在某些时候要比 Emacs 的操作更方便，但是在一些 Emacs 的默认使用过程中，还是 Emacs 的更好用，比如说 dired 中。 刚开始希望可以只在 编辑模式 中使用 Evil ，比如 org mode 、python mode 这类，但是在配置的时候发现，evil hook 并没有启作用。 12(use-package evil :hook (org-mode . evil-mode)) 但是这种方案并不能实现在阅读一些相关文档的过程中发现，可以使用另一个方法来修正这个问题，即在一些特殊的 mode 中关闭 evil 。 123(use-package evil :config (evil-set-initial-state &#x27;dired-mode &#x27;emacs)) 这样就可以让我们在使用过程中更适合的方式操作了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"Evil Multiple cursors","slug":"Evil-Multiple-cursors","permalink":"https://blog.zucchiniy.com/tags/Evil-Multiple-cursors/"},{"name":"turn evil mode off","slug":"turn-evil-mode-off","permalink":"https://blog.zucchiniy.com/tags/turn-evil-mode-off/"}]},{"title":"Hexo 中使用 emoji 和 tasks","slug":"fronts/hexo-markdown-tasks-emoji","date":"2020-01-11T13:06:58.000Z","updated":"2021-07-02T15:43:09.543Z","comments":true,"path":"posts/953e2b.html","link":"","permalink":"https://blog.zucchiniy.com/posts/953e2b.html","excerpt":"","text":"替换为 markdown-it今天在迁移博客项目的时候，发现原来在 hugo 中可以使用的 Emoji 和 tasks 功能都不能正常使用了，查询了一下原因，主要是因为 hexo 默认的解析器是 hexo-renderer-marked ，这个默认的渲染器是不支持 emoji 功能的，但是支持 tasks，但是这个渲染器是不支持扩展的，所以如果希望同时使用这两个功能的话，就需要换一个渲染器。 这里推荐的是 hexo-renderer-markdown-it 渲染器，支持扩展，采用的是 markdown-it 的内核来解析 markdown 的文本。 12npm un hexo-renderer-marked -Snpm i hexo-renderer-markdown-it -S 安装和配置 markdown-it这样就替换完成了，然后再安装需要的插件： npm i markdown-it-emoji markdown-it-task-lists -S 然后再增加相关配置： 1234567891011121314151617181920212223markdown: render: html: true # 在 markdown 文本中支持 html tag 标签 xhtmlOut: false # 需要 xtml 文档，使用 &lt;br /&gt; 替代 &lt;br&gt; breaks: true # 用 &lt;br&gt; 开始新的一行 linkify: true # 自动将 可能是链接的内容转换成链接 typographer: true # 印刷标识转换 plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-emoji - markdown-it-task-lists anchors: level: 2 collisionSuffix: &#x27;&#x27; permalink: false, permalinkClass: &#x27;header-anchor&#x27; permalinkSymbol: &#x27;&#x27; case: 0 separator: &#x27;&#x27; typographer 解释： 将 (c) (C) (r) (R) (tm) (TM) (p) (P) +- 这些标识转换成 © © ® ® ™ ™ § § ± 。 一些常用的插件，比如上标和下标，可以在插件里加上 markdown-it-sub 和 markdown-it-sup ，可以直接用 19^th^ 19^th^ 还有 H~2~O 表示 H2O 。 还有脚本、定义列表等功能，具体的见 https://markdown-it.github.io/ 。 其它插件因为 markdown-it 是支持扩展的，所以怎么找对应的扩展，也是非常重要的功能，比如 tasks 的支持，可以到 https://www.npmjs.com/ 里进行搜索，关键字是 keywords:markdown-it-plugin 或者直接打开链接 https://www.npmjs.com/search?q=keywords:markdown-it-plugin 。 就可以按照对应的功能去找寻找插件了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"hexo","slug":"工具环境/hexo","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/hexo/"}],"tags":[{"name":"markdown-it","slug":"markdown-it","permalink":"https://blog.zucchiniy.com/tags/markdown-it/"},{"name":"emoji","slug":"emoji","permalink":"https://blog.zucchiniy.com/tags/emoji/"},{"name":"tasks","slug":"tasks","permalink":"https://blog.zucchiniy.com/tags/tasks/"}]},{"title":"Emacs 快捷键配置方案","slug":"tools/emacs/keybinds-config-in-emacs","date":"2020-01-07T16:00:00.000Z","updated":"2021-07-02T15:43:09.551Z","comments":true,"path":"posts/86598d2e.html","link":"","permalink":"https://blog.zucchiniy.com/posts/86598d2e.html","excerpt":"","text":"Emacs 的快捷键和 Vim 的快捷键是编辑器中的两坐高山，其中 Emacs 的快捷键主要有四类。 四大类型 全局快捷键 1(global-set-key (kdb &quot;a&quot;) &#x27;command) 全局映射键 1(define-key key-translation-map (kbd &quot;a&quot;) (kdb &quot;b&quot;)) Major-mode 局部快捷键 1(local-set-key (kdb &quot;a&quot;) &#x27;command) Minor-mode 局部快捷键 1(define-key your-minor-mode-map (kbd &quot;a&quot;) &#x27;command) 删除、禁用快捷键12(global/local-unset-key (kbd &quot;a&quot;))(global/local-set-key (kbd &quot;a&quot;) &#x27;ignore/nil) 键冲突与解决最方便的解决方案是找一个空置的 prefix 键，先映射到这个键上，再全局或者局部设置它。 先映射到空闲键上1(define-key key-translation-map (kbd &quot;a&quot;) (kbd &quot;M-g A&quot;)) 全局或者局部设置1(global/local-set-key (kbd &quot;M-g A&quot;) &#x27;command) 快捷键优先级key-translation-map : 最高级，就是把这个键的意义改变了，想使用原来的快捷键，要重新进行绑定 minor-mode-map : 二级，只在 minor mode 激活时启作用，其它时候会被其它的快捷键覆盖掉 local-set-key : 三级，在 major mode 中启作用 global-set-key : 最弱的级别，但是也是最简单的键绑定方式 设置局域快捷键1234(defun f-python-mode () (local-set-key (kbd &quot;C-x C-e&quot;)&#x27;f-python-shell-send-line) (local-set-key (kbd &quot;M-g C-y&quot;) &#x27;f-python-shell-send-line))(add-hook &#x27;python-mode-hook &#x27;f-python-mode) 注意 当键进行重新绑定后，还应该将之前的功能重新绑定到另一个键上。 Minor Mode Map1234567(define-minor-mode visual-mode :init-value nil :global t :keymap (make-sparse-keymap) (if (not visual-mode) (setq cursor-type &#x27;bar) (setq cursor-type &#x27;box)))(define-key visual-mode-map (kbd &quot;h&quot;) &#x27;mark-paragraph) 定义之后，可以利用 define-key 来设置当前快捷键。然后在需要启用 Visual mode 的时候可以启用这个 minor mode 的相关快捷键。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"keybinds","slug":"keybinds","permalink":"https://blog.zucchiniy.com/tags/keybinds/"}]},{"title":"GDB 调试笔记","slug":"tools/linux/how-to-use-gdb-to-debug-program","date":"2020-01-07T16:00:00.000Z","updated":"2021-07-02T15:43:09.556Z","comments":true,"path":"posts/efe1991f.html","link":"","permalink":"https://blog.zucchiniy.com/posts/efe1991f.html","excerpt":"","text":"GDB 是一个由 GNU 开源组织发布的 *.nix 下的、基于命令行的一款比较知名的程序调试工具。 GDB 有着相当多的命令，但是常用的只有大概十个左右。 gdb命令一般可以使用 gdb program 或者使用 gdb progrma core 。如果想对正在执行的进程进行调试，则可以使用 gdb -p 123 。 常见命令 命令 解释 示例 file 加载被调试的可执行程序文件。因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。 (gdb) file gdb-sample r run的简写，运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。 (gdb) r c Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。 (gdb) c b &lt;行号&gt;b &lt;函数名称&gt;b \\*&lt;函数名称&gt;b \\*&lt;代码地址&gt; d [编号] b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。其中在函数名称前面加“\\*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 (gdb) b 8(gdb) b main(gdb) b \\*main(gdb) b \\*0x804835c(gdb) d bt 查看函数运行时堆栈 (gdb) bt disas 默认反汇编对应的方法 (gdb) disas s, n s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；n: 执行一行源程序代码，此行代码中的函数调用也一并执行。s 相当于其它调试器中的“Step Into (单步跟踪进入)”；n 相当于其它调试器中的“Step Over (单步跟踪)”。这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 (gdb) s(gdb) n si, ni si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。 (gdb) si(gdb) ni p &lt;变量名称&gt; Print的简写，显示指定变量（临时变量或全局变量）的值。 (gdb) p i(gdb) p nGlobalVar(gdb) p/a display ... undisplay &lt;编号&gt; display，设置程序中断后欲显示的数据及其格式。例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令“display /i $pc”其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。undispaly，取消先前的display设置，编号从1开始递增。 (gdb) display /i $pc(gdb) undisplay 1 i Info的简写，用于显示各类信息，详情请查阅“help i”。 (gdb) i r 打印寄存器(gdb) i proc m 检查是否为有效地址 reverse-stepi 回退之前执行过的指令 (gdb) reverse-stepi q Quit的简写，退出GDB调试环境。 (gdb) q record 录制程序过程 (gdb) record help [命令名称] GDB帮助命令，提供对GDB名种命令的解释说明。如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。 (gdb) help display 用法总结这里的总结主要是整理自 gdb 调试入门，大牛写的高质量指南，我觉得这篇文章是可以反复阅读的好文章。 发现这篇文章已经不存在了，希望我现在写的这篇总结对大家有帮助吧。 补充小工具python dbg工具，可以通过 apt-get install -y python-dbg 进行安装，然后可以在其中使用 py-bt 、 py-list 等命令。 另外还有一个工具是 cscope ，主要用来遍历代码用的。 cscope -bqR : 建立查找数据库 cscope -dq : 启动cscope","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://blog.zucchiniy.com/tags/gdb/"}]},{"title":"利用 find 和 grep 联合查找文件","slug":"tools/linux/find-files-on-linux","date":"2020-01-06T16:00:00.000Z","updated":"2021-07-02T15:43:09.556Z","comments":true,"path":"posts/3fcde5df.html","link":"","permalink":"https://blog.zucchiniy.com/posts/3fcde5df.html","excerpt":"","text":"Linux 下 使用 find 命令查找文件。 常用组合 查找所有 .h 文件 1find &lt;pathname&gt; -name &quot;*.h&quot; 查找所有 .h 文件中的含有 helloworld 字符串的文件 12find &lt;pathname&gt; -name &quot;*.h&quot; -exec grep -in &quot;helloworld&quot; &#123;&#125; \\;find &lt;pathname&gt; -name &quot;*.h&quot; | xargs grep -in &quot;helloworld&quot; 第一个命令中的 &#123;&#125; 是指的 find &lt;pathname&gt; -name &quot;*.h&quot; 的结果，也是就说，第一个命令中 grep 是在 find 查到的结果中进行二次筛选操作。而后面的 \\; 则是语句的结束标识，也就是转义的 ; 。 第二个命令则是使用的管道。 查找所有 .h 和 .c 文件中的含有 helloworld 字符串的文件 1find &lt;pathname&gt; /( -name &quot;*.h&quot; -or -name &quot;*.c&quot; /) -exec grep -in &quot;helloworld&quot; &#123;&#125; \\; 查找非备份文件中的含有 helloworld 字符串的文件 1find &lt;pathname&gt; /( -not -name &quot;*~&quot; /) -exec grep -in &quot;helloworld&quot; &#123;&#125; \\; &lt;pathname&gt; 为查找路径，默认为当前路径。带 -exec 参数时必须以 ; 结尾，否则会提示 『find: 遗漏 -exec 的参数』。 使用 find 和 xargsfind &lt;pathname&gt; -options [-print -exec -ok] -optinos -name:按照文件名查找12find ~ -name “*.txt” -printfind ~ -name “[a-z][0-9].txt -print -perm:按照权限查找文件123find ~ -perm 755 -print #查找权限为755的文件find ~ -perm 007 -print #查找o位置上具有7权限的文件find ~ -perm 4000 -print #查找具有suid的文件 -prune不在当前目录下查找 -user 和 -nouser12find ~ -user zhao -print #查找文件属主是zhao的文件find ~ -nouser -print #查找文件属主已经被删除的文件 -group和－nogroup1find ~ -group zhao -print #查找文件群组是zhao的文件 按照时间123find ~ -mtime -5 -print #文件更改时间在5天内的文件find ~ -mtime +3 -print #文件更改时间在3天前的文件find ~ -newer file1 -print #查找比文件file1新的文件 按照类型查找1find ~ -type d -print #查找所有目录 按照大小1find ~ -size +1000000C -print #查找文件大小大于1000000字节(1M)的文件 查找位于本文件系统里面的文件1find / -name &quot;*.txt&quot; -mount -print -exec , -ok : find 命令对于匹配文件执行该参数所给出 shell 命令，相应命令形式为: &#39;command&#39; &#123;&#125; \\;-ok 在执行命令前要确认 123find ~ -type f -exec ls -l &#123;&#125; \\;find / -name “*.log” -mtime +5 -ok rm &#123;&#125; \\;find . -name core -exec rm &#123;&#125; \\; 使用 -x dev 参数防止 find 搜索其他分区find . -size 0 -exec rm &#123;&#125; \\; 删除尺寸为０的文件 xargs 与-exec 功能类似 123find ~ -type f | xargs ls -lfind / -name “*.log” -type f -print| xargs grep -i DB0find . -type f |xargs grep -i “Mary” 在所有文件中检索字符串 Mary ls *~ |xargs rm -rf 删除所有以~结尾的文件 过滤 svn 文件夹 使用管道进行双层“过滤”，其中第二次 grep 使用了 -v 选项，即逆向匹配，打印出不匹配的行 grep -r &#39;function_name&#39; * | grep -v &#39;.svn&#39; 或者更简单一些，直接使用 --exclude-dir 选项，即指定排除目录，注意 svn 前的 \\. 1grep -r --exclude-dir=\\.svn &#x27;function_name&#x27; * 多个过滤条件或操作123grep -E &#x27;123|abc&#x27; filename # 找出文件（filename）中包含123或者包含abc的行egrep &#x27;123|abc&#x27; filename # 用egrep同样可以实现awk &#x27;/123|abc/&#x27; filename # awk 的实现方式 与操作grep pattern1 files | grep pattern2 显示既匹配 pattern1 又匹配 pattern2 的行。 其他操作12345grep -i pattern files #不区分大小写地搜索。默认情况区分大小写，grep -l pattern files #只列出匹配的文件名，grep -L pattern files #列出不匹配的文件名，grep -w pattern files #只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），grep -C number pattern files #匹配的上下文分别显示[number]行， find 过滤 svn 文件夹find -type f ! -path &#39;*/.svn/*&#39; find 查找大文件1find . -type f -size +800M type 类型 : b 块设备， d 目录， c 字符设备文档， p 管道文档， l 符号链接文档， f 普通文档 name 文件名 : 支持通配符 size 文件大小 : + 表示大于， - 表示小于，支持 k/M/G 的单位 1find . -type f -size +800M | xargs ls -lh 这里的 xargs 是把管理参数切分成多个部分，可以将命令进行组合 du 查找大目录123du -h --max-depth=1du -hm --max-depth=2 | sort -ndu -hm --max-depth=2 | sort -nr | head -12","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"find","slug":"find","permalink":"https://blog.zucchiniy.com/tags/find/"},{"name":"grep","slug":"grep","permalink":"https://blog.zucchiniy.com/tags/grep/"},{"name":"du","slug":"du","permalink":"https://blog.zucchiniy.com/tags/du/"}]},{"title":"搭建个人博客","slug":"tools/build-blog-with-hexo","date":"2020-01-04T16:00:00.000Z","updated":"2021-07-02T15:43:09.548Z","comments":true,"path":"posts/c442673f.html","link":"","permalink":"https://blog.zucchiniy.com/posts/c442673f.html","excerpt":"","text":"我们无法选择生活的样子，但我们可以记下来。 博客的开始其实，一切都是为了更好的装逼。好吧，我着相了。 最开始想做一个自己博客，主要是因为看到了很多人都有，觉得自己没有太 Low 了。于是申请了 CSDN 的用户，但是太丑了，于是又申请了博客园，感觉这些都不是我想要的，而做为一个 Emacser 不使用 Github 搭建一个自己的博客，感觉就已经落伍了。 于是就有这最初的一个，相当简陋的利用 Emacs 的 Org-mode 搭建的博客，后来看了 Org-page 这个包，但是，我配置不好啊！为什么为什么！ 最后，从 Hugo 和 Hexo 之间，我选择了 Hexo，虽然 Hugo 在 Windows 上使用起来更方便，但是我还是觉得 Hexo 更适合我。 利用 Hexo 的坑 有些插件需要翻墙，有些不用，我也不记得哪个用哪个不用了，实在不行可以使用淘宝的 npm 源进行安装。 环境配置好之后，最好更新一下模板，把一些常用的内容写到 Hexo 的模板里，这样在后续的使用中，可以快速的增加标签、分类和简介等内容。 学习 Markdown , 这个并不是一个坑，而是一个忠告，作为一个常年游荡在 GitHub 的好同志来说，但是对于一个 Emacser 来说，我更喜欢 Org-mode ，但是 Org-mode 并不能直接用来发布 Hexo 博客，有些人会说可以利用一些工具，但是与其增加一些工具，不如学习一下 Markdown, 这根本用不了几分钟，虽然 Org-mode 很强大（忍不住安利一波），但是 Markdown 作为一个大众的标记语言，简单的语法还是需要我们掌握的。 记住常用的命令 hexo new markdown_file 新建文章 hexo new page html_file 新建页面 hexo generate 生成静态页面到 public 目录 hexo server 开启预览访问端口，4000， Ctrl+c 关闭 server hexo deploy 将 .deploy 目录部署到 GitHub 这里需要配置 deploy 的项目地址并安装了 hexo-deployer-git 插件，才能使用这个功能 最后一个坑，挑选一个合适的主题，好吧，我选择了很久——大概四天吧，可能很多人能非常快的决定，但是对于我来说，把所有好看的主题都看一遍，才是我想做的事，最后我选择了 Next 主题，简单美观，还有非常齐全的配置说明 部署使用的命令有三个 hexo clean / hexo generate / hexo deploy ，这三个命令之后，就可以登录你的静态博客页面去查看了。 博客的生活我很喜欢调试自己的博客，但是写博客就不是那么喜欢了，但是我希望能养成一个定期写博客的习惯。 所以，我需要博客，主要是用来装…咳，主要是用来记录我们的生活、工作的内容，这样在下次使用的时候，就能更好的做到了。 Hexo 相关安装在几次试验之后，Node.js 环境还是使用 nvm管理比较好用，下载的时候可以使用 npm --registry=https://registry.npm.taobao.org install 进行安装下面的模块。 12345678910npm install -g hexo-clinpm install hexo-deployer-git --savenpm install hexo-generator-search --savenpm install hexo-generator-feed --savenpm install -g ternnpm install -g js-beautifynpm install -g jshintnpm install -g js-yamlnpm install hexo-renderer-jade --savenpm install hexo-renderer-sass --save hugoHugo 是由 Go 语言实现的一个 Static Site Generator 工具，特点就是快，而且默认是支持 Org mode 这种文本的。 虽然对于 hexo 而言少了许多好看的主题，但是对于 Org mode 的默认支持让我有了决心一用的冲动。 在使用了一段时间之后，发现这个工具完美的解决了我所有的问题，并能让我专心于博客写作本身而不是工具，虽然有一些不方便，但最后还是决定继续使用，而且要减少对工具本身的使用，而加强写作本身。 在长时间的使用之后，发现 Hugo 对 Org mode 的支持也比较一般，对于一些比较好用的特性，功能都不支持，最好的方案还是从 Org 转成 Markdown ，所以在最终使用 ox-hugo 工具配合 Hugo 使用，然后通过 capture 功能直接生成对应的博客文章，方便快捷。 ox-hugo 配置使用 ox-hugo 主要需要配置两个内容，一是将 ox-hugo 增加到配置中，然后是在 启动 org-capture 的时候，增加一个新的选项，可以将自动新增一篇文章。 1234567891011121314151617181920212223242526(use-package ox-hugo :after ox)(with-eval-after-load &#x27;org-capture (defun org-hugo-new-subtree-post-capture-template () &quot;Return `org-capture&#x27; template string for new Hugo post.&quot; (let* ((date (format-time-string (org-time-stamp-format :long :inactive) (org-current-time))) (title (read-from-minibuffer &quot;Post Title: &quot;)) (file-name (read-from-minibuffer &quot;File Name: &quot;)) (fname (org-hugo-slug file-name))) (mapconcat #&#x27;identity `( ,(concat &quot;* TODO &quot; title) &quot;:PROPERTIES:&quot; ,(concat &quot;:EXPORT_FILE_NAME: &quot; fname) ,(concat &quot;:EXPORT_DATE: &quot; date) &quot;:END:&quot; &quot;%?\\n&quot;) &quot;\\n&quot;))) (add-to-list &#x27;org-capture-templates &#x27;(&quot;h&quot; &quot;Hugo post&quot; entry (file &quot;~/workspace/blog/hugo-posts.org&quot;) (function org-hugo-new-subtree-post-capture-template)))) 在这里，我是将所有的文章写到对应的一个文件中，然后将文件中的所有内容生成到对应的 hugo 文件夹中。 文件头配置如下： 123#+HUGO_BASE_DIR: ~/workspace/blog/content/#+SEQ_TODO: TODO DRAFT DONE#+OPTIONS: ^:&#123;&#125; 然后在这个文件中使用导出的快捷键，就可以看到对应的选项了，将 org-export-dispatch 命令绑定到自己的快捷键上就可以看到对应的输出命令。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"hexo","slug":"工具环境/hexo","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.zucchiniy.com/tags/hexo/"},{"name":"hugo","slug":"hugo","permalink":"https://blog.zucchiniy.com/tags/hugo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://blog.zucchiniy.com/tags/GitHub-Pages/"}],"author":"zucchini"},{"title":"2020 读书/观影清单","slug":"journal/book-movie-list-2020","date":"2020-01-03T16:00:00.000Z","updated":"2021-07-02T15:43:09.545Z","comments":true,"path":"posts/c995ac9b.html","link":"","permalink":"https://blog.zucchiniy.com/posts/c995ac9b.html","excerpt":"","text":"东野圭吾小说阅读非系列小说 白夜行 &lt;2020-02-07 Fri&gt; 幻夜 解忧杂货店 &lt;2020-02-11 Tue&gt; 超杀人事件：推理作家的苦恼 &lt;2020-10-29 Thu&gt; 彷徨之刃 秘密 流星之绊 时生 信 放学后 &lt;2019-12-06 Fri&gt; 单恋 虚无的十字架 宿命 杀人之门分身 导论13 绑架游戏 使命与魂的尽头 湖边杀人案 平等世界 爱情故事 名侦探守则 变身 黎明之街 浪花少年侦探团 &lt;2020-02-22 Sat&gt; 再见了，忍老师 &lt;2020-03-20 Fri&gt; 天使之耳：交通警察之夜 &lt;2020-10-28 Wed&gt; 四笑小说 怪笑小说 毒笑小说 黑笑小说 歪笑小说 滑雪场系列 疾风回旋曲 &lt;2017-11-24 Fri&gt; 2.0 风雪追击 加贺一郎系列 毕业 &lt;2019-12-14 Sat&gt; 沉睡的森林 &lt;2019-12-16 Mon&gt; 谁杀了她 &lt;2019-12-17 Tue&gt; 恶意 &lt;2019-12-18 Wed&gt; 我杀了他 &lt;2019-12-22 Sun&gt; 只差一个谎言 &lt;2019-12-29 Sun&gt; 红手指 &lt;2019-12-31 Tue&gt; 新参者 &lt;2020-01-02 Thu&gt; 麒麟之翼 &lt;2020-01-03 Fri&gt; 祈祷落幕时 &lt;2019-12-12 Thu&gt; 神探伽利略系列 侦探伽利略 &lt;2020-01-06 Mon&gt; 预知梦 &lt;2020-01-06 Mon&gt; 嫌疑人 x 的献身 &lt;2019-12-09 Mon&gt; 圣女的救济 &lt;2020-01-14 Tue&gt; 伽利略的苦恼 &lt;2020-01-09 Thu&gt; 盛夏的方程式 &lt;2020-02-03 Mon&gt; 虚像小丑 禁忌魔术 其它推理小说 遗忘者 &lt;2020-10-18 Sun&gt; 罗杰疑案 &lt;2020-02-25 Tue&gt; 东方快车谋杀案 &lt;2020-03-10 Tue&gt; 无人生还 &lt;2020-03-02 Mon&gt; 啤酒谋杀案 ABC 杀人案 &lt;2020-03-06 Fri&gt; 尼罗河上的惨案 &lt;2020-03-10 Tue&gt; 福尔摩斯探案全集 消失的爱人 告白 逻辑王子的演绎 化工女王的逆袭 物理教师时空诡计 代上帝之手 无证之罪 坏小孩 长夜难明 络新妇之理 姑获鸟之夏 福尔摩斯探案集 占星术杀人魔法 死了七次的男人 一桩事先张扬的凶杀案 半落 别相信任何人 护士学院杀人事件 所罗门的伪证 达芬奇密码 金色梦乡 余生皆假期 铁鼠之槛 罗杰疑案 十角馆事件 一朵桔梗花 夏与冬的奏鸣曲 异邦骑士 七个证人 其它小说 我可以无限升级 &lt;2020-02-02 Sun&gt; 电影 粉红豹 &lt;2020-02-26 Wed&gt; 粉红豹2 &lt;2020-05-31 Sun&gt; 控方证人 &lt;2020-03-07 Sat&gt; 消失的爱人 &lt;2020-03-07 Sat&gt; 第六感 &lt;2020-05-31 Sun&gt; 彗星来的那一夜 穆赫兰道 &lt;2020-05-27 Wed&gt; 搏击俱乐部 &lt;2020-05-02 Sat&gt; 东方快车谋杀案 &lt;2020-03-06 Fri&gt; 致命ID &lt;2020-03-06 Fri&gt; 万能钥匙 &lt;2020-04-05 Sun&gt; 七宗罪 &lt;2020-02-26 Wed&gt; 天使与魔鬼 &lt;2020-01-05 Sun&gt; 达芬奇密码 &lt;2020-01-05 Sun&gt; 恐怖直播 &lt;2020-05-02 Sat&gt; 黑暗面 &lt;2020-04-05 Sun&gt; 小岛惊魂 &lt;2020-05-31 Sun&gt; 这个男人来自地球 &lt;2020-05-31 Sun&gt; 误杀瞒天记 &lt;2020-05-02 Sat&gt; 调音师 &lt;2020-03-05 Thu&gt; 我是谁：没有绝对的安全系统 消失的夜晚 &lt;2020-06-20 Sat&gt; 恐怖游轮 它在身后 蔷花红莲 &lt;2020-05-31 Sun&gt; 蝴蝶效应 &lt;2020-06-23 Tue&gt; 绝地战警：疾速追击 &lt;2020-12-20 Sun&gt; 连续剧 请输入搜索词 www &lt;2020-02-23 Sun&gt; 金秘书为何这样 &lt;2020-02-19 Wed&gt; 唐人街探案 &lt;2020-02-01 Sat&gt; 神探伽利略 &lt;2020-01-04 Sat&gt; 识骨寻寻踪1 &lt;2020-01-20 Mon&gt; 识骨寻寻踪2 &lt;2020-02-04 Tue&gt; 识骨寻寻踪3 &lt;2020-02-06 Thu&gt; 识骨寻寻踪4 &lt;2020-02-08 Sat&gt; 识骨寻寻踪5 &lt;2020-02-12 Wed&gt; 识骨寻寻踪6 &lt;2020-02-15 Sat&gt; 识骨寻寻踪7 识骨寻寻踪8 识骨寻寻踪9 识骨寻寻踪10 识骨寻寻踪11 识骨寻寻踪12 犯罪心理2 犯罪心理3 犯罪心理4 犯罪心理5 犯罪心理6 犯罪心理7 犯罪心理8 犯罪心理9 犯罪心理10 犯罪心理11 犯罪心理12 不死法医 劳拉之谜 大小谎言 Lie to me 神探夏洛克 布雷德利夫人探案 骇人命案事件簿 无妄之灾 我的恐怖妻子","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"年度清单","slug":"年度清单","permalink":"https://blog.zucchiniy.com/tags/%E5%B9%B4%E5%BA%A6%E6%B8%85%E5%8D%95/"},{"name":"读书清单","slug":"读书清单","permalink":"https://blog.zucchiniy.com/tags/%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"},{"name":"电影清单","slug":"电影清单","permalink":"https://blog.zucchiniy.com/tags/%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/"},{"name":"电视清单","slug":"电视清单","permalink":"https://blog.zucchiniy.com/tags/%E7%94%B5%E8%A7%86%E6%B8%85%E5%8D%95/"}]},{"title":"Valine 评论使用报错 504","slug":"fronts/valine-504-error","date":"2019-12-19T09:50:20.000Z","updated":"2021-07-02T15:43:09.544Z","comments":true,"path":"posts/c7b31ff.html","link":"","permalink":"https://blog.zucchiniy.com/posts/c7b31ff.html","excerpt":"","text":"最近准备重新配置一下 个人博客 ，由原来的 Hugo 改到 Hexo 来做。 评论系统也由之前的 disqus 改成现在的 valine 。 主题也使用了非常好看的 Material Design 的样式的 Material-x ，并在此之上进行修改。 完成初始的配置之后，做一下测试。 恩。。。报错了？！ 虽然报错，但是可以正确的显示对应的服务，查询了一下原因，发现是因为长时间未使用 LeanCode 的服务，导致文件上传域名无法访问了，需要在 设置-&gt;应用 Keys 下面，选择重启 文件上传域名 和 文件访问域名 的服务即可。 具体的位置如下：","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"hexo","slug":"前端技术/hexo","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.zucchiniy.com/tags/hexo/"},{"name":"valine","slug":"valine","permalink":"https://blog.zucchiniy.com/tags/valine/"},{"name":"Code 504","slug":"Code-504","permalink":"https://blog.zucchiniy.com/tags/Code-504/"}]},{"title":"如何在快捷奏的生活里阅读学习","slug":"journal/reading-taxonomy","date":"2019-11-14T06:50:00.000Z","updated":"2021-07-02T15:43:09.548Z","comments":true,"path":"posts/8d1edf2c.html","link":"","permalink":"https://blog.zucchiniy.com/posts/8d1edf2c.html","excerpt":"","text":"今天在微信读书进行阅读的时候，忽然发现我已经收藏了很多的书籍，大概有几百本，但是在车上或者是在路上，有的读并适合阅读，因为需要思考，而这种时间，并不适合边思考边阅读。更多的可能是进行听书或者是听一些休闲体裁的书。 在生活中，因为种种原因，在当当上、京东上购买了许许多的实体书，这些书有小说，也有编程相关的书，有散文，也有一些知识理论的凡人版。但是这些书小的有几百页，多的可能有上千页，我不可能随身携带。 分级为了更好的利用时间阅读，我将现在可以看的书分为三大类。 第一类，可以听的书，目前看来，这类书籍主要是小说为主，而一些简单的实用性理论书籍为辅，我可以在通勤的时候，洗澡的时候找开阅读平台，比如微信读书，然后听上个三四十分钟，如果有非常好的段落，就大概记下来，然后再后面再阅读。 第二类，需要看的书，这类书籍是一些在微信读书中收藏的书籍，可能是一些需要边看边思考的书，内容丰富，我要一边听一边想，这本书在讲什么，甚至有一些内容，需要我在电脑上记录下来，或者实际的练习一下，比如一些编程向的书，不实际的思考的实验，是不能学到这些的。 第三类，需要反复阅读的书，这种书需要在软件平台上阅读之后，购买下来，然后放在桌面、床头，甚至随身携带，在需的时候，找到他，再仔细的阅读一遍。而就像是一些书的评价一样，可能第一次阅读，第二次阅读和第三次阅读，看到的都是不一样的内容，就像是一些文章中的说的，在我新手的时候，中级的时候，高手的时候，在这本书中都能学到知识。而且学到的还是不一样的知识。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://blog.zucchiniy.com/tags/%E9%98%85%E8%AF%BB/"},{"name":"阅读分组","slug":"阅读分组","permalink":"https://blog.zucchiniy.com/tags/%E9%98%85%E8%AF%BB%E5%88%86%E7%BB%84/"}],"author":"zucchini"},{"title":"Google 验证网站所有权","slug":"tools/google-search-console","date":"2019-10-29T22:32:00.000Z","updated":"2021-07-02T15:43:09.555Z","comments":true,"path":"posts/1cbedf30.html","link":"","permalink":"https://blog.zucchiniy.com/posts/1cbedf30.html","excerpt":"","text":"想要有收，必要的点击率和使用率是要保证的，然后就是导流了，如果想在这上面使用，必须要有增加相关的搜索量，将自己写的文章，在 Google 进行搜索的时候，发现并没有数据引入，这就比较尴尬了，查询了一下，可以申请一个 Google Search Console 的服务，这里就必须要整理一下了。 点击跳转到验证网站所有权页面 谷歌提供了几个方案，第一个也是推荐的，就是将一个 html 文件放到对应的网站中，这个看了一下。 但是相对于这种方案，下面的两种方法更合适一些，但是都需要在博客的主题中增加相应的代码，这个可以和 Google Adsense 一起使用。 这个方案也是可以的，在使用过程中，想要针对性的看自己的网站的内容，使用 Google Analytics（分析）也是一个不错的方案。 还有一个方法是在 DNS 中增加对应的 txt 文件，但是这个方法，没有解决，在在腾讯云上，配置 DNS 的时候，提示非法，可能是使用的方案不对，需要再研究一下。 目前已经成功申请了广告业务，但是因为写的太次的原因，网站几乎没人看，恩。。。很尴尬。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Google","slug":"工具环境/Google","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Google/"}],"tags":[{"name":"google adsense","slug":"google-adsense","permalink":"https://blog.zucchiniy.com/tags/google-adsense/"}]},{"title":"Python 数据分析初阶","slug":"backends/python/python-data-analysis-junior","date":"2019-10-17T18:19:00.000Z","updated":"2021-07-02T15:43:09.542Z","comments":true,"path":"posts/a3644317.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a3644317.html","excerpt":"","text":"某一列数据计算1data[&#x27;column_name&#x27;].value_counts() 以之前找到的一个前辈的数据为例子，首先我们要获取文件 12import pandas as pddata = pd.read_excel(&#x27;xxxx.xls&#x27;) 这里可以单独查看其中的内容 data[&#39;nick&#39;]，计算其中的大小则使用 data[&#39;nick&#39;].value_counts()。 同样的情况，我们可以增加分组并获取对应的数据 1data1 = data[&#x27;score&#x27;].groupby(data[&#x27;city&#x27;]) data1.mean() 这种情况下可以类比为SQL语句： 1select avg(score) from data group by city 这样的数据看起来不是特别让人喜欢，这个时间我们可以给他排个序： 1data1.mean().sort_values(ascending=False) 现在看起来好多了，但是有点多了，我们只想看前几条记录： 1data1.mean().sort_values(ascending=False).head(3) 可惜了，好多城市我都没听过，我只想看直辖市的数据 1data2 = data.loc[(data[&#x27;city&#x27;].isin([&#x27;北京&#x27;,&#x27;天津&#x27;,&#x27;重庆&#x27;,&#x27;上海&#x27;]))] 但是这样还是不特别好看，我们可以再按城市看一下，评分有多少 1data2[&#x27;score&#x27;].groupby(data2[&#x27;city&#x27;]).mean() 数据表信息查看df.shape: 维度查看df.info(): 数据表基本信息，包括围度、列名、数据格式、所占空间df.dtypes: 每一列的数据格式df[&#39;b&#39;].dtype: 某一列的格式df.isnull(): 是否空值df.[&#39;b&#39;].unique(): 查看某一列的唯一值df.values: 查看数据表的值df.columns: 查看列名df.head(): 查看默认的前 10 行数据df.tail(): 查看默认的后 10 行数据 数据表清洗df.fillna(value=0): 用数字 0 填充空值df[&#39;pr&#39;].fillna(df[&#39;pr&#39;].mean()): 用列 pr 的平均值对 na 进行填充df[&#39;city&#39;]=df[&#39;city&#39;].map(str.strip): 清除 city 字段的字符空格df[&#39;city&#39;]=df[&#39;city&#39;].str.lower(): 大小写转换df[&#39;pr&#39;].astype(&#39;int&#39;): 更改数据的格式df.rename(columns=&#123;&#39;category&#39;: &#39;category-size&#39;&#125;): 更改列名df[&#39;city&#39;].drop_duplicates(): 删除后出现的重复值df[&#39;city&#39;].drop_duplicates(keep=&#39;last&#39;): 删除先出现的重复值df[&#39;city&#39;].replace(&#39;sh&#39;, &#39;shanghai&#39;): 数据替换 数据预处理 数据表合并 1234df_inner = pd.merge(df, df1, how=&#x27;inner&#x27;) # 匹配合并，交集df_left = pd.merge(df, df1, how=&#x27;left&#x27;) # 左联表df_right = pd.merge(df, df1, how=&#x27;right&#x27;) # 右联表df_outer = pd.merge(df, df1, how=&#x27;outer&#x27;) # 并集 设置索引列 1df.set_index(&#x27;id&#x27;) 按照特定列的值排序 1df.sort_values(by=[&#x27;age&#x27;]) 按照索引列排序 1df.sort_index() 如果 pr 列的值大于 3000 ， group 列显示 hight , 否则显示 low 1df[&#x27;group&#x27;] = np.where(df[&#x27;pr&#x27;] &gt; 3000, &#x27;hight&#x27;, &#x27;low&#x27;) 对复合多个条件的数据进行分级标记 1df.loc[(df[&#x27;city&#x27;] == &#x27;beijing&#x27;) &amp; (df[&#x27;pr&#x27;] &gt;= 4000), &#x27;sign&#x27;] = 1 对 category 字段的值依次进行分列，并创建数据表，索引值 df 的索引列，列名称为 category 和 size 1pd.DataFrame((x.split(&#x27;-&#x27;) for x in df[&#x27;category&#x27;]), index=df.index, columns=[&#x27;category&#x27;, &#x27;size&#x27;]) 数据提取loc: 函数按标签值进行提取iloc: 按位置进行提取ix: 可以同时按标签和位置进行提取 具体的使用见下： df.loc[3]: 按索引提取单行的数值df.iloc[0:5]: 按索引提取区域行数据值df.reset_index(): 重设索引df=df.set_index(&#39;date&#39;): 设置 date 为索引df[:&#39;2013&#39;]: 提取 2013 之前的所有数据df.iloc[:3,:2]: 从 0 位置开始，前三行，前两列，这里的数据不同去是索引的标签名称，而是数据所有的位置df.iloc[[0,2,5],[4,5]]: 提取第 0、2、5 行，第 4、5 列的数据df.ix[:&#39;2013&#39;,:4]: 提取 2013 之前，前四列数据df[&#39;city&#39;].isin([&#39;beijing&#39;]): 判断 city 的值是否为北京df.loc[df[&#39;city&#39;].isin([&#39;beijing&#39;,&#39;shanghai&#39;])]: 判断 city 列里是否包含 beijing 和 shanghai ，然后将符合条件的数据提取出来pd.DataFrame(category.str[:3]): 提取前三个字符，并生成数据表 数据筛选使用与、或、非三个条件配合大于、小于、等于对数据进行筛选，并进行计数和求和。 使用与进行筛选 1df.loc[(df[&#x27;age&#x27;] &gt; 25) &amp; (df[&#x27;city&#x27;] == &#x27;beijing&#x27;), [&#x27;id&#x27;, &#x27;city&#x27;, &#x27;age&#x27;, &#x27;category&#x27;]] 使用或进行筛选 1df.loc[(df[&#x27;age&#x27;] &gt; 25) | (df[&#x27;city&#x27;] == &#x27;beijing&#x27;), [&#x27;id&#x27;, &#x27;city&#x27;, &#x27;age&#x27;]] 使用非进行筛选 1df.loc[(df[&#x27;city&#x27;] != &#x27;beijing&#x27;), [&#x27;id&#x27;, &#x27;city&#x27;, &#x27;age&#x27;]].sort([&#x27;id&#x27;]) 筛选后的灵气按 city 列进行计数 1df.loc[(df[&#x27;city&#x27;] != &#x27;beijing&#x27;), [&#x27;id&#x27;, &#x27;city&#x27;, &#x27;age&#x27;]].sort([&#x27;id&#x27;]).city.count() 使用 query 函数进行筛选 1df.query(&#x27;city&#x27; == [&#x27;beijing&#x27;, &#x27;shanghai&#x27;]) 对筛选后的结果按 pr 进行求和 1df.query(&#x27;city&#x27; == [&#x27;beijing&#x27;, &#x27;shanghai&#x27;]).pr.sum() 数据汇总主要使用 groupby 和 pivote_table 进行处理。 df.groupby(&#39;city&#39;).count(): 按 city 列分组后进行数据汇总df.groupby(&#39;city&#39;)[&#39;id&#39;].count(): 按 city 进行分组，然后汇总 id 列的数据df.groupby([&#39;city&#39;,&#39;size&#39;])[&#39;id&#39;].count(): 对两个字段进行分组汇总，然后进行计算df.groupby(&#39;city&#39;)[&#39;pr&#39;].agg([len, np.sum,np.mean]): 对 city 进行分组，然后计算 pr 列的大小、总和和平均数 数据统计数据采样，计算标准差、协方差和相关系数。 简单数据采样 1df.sample(n=3) 手动设置采样权重 12weights = [0, 0, 0, 0, 0, 0.5, 0.5]df.sample(n=2, weights=weights) 采样后不放回 1df.sample(n=6, replace=False) # 如果 replace = True 采样后放回 数据表描述性统计 1df.describe().round(2).T # round 表示显示的小数位数，T 表示转置 计算列的标准差 1df[&#x27;pr&#x27;].std() 计算两个字段间的协方差 1df[&#x27;pr&#x27;].cov(df[&#x27;m-point&#x27;]) 计算表中所有字段间的协方差 1df.cov() 两个字段间的相关性分析 1df[&#x27;pr&#x27;].corr(df[&#x27;m-point&#x27;]) # 相关系数在 [-1, 1] 之间，接近 -1 为负相关，1 为正相关，0 为不相关 数据表的相关性分析 1df.corr()","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://blog.zucchiniy.com/tags/pandas/"}]},{"title":"Python 学习书单","slug":"journal/python-learning-book-list","date":"2019-10-16T19:15:00.000Z","updated":"2021-07-02T15:43:09.547Z","comments":true,"path":"posts/f47baf34.html","link":"","permalink":"https://blog.zucchiniy.com/posts/f47baf34.html","excerpt":"","text":"Python入门书单 Python 编程无师自通 [已购] 提高书单阅读过程中，发现这本书要比入门书要复杂一些，而且主要使用的是 Python 2.7 版本，有些陈旧了，但是内容确是非常棒，适合在初级掌握之后，提高使用，除了简单的介绍相关的数据，还有一些内容是了解 Python 所需要的知识。 Python 核心编程 二 [已购] [2020-03-20 Fri] 看了前言，第三版主要就是第二部分，所以直接阅读第三版。 Python 核心编程 三 [已购] 进阶系列 [ ] 流畅的 Python :star::star::star::star: [已购] [ ] Python Cookbook 中文版 :star::star::star: [已购] [ ] Effective Python :star: [ ] Python 高性能编程 :star: [已购] [ ] Python 学习手册 :star:star: 其它方向 [X] Python Web 开发——测试驱动方法 [2019-10-05 Sat] [X] 轻量经 Django [2019-10-14 Mon] [ ] Python 自动化运维 [ ] Python 绝技——利用 Python 成为顶级黑客 [ ] Python 黑帽子——黑客与渗透测试编程之道 数据分析 [X] Head First Data Analysis :star: [已购] [2019-10-14 Mon] [ ] 集体智慧编程 :star::star::star::star::star: [已购] [ ] 利用 Python 进行数据分析 :star::star::star::star::star: [已购] [ ] Python 金融大数据分析 :star: [已购] [ ] Python 数据分析与挖掘实战 :star::star: [已购] [ ] Python 数据可视化编程实战 :star::star: [已购] [ ] 百面机器学习——算法工程师带你去面试 [已购] 通用 [ ] 像程序员一样思考 [ ] 重构 改善既有代码的设计 :star:️:star:️:star:️ [已购] [ ] 代码整洁之道 :star:️:star:️:star:️ [已购] [ ] 代码整洁之道 程序员的职业素养 :star:️:star:️:star:️ [已购] [ ] 编程珠玑 一 :star:️:star:️:star:️ [已购] [ ] 编程珠玑 二 :star:️:star:️:star:️ [已购] 其它 [ ] Vim 实用技巧 :star::star::star::star: [已购] [ ] 高性能 MySQL :star::star: [已购] 前端 [X] Vue.js 前端开发——快速入门与专业应用 [已购] [ ] React 开发实战 [已购] [ ] 单面 Web 应用 [已购] [ ] Bootstrap 实战——从入门到精通 [已购] Linux [ ] Linux 私房菜——基础学习篇 [已购] [ ] Linux 私房菜——服务器回调篇 [已购] [ ] Linux 命令行大全 [已购] [ ] 深入理解 Linux 内核 [已购] Java [X] Java RESTful Web Service 实战 [已购] [X] Spring MVC MyBatis 开发从入门到项目实战 [已购]","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.zucchiniy.com/tags/Python/"},{"name":"学习计划","slug":"学习计划","permalink":"https://blog.zucchiniy.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"}],"author":"zucchini"},{"title":"Python 转换 Markdown 方法","slug":"backends/python/python-convert-markdown-to-html","date":"2019-10-11T18:43:00.000Z","updated":"2021-07-02T15:43:09.542Z","comments":true,"path":"posts/9a20479.html","link":"","permalink":"https://blog.zucchiniy.com/posts/9a20479.html","excerpt":"","text":"昨天看书的时候，看到了作者留的一个练习，是将 Markdown 的文档转换成 HTML 的方法。类似的标记语言还有 RestruredText 和 Org Mode，但是貌似 Org 比较小众，暂没有。 在 Django 中进行转换有两个方案，一个是直接安装 markdown 的模块，pip install markdown ，这种方式是直接将 Markdown 渲染成 HTML ，但是在 Django 项目中需要使用模板进行渲染，会导致样式改变，所以需要增加 safe 到模板中，表示不需要转义。 代码块如下： 1234567891011121314151617# 在 view.py 里使用 markdown 进行渲染import markdowndef page(request, name): template = get_template(&#x27;doc.html&#x27;) docfile = get_template(&#x27;doc/&#123;&#125;.md&#x27;.format(name)) content = docfile.render() html = template.render(&#123; &#x27;docname&#x27; : name &#x27;content&#x27; : markdown.markdown(content, extensions=[ &#x27;markdown.extensions.extra&#x27;, &#x27;markdown.extensions.codehilite&#x27;, &#x27;markdown.extensions.tox&#x27;, ]) &#125;) return HttpResponse(html) Html 文件如下 123456&lt;!DOCTYPE&gt;&lt;html lang=&#x27;en&#x27;&gt; &lt;body&gt; &#123;&#123; content | safe &#125;&#125; &lt;/body&gt;&lt;/html&gt; 另一个方案是使用 django.markdown-deux 进行渲染，首先在 INSTALL_APPS 中增加 markdown-deux , 然后模板里引用这个标签： 1234567&lt;!DOCTYPE&gt;&lt;html lang=&#x27;en&#x27;&gt; &lt;body&gt; &#123;% load markdown-duex-tags %&#125; &#123;&#123; content | markdown &#125;&#125; &lt;/body&gt;&lt;/html&gt; 这样也可以将 Markdown 直接渲染成网页了。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://blog.zucchiniy.com/tags/markdown/"},{"name":"django","slug":"django","permalink":"https://blog.zucchiniy.com/tags/django/"},{"name":"markdown-deux","slug":"markdown-deux","permalink":"https://blog.zucchiniy.com/tags/markdown-deux/"}]},{"title":"整数转英文表示","slug":"backends/python/integer-to-english-words","date":"2019-10-07T18:13:00.000Z","updated":"2021-07-02T15:43:09.541Z","comments":true,"path":"posts/82c82a34.html","link":"","permalink":"https://blog.zucchiniy.com/posts/82c82a34.html","excerpt":"","text":"将非负整数转换为其对应的英文表示。 LeetCode数转换英文表示 12345678910111213141516171819class Solution: def numberToWords(self, num: int) -&gt; str: one_to_19 = &#x27;&#x27;&#x27;One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen&#x27;&#x27;&#x27;.split() tens = &#x27;Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety&#x27;.split() def helper(num): if num &lt; 20: return one_to_19[num - 1:num] elif num &lt; 100: return [tens[num // 10 - 2]] + helper(num % 10) elif num &lt; 1000: return [one_to_19[num // 100 -1]] + [&#x27;Hundred&#x27;] + helper(num % 100) for p,w in enumerate([&#x27;Thousand&#x27;,&#x27;Million&#x27;,&#x27;Billion&#x27;],1): if num &lt; 1000 ** (p+1): return helper(num//1000**p) + [w] + helper(num % 1000 ** p) return &#x27; &#x27;.join(helper(num)) or &quot;Zero&quot; 这里做了两个测试，关于 if-elif 和 if...if 的时间，在 Leetcode 上测试的时候，发现 if-elif 的效率是低于两个 if...if 的效率的，具体时候如下： 所以在没有具体的逻辑要求的时候，使用 if...if 代替 if-elif 来提高效率，但是为什么会与我的认知相反呢？很奇怪，有时间希望可以研究一下两个的时间使用效率的差别。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.zucchiniy.com/tags/Leetcode/"}]},{"title":"整数转罗马数字","slug":"backends/python/integer-to-roman","date":"2019-10-07T18:06:00.000Z","updated":"2021-07-02T15:43:09.541Z","comments":true,"path":"posts/50b197ff.html","link":"","permalink":"https://blog.zucchiniy.com/posts/50b197ff.html","excerpt":"","text":"LeetCode数转罗马数字 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 123456789101112131415class Solution: def intToRoman(self, num: int) -&gt; str: nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1] romans = [&#x27;M&#x27;,&#x27;CM&#x27;,&#x27;D&#x27;,&#x27;CD&#x27;,&#x27;C&#x27;,&#x27;XC&#x27;,&#x27;L&#x27;,&#x27;XL&#x27;,&#x27;X&#x27;,&#x27;IX&#x27;,&#x27;V&#x27;,&#x27;IV&#x27;,&#x27;I&#x27;] index = 0 res = &#x27;&#x27; while index &lt; 13: while num &gt;= nums[index]: res += romans[index] num -= nums[index] index += 1 return res","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.zucchiniy.com/tags/Leetcode/"}]},{"title":"如何提高时间使用效率","slug":"journal/how-to-improve-work-efficiency","date":"2019-08-15T17:42:00.000Z","updated":"2021-07-02T15:43:09.546Z","comments":true,"path":"posts/46a53616.html","link":"","permalink":"https://blog.zucchiniy.com/posts/46a53616.html","excerpt":"","text":"碎片时间与完整的时间不同，生活中经常有一些碎片时间，这些时间缺乏连续性，并且时间短，随时可能会出现，因此碎片时间和完整时间的利用不太相同。 我们可以先将自己的碎片时间按长短进行分类，比如 15 分钟、30 分钟，然后按时间长短，将自己可以处理的事情做完，将这些事情列举出来，当有了这个时间之后，可以按这个进行处理。 15 分钟 阅读一篇微信公众号的文章，如果有趣可以保存下来，在后面有大块时间后进行反复阅读 休息一下眼睛，在长时间伏案工作后，必要的休息是很有用的 给家人打个电话之类的 处理一下工作中的邮件 将之前收集到的内容整理成一个计划表 30 分钟 增加一个 Emacs 中想要使用的功能 整理之前阅读到的知识点 听一小段英文，并记录学习 这样时间的利用效率提高之后，学习和工作也就更有计划了。 这里推荐两个小工具。 Forest : 可以计时时间并统计，比较好用，期间不能使用手机，强迫症好帮手。还能收集金币换不同的树用来种。 滴答清单 : 有 Mac 版和 iOS 版本，我主要用来收集阅读到的好文章，或者想要归纳整理的内容，等有时间后再重复阅读。 其它小技巧 对于可以同时做的事情，尽量同时完成。比如洗澡的同时可以洗衣服、烧水等 有意识的为自己设定一个截止时间，这样可以强迫自己完成某些任务 做事的时候多思考总结，找到适合自己，提高时间使用效率的方法","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"https://blog.zucchiniy.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"},{"name":"时间使用效率","slug":"时间使用效率","permalink":"https://blog.zucchiniy.com/tags/%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87/"}]},{"title":"利用 Python 生成数据透视表","slug":"backends/python/python-process-excel","date":"2019-08-08T22:53:00.000Z","updated":"2021-07-02T15:43:09.542Z","comments":true,"path":"posts/f24bdf86.html","link":"","permalink":"https://blog.zucchiniy.com/posts/f24bdf86.html","excerpt":"简介 利用 read_excel() 的 usecols 参数来指定表的某一列，以方便排除不必要的干扰列 养成数据加载以后，使用 head() 进行预览的习惯 养成使用 shape() 及 info() 了解表格基本情况的习惯 利用 info() 方法查看数据中是否有空值，如果有空值的话，则可以使用 dropna() 方法将其移除。 需要掌握的主要有两个方法: DataFrame.insert() 方法，用来增加对应的列 DataFrame.pivot_table() 产生透视图，展示重要的数据","text":"简介 利用 read_excel() 的 usecols 参数来指定表的某一列，以方便排除不必要的干扰列 养成数据加载以后，使用 head() 进行预览的习惯 养成使用 shape() 及 info() 了解表格基本情况的习惯 利用 info() 方法查看数据中是否有空值，如果有空值的话，则可以使用 dropna() 方法将其移除。 需要掌握的主要有两个方法: DataFrame.insert() 方法，用来增加对应的列 DataFrame.pivot_table() 产生透视图，展示重要的数据 具体方法 DataFrame.insert(self, loc, column, value, allow_duplicates=False) loc : int 表示第几列；0 &lt;= loc &lt;= len(columns)column : string, number, or hashable object;给插入的列取名，如 column=’新的一列’value : int ，array，seriesallow_duplicates : bool 是否允许列名重复，选择 True 表示允许新的列名与已存在的列名重复。 DataFrame.pivot_table(self, values=None, index=None, columns=None, aggfunc=&#39;mean&#39;, fill_value=None, margins=False, dropna=True, margins_name=&#39;All&#39;, observed=False) values : 要进行透视展示的数据index : 需要重新进行展示成列，是原始数据中的某一个行columns : 要重新展示为行的内容，是原来的列或者是其它的属性，可以是列表aggfunc : 要进行统计的行，可以是 numpy.sum / numpy.mean 等，也可以按列进行统计 aggfunc=&#123;&#39;c1&#39; : numpy.mean, &#39;c2&#39; : numpy.sum&#125;fill_value : 将缺失值替换的值，幽灵将 Nan 换成 0 : fill_value=0margins : bool, 增加行或者列的汇总信息dropna : bool ，是否要删除为空的信息margin_name : string , 默认为 all ，或者自定义一个名称 observed bool , True 显示分类中的数据，False 显示所有数据，默认为 False 示例代码1234567891011121314151617181920212223242526272829303132333435import pandas as pdfrom datetime import datetimedata = pd.read_excel(r&#x27;python_learning.xlsx&#x27;, usecols=[1, 4, 6, 7, 8, 9, 10, 11, 12], sheet_name=&#x27;sheetName&#x27;)data = data[data[&#x27;合同生效日&#x27;] &gt; datetime(2018, 12, 31)]# 按逻辑，将一组数据拆成三组data1 = data[[&quot;used&quot;, &quot;loan amount&quot;, &quot;company1&quot;, &quot;percent1&quot;]]data2 = data[[&quot;used&quot;, &quot;loan amount&quot;, &quot;company2&quot;, &quot;percent2&quot;]]data3 = data[[&quot;used&quot;, &quot;loan amount&quot;, &quot;company3&quot;, &quot;percent3&quot;]]# 将三组内容，重新命名之后合成一个新表data1 = data1.rename(columns=&#123;&quot;company1&quot;: &quot;company&quot;, &quot;percent1&quot;: &quot;percent&quot;&#125;)data2 = data2.rename(columns=&#123;&quot;company2&quot;: &quot;company&quot;, &quot;percent2&quot;: &quot;percent&quot;&#125;)data3 = data3.rename(columns=&#123;&quot;company3&quot;: &quot;company&quot;, &quot;percent3&quot;: &quot;percent&quot;&#125;)data4 = pd.concat([data1, data2, data3], ignore_index=True)# 将数据中的空值清除data4 = data4.dropna()# 插入新的数据# 1. insert() 方法data4.insert(2, &quot;devide percent&quot;, data4[&quot;percent&quot;]/100)data4.insert(5, &quot;devide amount&quot;, data4[&quot;loan amount&quot;]*data4[&quot;deivide percent&quot;]/10000, False)# 普通索引方式插入# data4[&quot;loan divide amount&quot;] = data4[&quot;load amount&quot;]*data4[&quot;deivide percent&quot;]/10000# 增加数据透视data5 = data4[[&#x27;company&#x27;, &#x27;used&#x27;, &#x27;loan amount&#x27;]]data6 = pd.pivot_table(data5, values=&quot;loan divide amount&quot;, columns=&quot;used&quot;, index=&quot;company&quot;, aggfunc=&#x27;sum&#x27;, fill_value=0, observed=False).reset_index()print(data6.head())","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"透视表","slug":"透视表","permalink":"https://blog.zucchiniy.com/tags/%E9%80%8F%E8%A7%86%E8%A1%A8/"},{"name":"read_excel()","slug":"read-excel","permalink":"https://blog.zucchiniy.com/tags/read-excel/"}]},{"title":"在 Emacs 中执行 Pyhton","slug":"tools/emacs/run-python-in-emacs","date":"2019-08-06T23:18:00.000Z","updated":"2021-07-02T15:43:09.552Z","comments":true,"path":"posts/d07fab41.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d07fab41.html","excerpt":"","text":"最近在整理 Python 的相关的内容，主要需要整理成笔记，记录下来，等有需要的时候再进行复习。 在编写 org 的时候，发现 Python 的内容并不能很好的执行，而且生成的图片也不能正常显示，所以查询了一下资料，发现如果是 python 的话，需要按下面的形势处理： 1#+BEGIN_SRC python :results file :preamble &quot;# -*- coding: utf-8 -*-&quot; :python python3 :exports both 其中 :results 针对不同的执行结果进行调整，如果是想把 Python 生成的图片显示在 org 文档里的话，就要选择 file ，如果是想显示执行的结果的话，就使用 output 。 :preamble 的话，是针对 Python 的码制了，现在如果有中文的话，可能需要指定为 utf-8 所以默认需要加上这个内容。 :python 是用来指定解释器的，在 Mac 环境下，执行的时候，总是提示找不到 pandas 但是如果直接使用 python test.py 的话是能正常显示结果，可能是因为默认查找的 python2 吧，这里进行指定到 python3 上就可以使用了。 :exports 是指定输出的情况的，code 是指显示代码，results 是指的仅显示结果，both 是两个都显示，none 则是指的都不显示。 :session 是特殊情况，有些时候需要调用方法中的 return 使用 session 的话能直接使用，可以不必再单独返回了。 :var 可以指定传入的参数 使用示例如下： 12345678910111213141516171819202122232425#+tblname: data_table| a | 1 || b | 2 || c | 3 |#+begin_src python :var val=1 :var data=data_tablereturn(data[val])#+end_src#+RESULTS:| b | 2 |#+begin_src python :results fileimport matplotlib, numpymatplotlib.use(&#x27;Agg&#x27;)import matplotlib.pyplot as pltfig=plt.figure(figsize=(4,2))x=numpy.linspace(-5,5)plt.plot(numpy.sin(x)/x)fig.tight_layout()plt.savefig(&#x27;./images/python-matplot-fig.png&#x27;)return &#x27;./images/python-matplot-fig.png&#x27; # return filename to org-mode#+end_src#+RESULTS:[[file:./images/python-matplot-fig.png]] 将这个内容增加到 snippet 中去，在 snippet/org-mode/ 路径下增加 python文件，其中内容如下 123# -*- mode: snippet -*-# name: python# key: &lt;pyt_","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"org mode","slug":"org-mode","permalink":"https://blog.zucchiniy.com/tags/org-mode/"},{"name":"Python","slug":"Python","permalink":"https://blog.zucchiniy.com/tags/Python/"}]},{"title":"Python 学习路径","slug":"journal/python-learning-path","date":"2019-08-06T22:54:00.000Z","updated":"2021-07-02T15:43:09.547Z","comments":true,"path":"posts/df5adb66.html","link":"","permalink":"https://blog.zucchiniy.com/posts/df5adb66.html","excerpt":"","text":"现在 Python 主要在 前端 、 数据分析 两个方面比较火，相较于其它语言，更灵活，经过一段时间的选择之后，希望可以认真的学习 Python 这门编程语言。 Python 的级别对于我们这些程序员来说，总要有一个级别，不然怎么能知道自己在哪个级别呢？ 一级——了解基本语法 [X] 掌握了基本的语法，可以通过 Python 实现常用的需求。不管代码质量怎么样。 [ ] The Python Tutorial 3.8 二级——熟练使用常用的库 [ ] 熟悉常用的 Standard 库的使用。 [ ] The Python Standard Library [ ] 熟悉常用的第三方库，要看各自领域中的内容，例如 pandas、flask 等 Pythonic 的小技能 善用内置函数 map zip enumerate reversed any all 小细节 raise SystemExit 文件的 x 模式 ConfigParser defaultdict Counter nametuple 使用高级并发工具 使用装饰器 使用设计模式 全局变量 时间复杂度 上下文管理器 管理锁 管理数据库 cursor 运算精度 同时管理多个资源 实现上下文管理协议 三级——Pythonic让编码更优雅，更符合 Python 也就是 Pythonic 而不是用 Python 写 Java 类型的代码，比如 with、for-else、try-else、while-else、yield 等。 另外还需要掌握一些实现原理，了解 Python 在语法层面的一些协方，可以自己实现语法糖。比如（上下文管理器）等。 [ ] The PythonLanguage Reference [ ] Python HOWTOs 四级——高级玩法 [ ] 掌握 Python 的内存机制、GIL限制等 [ ] 知道如何改变 Python 的行为 [ ] 可以轻松写出高质量的 Python 代码 [ ] 能够轻松分辨不同的 Python 代码效率并知道如何优化 五级——看透本质 [ ] 阅读 Python 的 C 实现 [ ] 掌握 Python 中各种对象的本质，掌握是如何通过 C [ ] 实现对象行为，对于常见的数据结构，掌握其实现细节","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.zucchiniy.com/tags/Python/"}],"author":"zucchini"},{"title":"简历中的水平","slug":"journal/knowledge-level-in-resume","date":"2019-08-04T17:40:00.000Z","updated":"2021-07-02T15:43:09.546Z","comments":true,"path":"posts/d5852cf3.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d5852cf3.html","excerpt":"","text":"在写自己的简历的时候，有时候会有对自己的水平不清楚，查了一些资料，大概了解了一下相关的水平。 了解 : 知道，不会做，找个人带着可以帮点忙 熟悉 : 知道，能做 60%-80% 的工作。但碰到难题需要指导一下 熟练（掌握）: 95% 以上的相关工作进季可 独立完成 ，无需指导帮忙。且能在 工作技巧上指导 “了解”、“熟悉” 精通 : “熟练” 那 5% 解决不了的，“精通” 可以攻关完成。“精通”最主要的价值是可以 技术预研，能改革现有程序或者方法，解决新问题 。精通另一点价值是能解脱民 单一领域多层次问题 ，或 多领域单一层次问题 。 看了一些文章，很多招聘需求中都写着要精通某一技术，很多人说这个有点高了，但其实有可能这里的精通是指的熟练这一级别，毕竟 精通 可以说是达到了某一领域中的极限，很多工作并不需要这样的人，除非真的是非常重要的位置。而一般招聘信息中的可能是指的英文中的 Proficient 也就和 熟练（掌握） 同样的层级，一般英文级别是 Novice / Basic / Proficient / Advance / Expert 这五个级别。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://blog.zucchiniy.com/tags/%E7%AE%80%E5%8E%86/"},{"name":"技能水平","slug":"技能水平","permalink":"https://blog.zucchiniy.com/tags/%E6%8A%80%E8%83%BD%E6%B0%B4%E5%B9%B3/"}]},{"title":"Mac 下使用 tmux","slug":"tools/mac/tmux-on-mac","date":"2019-07-31T22:37:00.000Z","updated":"2021-07-02T15:43:09.558Z","comments":true,"path":"posts/cd94d23e.html","link":"","permalink":"https://blog.zucchiniy.com/posts/cd94d23e.html","excerpt":"","text":"安装 tmuxbrew install tmux 可以直接安装到电脑中。 简单使用打开在命令行中，直接输入 tmux 即可启 切分窗口ctrl + b 可以启动命令模式，类似 vim 下的 : 。然后再按 % 可以进行水平切分。 如果想到垂直切分，则按下 “ 即可。 后台执行ctrl + b 然后按 d 可以将这个后台隐藏，如果想回到隐藏的进程，可以输入 tmux attach 即可。 基本概念Session : 会话，一组窗口的集合，通常来概括一个任务， Session 可以有自己的名字用来切换 Window : 窗口，单个可见窗口，有自己的编号，可以快捷切换。 Pane : 窗格，被划分可小块的窗口，类似于 vim 中的 C-w +v 。 快捷键ctrl + b 来激活快捷键，开启后可以使用一些特定按键来执行操作。 分类 快捷键 功能 基础 ? 获取帮助信息 Session管理 s 列出所有会话 $ 重命名当前会话 d 断开当前会话 Window管理 c 创建一个新窗口 , 重命名当前窗口 w 列出所有窗口 % 水平分割窗口 \" 垂直分割窗口 n 选择下一个窗口 p 选择上一个窗口 0~9 选择0~9对应的窗口 l 在前后两个窗口间切换 w 通过窗口列表切换窗口 f 在所有窗口中查找指定文本 Pane管理 % 创建水平窗格 \" 创建一个垂直窗格 h 将光标移入下左侧窗格 j 将光标移入下下方窗格 l 将光标移入下右侧窗格 k 将光标移入下上方窗格 q 显示窗格编号 o 在窗格间切换 } 与下一个窗格交换位置 { 与上一个窗格交换位置 ! 在新窗口中显示当前窗格 x 关闭当前窗格 SPC 循环切换窗格布局 Alt + o 逆时针旋转窗格面板 Ctrl + o 顺时针旋转窗格面板 方向键 移动光标选择面板 其它 t 在当前窗格显示时间 z 最大化和最小化当前窗口","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"工具环境/Mac","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Mac/"}],"tags":[{"name":"tmux","slug":"tmux","permalink":"https://blog.zucchiniy.com/tags/tmux/"}]},{"title":"Emacs 中辅助键设置","slug":"tools/emacs/emacs-hyper-keybinds","date":"2019-07-31T00:50:00.000Z","updated":"2021-07-02T15:43:09.550Z","comments":true,"path":"posts/3cf89ec9.html","link":"","permalink":"https://blog.zucchiniy.com/posts/3cf89ec9.html","excerpt":"","text":"使用 Emacs 的人，一般都对快捷键的前缀 C 和 M 键不陌生，但其实在 Emacs 中，除了常见的 C 和 M 之外，还有 s 和 H 两个辅助键，但是在不同的操作系统中，辅助键的设置方法也是不一样的，但是我们可以通过在 init.el 文件中设置键位来保证快捷键的一致。 在 windows 系统下 12345678(setq w32-pass-lwindow-to-system nil)(setq w32-lwindow-modifier &#x27;super) ; Left Windows key(setq w32-pass-rwindow-to-system nil)(setq w32-rwindow-modifier &#x27;super) ; Right Windows key(setq w32-pass-apps-to-system nil)(setq w32-apps-modifier &#x27;hyper) ; Menu/App key 在 Mac 系统下 1234(setq mac-command-modifier &#x27;meta) ; make cmd key do Meta(setq mac-option-modifier &#x27;super) ; make opt key do Super(setq mac-control-modifier &#x27;control) ; make Control key do Control(setq ns-function-modifier &#x27;hyper) ; make Fn key do Hyper 在如此配置之后，绑定快捷键过程中，super 对应的是 s 前缀，hyper 对应的是 H 的前缀。 12(global-set-key (kbd &quot;H-b&quot;) &#x27;backward-word) ; 绑定的 Hyper 键(global-set-key (kbd &quot;s-b&quot;) &#x27;backward-word) ; 绑定的 super 键","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"keymap","slug":"keymap","permalink":"https://blog.zucchiniy.com/tags/keymap/"},{"name":"super","slug":"super","permalink":"https://blog.zucchiniy.com/tags/super/"},{"name":"hyper","slug":"hyper","permalink":"https://blog.zucchiniy.com/tags/hyper/"}]},{"title":"Matplotlib 学习笔记","slug":"backends/python/matplotlib-learning-notes","date":"2019-07-29T18:38:00.000Z","updated":"2021-07-02T15:43:09.541Z","comments":true,"path":"posts/c2ad7d73.html","link":"","permalink":"https://blog.zucchiniy.com/posts/c2ad7d73.html","excerpt":"","text":"记录了几个好入的可视化库，学习还是要从基础—— Matplotlib 开始学习。 图表基本12345import numpy as npimport matplotlib.pyplot as pltplt.plot(np.random.rand(10))# 创建图表plt.show() 与 Emacs org mode 交互使用： 1234567891011import matplotlib.pyplot as pltimport matplotlibimport numpymatplotlib.use(&#x27;Agg&#x27;)fig = plt.figure(figsize=(4, 2))x = numpy.linspace(-15, 15)plt.plot(numpy.sin(x)/x)fig.tight_layout()plt.savefig(&#x27;images/python-matplot-fig.png&#x27;)return &#x27;/images/python-matplot-fig.png&#x27; # return filename to org-mode plt.close() : 关闭窗口 plt.gcf().clear() : 每次清空图标内的内容 Matplotlib 图例 折线图12345678910111213141516171819202122232425262728293031323334353637383940414243import pandas as pdimport matplotlib.pyplot as pltimport matplotlibimport numpy as npdf = pd.DataFrame(np.random.rand(10, 2), columns=[&#x27;A&#x27;, &#x27;B&#x27;])f = plt.figure(figsize=(10, 10))fig = df.plot(figsize=(8, 6))# 表头plt.title(&#x27;aa&#x27;)plt.xlabel(&#x27;x&#x27;)plt.xlabel(&#x27;y&#x27;)# 图例位置# best 自适应位置# upper right# upper left# lower left# lower right# right# center left# center right# lower center# upper center# centerplt.legend(loc=&#x27;best&#x27;)# x 轴边界plt.xlim([0, 10])# y 轴边界plt.ylim([0, 1.1])# 设置 x 刻度plt.xticks(range(10))# 设置 y 刻度plt.yticks([0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2])# x 轴刻度标签fig.set_xticklabels(&#x27;%.1f&#x27; % i for i in range(10))# y 轴刻度标签fig.set_yticklabels(&#x27;%.2f&#x27; % i for i in [0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2])# 边界限定了值的范围，刻度表示显示的标尺，这里 x 轴是 0 - 10 ，但是刻度只有 0.0 - 9.0plt.savefig(&#x27;./images/matplotlib02.png&#x27;)return &#x27;/images/matplotlib02.png&#x27; 图表基本样式 :::python import numpy as np import matplotlib.pyplot as plt import matplotlib x = np.linspace(-np.pi,np.pi ,256, endpoint=True) c, s = np.cos(x), np.sin(x) plt.plot(c) plt.plot(s) 显示网格linestyle: 线型color: 颜色linewidth: 宽度axis: x,y,both 显示 x,y,两者 plt.grid(True, linestyle=’–’, color=’gray’, linewidth=’0.5’, axis=’both’) plt.tick_params(bottom=’on’, top=’on’, left=’on’,right=’on’) 显示刻度的方向 in, out, inout matplotlib.rcParams[‘xtick.direction’]=’out’ matplotlib.rcParams[‘ytick.direction’]=’in’ 返回当前 axes 对象，gcf() 返回当前 figure 对象 frame = plt.gca() plt.axis(‘on’) frame.axes.get_xaxis().set_visible(True) frame.axes.get_yaxis().set_visible(False) plt.savefig(‘./images/matplotlib03.png’) return ‘/images/matplotlib03.png’ 线样式 -: 直线 --: 虚线 -.: 点横线 :: 全点线 子图在 matplotlib 中，整个图像为 Figure ，而一个 Figure 中可以有多个 axes。 :::python import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib matplotlib.style.use(&#39;bmh&#39;) fig = plt.figure(figsize=(10, 6), facecolor=&#39;gray&#39;) # 创建图表，在2行2列的第一个位置 ax1 = fig.add_subplot(2, 2, 1) plt.plot(np.random.rand(50).cumsum(), &#39;--g&#39;) ax2 = fig.add_subplot(2, 2, 4) ax2.hist(np.random.rand(50).cumsum(), alpha=0.5, color=&#39;b&#39;) ax4 = fig.add_subplot(2, 2, 2) df2 = pd.DataFrame(np.random.rand(10, 4), columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]) ax4.plot(df2, linestyle=&#39;--&#39;, marker=&#39;.&#39;) plt.savefig(&#39;./images/matplotlib04.png&#39;) return &#39;/images/matplotlib04.png&#39; :::python import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib df = pd.DataFrame(np.random.randn(1000, 4), columns=list(&#39;ABCD&#39;)) df = df.cumsum() df.plot(style=&#39;--&#39;, alpha=0.5, grid=True, figsize=(8, 6), subplots=True, layout=(2, 2)) plt.subplots_adjust(wspace=0, hspace=0.2) plt.savefig(&#39;./images/matplotlib05.png&#39;) return &#39;/images/matplotlib05.png&#39; Series 直接生成图表:::python import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib ts = pd.Series(np.random.randn(12), index=pd.date_range(&#39;1/1/2019&#39;, periods=12)) ts = ts.cumsum() ts.plot( # kind 包括，line, bar, barh kind=&#39;line&#39;, color=&#39;r&#39;, # linestyle -, marker . color g style=&#39;-gx&#39;, # alpha 透明度，0-1 alpha=0.5, use_index=True, rot=0, ylim=[-50, 50], yticks=list(range(-50, 50, 10)), title=&#39;Time Series&#39;, legend=True, label=&#39;test&#39;) plt.grid(True, linestyle=&#39;:&#39;, color=&#39;gray&#39;, linewidth=&#39;0.5&#39;, axis=&#39;both&#39;) plt.savefig(&#39;./images/matplotlib06.png&#39;) return &#39;/images/matplotlib06.png&#39; Dataframe 直接生成图表:::python import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib df = pd.DataFrame(np.random.randn(12, 4), index=pd.date_range(&#39;1/1/2019&#39;, periods=12), columns=list(&#39;abcd&#39;)) df = df.cumsum() df.plot( style=&#39;--.&#39;, alpha=0.8, ylim=[-100, 100], figsize=(10, 8), grid=True, yticks=list(range(-100, 125, 25)), title=&#39;test&#39;, subplots=True) plt.grid(True, linestyle=&#39;:&#39;, color=&#39;gray&#39;, linewidth=&#39;0.5&#39;, axis=&#39;both&#39;) plt.savefig(&#39;./images/matplotlib07.png&#39;) return &#39;/images/matplotlib07.png&#39; 柱关图与堆叠图:::python import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib fig, axes = plt.subplots(4,1, figsize=(12,12)) s = pd.Series(np.random.randint(0,10,16), index=list(&#39;abcdefghijklmnop&#39;)) df=pd.DataFrame(np.random.rand(10,3), columns=list(&#39;ABC&#39;)) # 单系列柱状图 s.plot(kind=&#39;bar&#39;, ax=axes[0], grid=True,legend=True,label=&#39;s&#39;,alpha=0.6) # 多系列柱状图 df.plot(kind=&#39;bar&#39;,ax=axes[1],colormap=&#39;Reds_r&#39;) # 多系列堆叠图 df.plot(kind=&#39;bar&#39;,ax=axes[2], colormap=&#39;Blues_r&#39;, stacked=True) df.plot.barh(ax=axes[3],grid=True,stacked=True,colormap=&#39;BuGn_r&#39;) plt.savefig(&#39;./images/matplotlib08.png&#39;) return &#39;/images/matplotlib08.png&#39; 堆叠柱状图:::python import numpy as np import matplotlib.pyplot as plt category_names = [&#39;Strongly disagree&#39;, &#39;Disagree&#39;, &#39;Neither agree nor disagree&#39;, &#39;Agree&#39;, &#39;Strongly agree&#39;] results = &#123; &#39;Question 1&#39;: [10, 15, 17, 32, 26], &#39;Question 2&#39;: [26, 22, 29, 10, 13], &#39;Question 3&#39;: [35, 37, 7, 2, 19], &#39;Question 4&#39;: [32, 11, 9, 15, 33], &#39;Question 5&#39;: [21, 29, 5, 5, 40], &#39;Question 6&#39;: [8, 19, 5, 30, 38] &#125; def survey(results, category_names): labels = list(results.keys()) data = np.array(list(results.values())) data_cum = data.cumsum(axis=1) category_colors = plt.get_cmap(&#39;RdYlGn&#39;)( np.linspace(0.15, 0.85, data.shape[1])) fig, ax = plt.subplots(figsize=(9.2, 5)) ax.invert_yaxis() ax.xaxis.set_visible(False) ax.set_xlim(0, np.sum(data, axis=1).max()) for i, (colname, color) in enumerate(zip(category_names, category_colors)): widths = data[:, i] starts = data_cum[:, i] - widths ax.barh(labels, widths, left=starts, height=0.5, label=colname, color=color) xcenters = starts + widths / 2 r, g, b, _ = color text_color = &#39;white&#39; if r * g * b &lt; 0.5 else &#39;darkgrey&#39; for y, (x, c) in enumerate(zip(xcenters, widths)): ax.text(x, y, str(int(c)), ha=&#39;center&#39;, va=&#39;center&#39;, color=text_color) ax.legend(ncol=len(category_names), bbox_to_anchor=(0, 1), loc=&#39;lower left&#39;, fontsize=&#39;small&#39;) return fig, ax survey(results, category_names) plt.savefig(&#39;./images/matplotlib09.png&#39;) return &#39;/images/matplotlib09.png&#39; 散点图:::python import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib data = &#123;&#39;a&#39;: np.arange(50), &#39;c&#39;: np.random.randint(0, 50, 50), &#39;d&#39;: np.random.randn(50)&#125; data[&#39;b&#39;] = data[&#39;a&#39;] + 10 * np.random.randn(50) data[&#39;d&#39;] = np.abs(data[&#39;d&#39;]) * 100 plt.scatter(&#39;a&#39;, &#39;b&#39;, c=&#39;c&#39;, s=&#39;d&#39;, data=data) plt.xlabel(&#39;entry a&#39;) plt.ylabel(&#39;entry b&#39;) plt.savefig(&#39;./images/matplotlib010.png&#39;) return &#39;/images/matplotlib010.png&#39; 图中插入数据表12345678910111213141516171819202122232425262728293031323334353637383940414243444546import numpy as npimport matplotlib.pyplot as pltdata = [[66386, 174296, 75131, 577908, 32015], [58230, 381139, 78045, 99308, 160454], [89135, 80552, 152558, 497981, 603535], [78415, 81858, 150656, 193263, 69638], [139361, 331509, 343164, 781380, 52269]]columns = (&#x27;Freeze&#x27;, &#x27;Wind&#x27;, &#x27;Flood&#x27;, &#x27;Quake&#x27;, &#x27;Hail&#x27;)rows = [&#x27;%d year&#x27; % x for x in (100, 50, 20, 10, 5)]values = np.arange(0, 2500, 500)value_increment = 1000colors = plt.cm.BuPu(np.linspace(0, 0.5, len(rows)))n_rows = len(data)index = np.arange(len(columns)) + 0.3bar_width = 0.4y_offset = np.zeros(len(columns))cell_text = []for row in range(n_rows): plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row], edgecolor=&#x27;black&#x27;) y_offset = y_offset+data[row] cell_text.append([&#x27;%1.1f&#x27; % (x/1000.0) for x in y_offset])colors_col = plt.cm.Reds(np.linspace(0, 0.5, len(rows)))colors = colors[::-1]cell_text.reverse()the_table = plt.table(cellText=cell_text, rowLabels=rows, rowColours=colors, colLabels=columns, colColours=colors_col, loc=&#x27;bottom&#x27;)plt.subplots_adjust(left=0.2, bottom=0.2)plt.ylabel(&quot;Loss in $&#123;0&#125;&#x27;s&quot;.format(value_increment))plt.yticks(values * value_increment, [&#x27;%d&#x27; % val for val in values])plt.xticks([])plt.title(&#x27;Loss by Disaster&#x27;)plt.savefig(&#x27;./images/matplotlib011.png&#x27;)return &#x27;/images/matplotlib011.png&#x27; 面积图12345678910import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfig, axes = plt.subplots(2, 1, figsize=(10, 8))df1 = pd.DataFrame(np.random.rand(10, 4), columns=list(&#x27;abcd&#x27;))df2 = pd.DataFrame(np.random.randn(10, 4), columns=list(&#x27;abcd&#x27;))df1.plot.area(colormap=&#x27;Greens_r&#x27;, alpha=0.8, ax=axes[0])df2.plot.area(stacked=False, colormap=&#x27;Set2&#x27;, alpha=0.8, ax=axes[1])plt.savefig(&#x27;./images/matplotlib012.png&#x27;)return &#x27;/images/matplotlib012.png&#x27; 3d 图例1234567891011121314151617181920212223242526from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltimport numpy as npnp.random.seed(196608081)def randrange(n, vmin, vmax): return (vmax-vmin)*np.random.rand(n)+vminfig = plt.figure()ax = fig.add_subplot(111, projection=&#x27;3d&#x27;)n = 100for m, zlow, zhigh in [(&#x27;o&#x27;, -50, -25), (&#x27;^&#x27;, -30, -5)]: xs = randrange(n, 23, 32) ys = randrange(n, 0,100) zs = randrange(n, zlow, zhigh) ax.scatter(xs, ys, zs, marker=m)ax.set_xlabel(&#x27;X Label&#x27;)ax.set_ylabel(&#x27;Y Label&#x27;)ax.set_zlabel(&#x27;Z Label&#x27;)plt.savefig(&#x27;./images/matplotlib013.png&#x27;)return &#x27;/images/matplotlib013.png&#x27; 更多图例更多内容内 Matplotlib Gallery，可以从中找到想使用的图例进行使用。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://blog.zucchiniy.com/tags/Matplotlib/"}]},{"title":"Mac 电脑上使用 Emacs","slug":"tools/emacs/emacs-in-mac","date":"2019-07-28T19:17:00.000Z","updated":"2021-07-02T15:43:09.550Z","comments":true,"path":"posts/d9063434.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d9063434.html","excerpt":"","text":"在 Mac 上使用 Emacs 有两个方案，从 Emacs For Mac OS X 手工下载，然后更新本地，或者是在 homebrew 中增加配置，然后利用 brew upgrade 从 homebrw-emacsmacport 上进行下载和更新。 两种方式获取的 Emacs 有少许不同，具体的见两个项目的简介。 第二种方法的命令如下： 12brew tap railwaycat/emacsmacportbrew install emacs-mac 安装之后，如果要从启动台启动应用，需要在 /applications 和安装位置增加软链接，命令如下 1ln -s /usr/local/opt/emacs-mac/Emacs.app/Applications 这样之后就可以直接在 Alfred 中输入 emacs 直接启动。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"install Emacs","slug":"install-Emacs","permalink":"https://blog.zucchiniy.com/tags/install-Emacs/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://blog.zucchiniy.com/tags/Mac-OS/"}]},{"title":"Python 基础配置","slug":"backends/python/python-evn-config","date":"2019-07-26T00:18:00.000Z","updated":"2021-07-02T15:43:09.542Z","comments":true,"path":"posts/22347697.html","link":"","permalink":"https://blog.zucchiniy.com/posts/22347697.html","excerpt":"","text":"安装安装的时候最好选择将 anaconda 加入到环境变量中，这样可以直接使用 conda 命令来管理包，而不需要增加额外的配置。 国内源镜像国内使用的话，镜像就还是用 清华大学开源软件镜像站 ，按步骤安装： 123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes 就可以了，如果是 conda 不包含的库的话，还是需要使用 pip 命令进行安装的，可以同样配置成清华源 1234567# 临时使用pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package# 设为默认值pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple# 但是这个需要 pip 版本在 10.0.0 以上，如果低的话，可以临时升级pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U 包管理12345678conda list #查看所有的包conda install package_name #安装包conda remove package_name #移除包conda update package_name #升级包conda search search_term #模糊查询包名conda update conda #更新 conda 本身conda update anaconda #更新 anacondaconda update python #更新 Python 中文乱码使用 Anaconda 进行数据处理后生成图片的时候，如果不指定对应字体会导致中文乱码，可以通过下面的方案进行解决。 12345from pylab import mpl# 指定默认字体：解决plot不能显示中文问题mpl.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;Microsoft YaHei&#x27;]# 解决保存图像是负号&#x27;-&#x27;显示为方块的问题mpl.raParams[&#x27;axes.unicode_minus&#x27;] = False Mac 下查找字体可以利用 font_manager 将所有 matplotlib 能使用的字体打印出来。 1234from matplotlib import font_managera = sorted([f.name for f in font_manager.fontManager.ttflist])for i in a: print(i) 如果 matplotlib 中无中文字体，则需要下载对应的 tff 字体只在到 matplotlib/mpl-data/fonts/tff 中，然后使用 font_manager 重新编译一下。 123from matplotlib.font_manager import _rebuild_rebuild() 之后就可以利用上面的方法，将使用新的字体了。 12plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;STFangsong&#x27;]plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"conda","slug":"conda","permalink":"https://blog.zucchiniy.com/tags/conda/"}]},{"title":"实现自己的子弹笔记","slug":"journal/bullet-journal-for-myself","date":"2019-07-17T18:47:00.000Z","updated":"2021-07-02T15:43:09.545Z","comments":true,"path":"posts/f132014a.html","link":"","permalink":"https://blog.zucchiniy.com/posts/f132014a.html","excerpt":"","text":"已经坚持记笔记和做手帐有大概 2 年的时间了，从最开始的只是记，到后来的坚持用手帐进行时间管理，让我获益良多，从最开始的记到后来的边记边思考，到再后来的不停的换手帐的内容，随着改变，也越来越习惯于手帐本身。 最近买了一本 《子弹笔记》 一直在阅读和学习其中的方法，确实比自己的要谘和有用，但是简单的照搬却又不太习惯，所以想整理一下其中有用的思想，然后进行个性化。 子弹笔记官方网站：https://bulletjournal.com/ 思想清单 第一栏列出所有的 正在 做的事情 第二栏列出所有的 应该 做的事情 第三栏列出所有的 你想 做的事情 回顾思想清单 画去不要紧的，或者不重要的内容 找出相关的内容，创建个性化的集子 迁移思想清单 把未来事项移入未来记录 把当月事项移行进月度记录 为月度记录排列主次 把优先事项迁移进每日记录 把附加事项迁移进对应的修改化集子 关键内容索引 : 利用标题和页码定位笔记的内容，而索引无需连续；专用索引与集子类似，提供特定的主题的索引 未来记录 : 用来记录本月以外的任务和事件 月度记录 : 用于一览本月的时间安排和任务。也可以作为你本月的思想清单 每日记录 : 用于快速记录下每一天里所有的想法 快速记录 : 利用简短的符号快速捕捉想法，分成笔记、事件、任务三类，并排序。 集子 : 笔记中模块化的构成部分，用于储存紧密相关的内容。核心领子有索引、未来记录、月度记录、每日记录，但也支持个性化设计。 迁移 : 每月从笔记本中过滤掉的无意义的内容的过程 快速记录中，任务、事件、笔记三种的意义： 任务 : 需要 做的事情，用 “.” 标记，同样的，迁移任务使用 “&gt;” 标记，计划中的任务用 “&lt;” 标记，移除的任务用 删除线 表示 事件 : 经历 过的事情，用 “o” 标记 笔记 : 不想遗忘 的事情，用 “-” 标记 特殊的一些标记，比如重点任务、灵感、长笔记 重点任务 : 在任务前加 “*” 灵感 : 在任务前增加 “!” 长笔记 : 有特殊的想法或者想额外的记录一些内容，使用 “+” 标记 日历页在日历页上，左侧按顺序列出日期，并在日期右侧附上星期，在左侧留出空白空间，以便后续增加特殊符号。 任务页月度记录中的任务页是不断的更新的思想清单，如果有最终的时候，可以未完成的时候进行迁移，也可以调整日期。 未来记录未来记录主要是将本月无法完成的项目，提前写入到未来日记中，或者是读书、学习的特殊记划，这样在月度记录的时候，就能很好的规划我们的生活。 引线法索引有时候页码不连续，但是使用过程中，又不想过多翻回到索引页观看，可以使用引线法，比如在第二块的初始页面中，可以使用 “当前页码/前一部分页码” 的形式进行记录，而同理，结束部分则使用 “后一部分页码/当前页码” ，这种方式可以扩展到不同的本子中，比如使用 “第几册.第多少页” 这种形式记录。 计划旅行计划描述 : 包括要去什么地方，要做什么，和谁一起去，是旅行还是休闲 目的地 : 记录了这次要去的地方，包括景点、住宿等 活动 : 想做什么？旅伴想做什么？ 时间 : 航班时间、当地交通、活动的时间等 预算 : 机票、租车、住宿、汽油、伙食、活动、购物、礼品 行程计划要记录我们出行过程中的事情，比如从哪儿飞到哪儿，怎么入住，有什么特殊的事件吗，等等问题，可以按地点进行记录。 第一栏记录机场，包含对应的事件的页码 第二栏记录时间，包括星期和日期 第三栏记录时间轴上的任务，比如入住酒店、退房、飞住什么地方、要做事情，可以有效的进行规划 个性化调整长笔记长笔记可以记录某一件事情的后续，或者是有什么想法，为什么有这个想法，或者是与人发生了什么样的交流，甚至是思考了什么问题，或者是对某件事的感想，这些可以培养记录的好习惯。 习惯养成这个是与月历相关，可以在页面上记录一个月的习惯养成情况，与日历上的日期一一对应，比如坚持运动、阅读等事情，或者是增加一些希望养成的习惯。 针对阅读，可以设定为阅读某一本书，或者是阅读多少时间，这样可以让任务更具体，而越是具体的任务，越容易完成。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://blog.zucchiniy.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"子弹笔记","slug":"子弹笔记","permalink":"https://blog.zucchiniy.com/tags/%E5%AD%90%E5%BC%B9%E7%AC%94%E8%AE%B0/"},{"name":"手帐体系","slug":"手帐体系","permalink":"https://blog.zucchiniy.com/tags/%E6%89%8B%E5%B8%90%E4%BD%93%E7%B3%BB/"}]},{"title":"Android 刷机实践","slug":"tools/android-flashboot","date":"2019-04-10T00:44:00.000Z","updated":"2021-07-02T15:43:09.548Z","comments":true,"path":"posts/feff8405.html","link":"","permalink":"https://blog.zucchiniy.com/posts/feff8405.html","excerpt":"","text":"获取在刷机之前，需要在电脑上下载 Android Preview 包，一般我都是到安卓中国 ，这里可以下载最新的包。 手机相对下载包的获取，比较难的是有一部支持最新的安卓系统的手机，一般 Preview 版的系统都是默认支持 Google 自己的手机的。 目前只支持 Pixel 系列的手机，包括 XL 系列。 Pixel n Pixel n XL 刷机刷机目前有两个比较麻烦的地方，第一就是需要安装 adb 的命令，也就是 Android 的功能模块，第二就是需要解锁手机。 adb 配置即将 Android SDK 下载下来，然后将其配置到环境变量中即可 Windows 配置 ANDROID_HOME 变量到环境变量中 配置 %ANDROID_HOME%\\platform-tools 到 path 中 配置 %ANDROID_HOME%\\tools 到 path 中 Linux &amp; Mac打开 profile 文件，默认为 .bash_profile 如果使用的是 zsh 则编辑 .zshrc 文件。 将下面的内容放到 profile 文件中 :::shell ANDROID_HOME=~/developerTools/adt-mac/sdk export ANDROID_HOME PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools MacMac 电脑提供了一个自动安装的内容，可以将 adb 相关的内容直接安装，但是如果是想开发 Android 应用的话，则必须要按上面的方案进行配置。 首先需要先安装 brew ，具体方案见 Homebrew ，或者可以直接看其 GitHub 的主页 Homebrew/brew 。 然后执行下面的命令 :::shell brew install --cask android-platform-tools 如果执行刷机的时候，提示 fastboot is too old 则需要重新安装 android-platform-tools , 因为 brew update 更新是不能更新 cask 库的内容的。 :::shell brew cask reinstall android-platform-tools 最后，在命令行中执行 adb devices 不报错刚配置成功。如果配置之后，还依然报错的话，可以检查一下是否在使用过程中，将 USB 调试功能 关闭了。 操作 连接手机 adb devices 获取手机的 device id adb reboot bootloader 进入 bootloader 模式 如果已经解锁了，则进入第8步，如果未解锁则进入第五步 进入到 bootloader 之后，执行 fastboot flashing unlock 如果是 Pixel 2 XL 则执行 fastboot flashing unlock_critical 如果是更早的设备，则需要执行 fastboot oem unlock 进入下载的目录，然后执行 flash-all 脚本，如果是 Windows 则是 flash-all.bat ，其它的则执行 flash-all.sh 执行结束后，手机就已经刷好了，重启就可以使用了 如果执行失败的话，就需要解压目录下的 image 对应的包，然后执行下面的命令 :::shell fastboot flash vendor vendor.img fastboot flash boot boot.img fastboot flash system system.img 然后重启手机就可以了。 V 版手机解锁需要刷入一个工具，才能解锁 :::shell adb push dePixel8 /data/local/tmp adb shell chmod 755 /data/local/tmp/dePixel8 adb shell /data/local/tmp/dePixel8 然后再执行 adb reboot bootloader 就可以正常解锁了。 dePixel8.zip 下载 判断是否 V 版手机 :::shell adb shell getprop|grep cid 如果出现 VZW_001 就是 V 版手机","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Android","slug":"工具环境/Android","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Android/"}],"tags":[{"name":"安卓系统","slug":"安卓系统","permalink":"https://blog.zucchiniy.com/tags/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F/"},{"name":"手动更新手机系统","slug":"手动更新手机系统","permalink":"https://blog.zucchiniy.com/tags/%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"author":"zucchini"},{"title":"如何写总结类的博客","slug":"journal/how-to-write-summary-blog","date":"2019-04-08T00:07:00.000Z","updated":"2021-07-02T15:43:09.546Z","comments":true,"path":"posts/8d4adffc.html","link":"","permalink":"https://blog.zucchiniy.com/posts/8d4adffc.html","excerpt":"","text":"学习是一个将别人的知识转换为自己的知识的过程，这其中最重要的就是思考，如果只是将看到的内容搬到一个地方，那这个过程不能称为学习，只能算是一个备份。 知识从阅读、思考过程中来，当看到一个比较好的用法的时候，我们可以去抄，但是在抄完之后，必须要有一个整理的过程，这个过程也是为了将一个大块的内容，转换成小块的内容，然后将已知的知识点进行巩固，然后将未学习过的点进行归纳，在后面再运用的时候，可以从我们自己的知识库中找到需要的内容，这个过程就是知识管理。 知识管理最重要的内容就是复盘和整理，做为一个单线程的程序员，必须对自己的一系列的知识进行整理和归纳，才能跟上前进的脚步，而现在知识的获取不是问题，真正的问题是知识的整理，毕竟自己好才是真的好。 所以现在我有一套整理的方案，比如阅读到好的文章，先收藏到滴答清单，然后在有时间的时候，把好的文章再重读一遍，然后整理成一篇博客。 再或者读到一个好解决方案，但是这个方案并不了解，一般会再重新搜索一下具体的内容，将文章先能读一遍，然后再把整篇文章细读一遍，然后保存下来，再看看，等觉得文章已经没问题，再进行整理，最后才是写出一篇总结文档，有时候，前几遍读不明白没什么问题，但是如果不经过整理、归纳、重读、复盘这些操作，等到下次，再读到还是不明白，才是真的问题。 知识就是要有学习和进步，哪怕慢点，也是有成效的，最怕的就是看起来很努力，看起来很好学，但事实上，并没有在学，没有进步。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://blog.zucchiniy.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"知识管理","slug":"知识管理","permalink":"https://blog.zucchiniy.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"}]},{"title":"Java 反射获取数据","slug":"backends/java/java-get-field-name","date":"2019-03-17T18:50:00.000Z","updated":"2021-07-02T15:43:09.538Z","comments":true,"path":"posts/29237c14.html","link":"","permalink":"https://blog.zucchiniy.com/posts/29237c14.html","excerpt":"","text":"反射获取成员变量使用 Sql2o 方法读取数据库的时候，发现表名类似，但是有一些差别，如果使用 select * 方式查询，需要针对对象声明多个内容，但是实际上用的都是一样的，所以想通过获取成员变量的名称来拼接成 select 后面的内容，经过尝试，发现可以用下面的方法获取： 12345678public String allName()&#123; String allName = &quot;&quot;; Field[] fields = this.getClass().getDeclaredFields(); for(Field field : fields)&#123; allName += field.getName() + &quot;,&quot;; &#125; return allName.substring(0, allName.length() -1);&#125; 这样之后，调用 allName() 方法就能直接获取对应的变量名称了。 反射获取父类实例化对象中的值12345678910111213141516try &#123; Field[] fields = super.getClass.getDeclaredFields(); for (Field field : fields) &#123; field.setAcessible(true); Method method = super.getClass().getDeclaredMethod(&quot;get&quot; + upperHeadChar(field.getName())); Object obj = method.invoke(super); field.set(this, obj); &#125;&#125; catch (NoSuchMethodException | IllegalAcessException | InvocationTargetException e)&#123; e.printStackTrace();&#125;private static String upperHeadChar(String in)&#123; String head = in.substring(0,1); return head.toUpperCase() + in.substring(1);&#125;","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"后台技术/Java","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Java/"}],"tags":[{"name":"reflex","slug":"reflex","permalink":"https://blog.zucchiniy.com/tags/reflex/"},{"name":"Field","slug":"Field","permalink":"https://blog.zucchiniy.com/tags/Field/"}],"author":"zucchini"},{"title":"Selenium 操作下拉框","slug":"backends/java/select-dropdown-value-by-selenium","date":"2019-02-27T01:05:00.000Z","updated":"2021-07-02T15:43:09.538Z","comments":true,"path":"posts/9b20002f.html","link":"","permalink":"https://blog.zucchiniy.com/posts/9b20002f.html","excerpt":"","text":"使用 Selenium 进行 Web 端的自动化测试的时候，不能通过 findElement 进行自动选择，后来发现，需要先声明一个 Select 类型，再进行选择，实现方法如下： 123456Select dropdown = new Select(driver.findElement(By.id(&quot;selectId&quot;)));dropdown.selectByValue(&quot;optionValue&quot;);// 或者使用 Indexdropdown.selectByIndex(0);// 或者使用下拉框中的内容dropdown.selectByVisibleText(&quot;content&quot;); 这样就可以操作下拉框了。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"后台技术/Java","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Java/"}],"tags":[{"name":"Selenium","slug":"Selenium","permalink":"https://blog.zucchiniy.com/tags/Selenium/"},{"name":"下拉框","slug":"下拉框","permalink":"https://blog.zucchiniy.com/tags/%E4%B8%8B%E6%8B%89%E6%A1%86/"}],"author":"zucchini"},{"title":"Emacs 功能键配置","slug":"tools/emacs/emacs-modifier-keys","date":"2019-02-25T22:10:00.000Z","updated":"2021-07-02T15:43:09.550Z","comments":true,"path":"posts/749f099.html","link":"","permalink":"https://blog.zucchiniy.com/posts/749f099.html","excerpt":"","text":"Emacs 和 Vim 最大的就是快捷键的体系不同，在 Emacs 中，快捷键要有对应的控制键配合，才能正常使用，比如打开 Agenda C-c a 一般指的是 Ctrl + c a 而在 Emacs 中，使用的控制键主要有以下几种： 12345s- : supperS- : ShiftM- : Meta / AltC- : CtrlH- : Hyper 其中 Ctrl、Meta/Alt、Shift这几种快捷键比较常见，但是 supper 这个键就比较少见了，而且在键盘上，一般也看不到，所以我们在配置的时候，需要在配置中声明这几个键被绑定在哪些键上。 如果是在 /Windows/ 系统下需要增加如下的配置： 12(setq w32-lwindow-modifier &#x27;supper w32-apps-modifier &#x27;hyper) 但是如果使用的是 /Mac/ 系统的话要增加如下配置： 1234(setq mac-command-modifier &#x27;meta mac-option-modifier &#x27;super mac-control-modifier &#x27;control ns-function-modifier &#x27;hyper) 但是这样的情况又有另外一个问题，需要在特定的系统中使用，所以我们要在对应的配置上增加上对系统的判断，绑定的方案如下： 1234567891011(when sys/winntp ;; 经过测试，在 windows 下，window 键是不能修改的 (setq ;;w32-lwindow-modifier &#x27;supper w32-apps-modifier &#x27;hyper) (w32-register-hot-key [s-t]))(when sys/macp (setq mac-command-modifier &#x27;meta mac-option-modifier &#x27;super mac-control-modifier &#x27;control ns-function-modifier &#x27;hyper)) 这样我们就可以在不同的系统中正确的使用不同的功能键了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"modifier keys","slug":"modifier-keys","permalink":"https://blog.zucchiniy.com/tags/modifier-keys/"}]},{"title":"Emacs 个人使用","slug":"journal/how-to-use-my-emacs","date":"2019-02-13T03:07:00.000Z","updated":"2021-07-02T15:43:09.546Z","comments":true,"path":"posts/4c7b9a02.html","link":"","permalink":"https://blog.zucchiniy.com/posts/4c7b9a02.html","excerpt":"","text":"使用 Emacs 已经有两三年的时间了，从最开始自己配置了一个垃圾版，到后来使用的 spacemacs ，再到后来又重新配置了一个个人简单版，再到又配置了一个综合版，个人版最大的问题就是慢，启动几十个配置比大神们配置的启动几百个还要慢，但是最大的优势就是符合我的使用习惯，可以用我最喜欢的方式配置，也可以把我认为没用的配置删除掉。 当然使用大神们的配置也有一个问题，太大了，而且对于工程化的配置，总需要跟紧开发的路线，可能更新了版本之后，还需要同步更新自己的配置才能使用。这总是让人觉得特别的不爽，而且想要从头学习配置话，总是有一些东西不知道是为什么，也不知道就言怎么用，可是删除掉就是不行，会慢，会报错，会出各种的问题。 怎么学习 Emacs ? 达到真正融汇贯通的境界? 今天读到的这篇文章让我知道应该如果去使用自己的 Emacs。但是大神毕竟是大神，对于我这样的凡人来说，有点太难了，拿到大神说的这篇文章，1241页的全英文文档。但是从大神的思路中，我觉得我找到了一个比较符合我这样的凡人的路线。 熟悉快捷键 : 这个没什么可说的，如果不熟悉快捷键的话，几乎所有的工具都用不好，但是 Emacs 最大的特点就是可以定制你的快捷键，这样可以让你更容易习惯这个工具，能更快的上手。 复杂插件和抄录配置 : 这个也没什么，在入手之后，一个可以使用的配置才是最合适的配置，如果不能使用，那永远也不知道 Emacs 的美在什么的地方，而且工具不能使用，又怎么能当做工具呢？ 找到自己的插件 : 这里的插件是指的从你抄录的或者使用过的配置中找到有用的配置，然后吸收为自己的配置，这个过程可能是大神们的一步，但是对于我来说不得不拆分为几步才能慢慢的使用。我现在找到的，呼声最高的 Emacs 就是 org mode , 然后就是 magit 。这两个工具几乎是 Emacs 的半边天。当然对于非程序员来说， org mode 就已经是半边天了，很多人就是冲着 org mode 来使用 Emacs 的。 针对自己的插件进行整理和学习 : 将整理出来的插件，针对插件的文档进行阅读和学习，主要是因为这些插件的文档都相对比较短，目前我看到的最后的也就是 org-mode 的341页，与上千页的文档比较，当然是比较简单的了。 阅读 Emacs Manual : 终于到了最重要的功能了，但是经过了之前的学习之后，应该也就能把这本特别长的文档看完看明白了，然后按大神的思路，一页一页的挨着看, 一个 API 一个 API 的读, 不要跳过每个 API , 都在 ielm 里面实践一下，遇到不知道啥鬼用的 API , 去 Google 或 EmacsWiki 上搜索一下, 看看别人怎么用这些API的。 暂时先就这些工作，等我到了这个技术之后，再进行第二次更新。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Emacs","slug":"Emacs","permalink":"https://blog.zucchiniy.com/tags/Emacs/"}]},{"title":"让自己生活的更好","slug":"journal/3-step-to-better-one","date":"2019-02-11T00:13:00.000Z","updated":"2021-07-02T15:43:09.544Z","comments":true,"path":"posts/9c3a1f23.html","link":"","permalink":"https://blog.zucchiniy.com/posts/9c3a1f23.html","excerpt":"","text":"学会早睡想要早睡，需要减少自己的兴奋点，在生活中，如果无法早睡，白天的工作效率也就会降低，可能要拖拉到半夜才完成，这样就成了一个恶性循环了。 我尝试过早睡，但是未必能早起，主要是就算我10点躺下，也不可能在10点半入睡，毕竟手机、pad等等太好玩了。 所以想要早睡的会，要学会给自己降噪。 早一点运动和洗澡，避免淋水让自己重回清醒状态； 调暗室内灯光，尽量用暖色灯； 点燃香薰，或者其它助眠的东西； 阅读简单轻快的小说或者看一些轻松的视频，不要让自己兴奋或者让自己思考； 放下手机； 努力运动作为已经迈入中年油腻男境界的人来说，其实可以好的，比如给自己更好的身材，就算光头也可以很有型，所以运动是必不可少的，不过现在的我还是先从减肥开始，这里就不会有更多的问题，就是坚持二字，必然会瘦下来。 断舍离生活断舍离“把不用的东西扔掉！” 这是非常简单的几乎所有人都知道的真理，但是在生活中，不用的东西到底是怎么定义的，我现在不用，将来也不会用到的一定是。但是我们怎么知道将来会不会呢？ 所以应该把自己的物欲降低，先从不买或者真正有用或者想用的时候再买，千万不能图打折，图降价而购入一些不需要的东西。 特别是对于自己有吸引力的东西，对我来说，最常购买的东西就是图书，经常看到当当网、京东网、亚马逊有便宜的或者折扣的力收的时候就管不住自己的手，而有一些商家还经常用优惠来吸引人。结果导致了购买了许多的书，但是实际上看的书特别少。 所以在这里，自己定义了一个新的书单，用来记录自己实际读了什么、要读什么，再定一个计划，比如：阅读多少本已购书籍之后再购入新的书籍。 对于一些可能用又不可能不用，或者近一年都不会用的东西都扔掉，这样就可以让我们的家更整洁。等到一年后或许你发现你也不会用这个东西了。或者是再重新购入即可。 思想断舍离除了我们的生活，对于我们的思想也应该 “断舍离” 。 当有了一个想法，如果一直想着，就会把时间和记忆固定在这里，而如果中途又遇到另外的事情，又特别容易将某些事情忘记，所以我们应该选择记下来，用实体的东西代替大脑，这样可以让我们思考更多的东西。 或者我们忽然读到了一篇好文章，但是现在不适合详读，我们可以在这个是时候把文章通过工具记录下来，等有时间了，再重新详读这篇文章。 比如在通勤的路上，会遇到一些比较好的文章，我会利用手机 app 将文章保存到 滴答 清单中，当有时间的时候，将好的文章再重新阅读一遍，或者重新学习一遍。 当然有时候，也会因为懒怠繁忙导致累积了许多内容没有读，最多的时候，滴答的待办清单中有500篇文章要读。 除了这些，还可以把自己心中的那些不满啊、忧愁啊都记下来，这样也可以有效的控制我们的感情，让自己更开心的生活。 这个主要用了两个东西，一个是电子版的笔记系统——Org Mode Journal系统，另外一个就是一个简单的横格本和一支笔就可以手工记录了，具体的可以看一些手帐相关的文章来学习如何简单清晰的记录生活。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://blog.zucchiniy.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"减法生活","slug":"减法生活","permalink":"https://blog.zucchiniy.com/tags/%E5%87%8F%E6%B3%95%E7%94%9F%E6%B4%BB/"}]},{"title":"2019 读书/观影清单","slug":"journal/book-movie-list-2019","date":"2019-01-03T16:00:00.000Z","updated":"2021-07-02T15:43:09.545Z","comments":true,"path":"posts/4ac58b33.html","link":"","permalink":"https://blog.zucchiniy.com/posts/4ac58b33.html","excerpt":"","text":"小说 尸语者 无声的证词 十一根手指 清道夫 幸存者 偷窥者 天谴者 大唐狄公案 一 大唐狄公案 二 大唐狄公案 三 大唐狄公案 四 大唐狄公案 五 大唐狄公案 六 心理罪系列 电影 惊奇队长 复仇者联盟 4 惊声尖笑 1 惊声尖笑 2 惊声尖笑 3 惊声尖笑 4 x 战警：黑凤凰 黑衣人：全球追缉 蜘蛛侠：英雄远征 深夜食堂 &lt;2019-10-04 Fri&gt; 大侦探皮卡丘 &lt;2019-10-05 Sat&gt; 超能陆战队 &lt;2019-10-06 Sun&gt; 沉默的证人 &lt;2019-10-10 Thu&gt; 利刃出鞘 &lt;2019-12-12 Thu&gt; 犯罪现场 &lt;2019-12-14 Sat&gt; 连续剧 东宫 知否知否应是绿肥红瘦 犯罪心理1 无人生还 心理法医 专题电影记录漫威系列 《钢铁侠》 《钢铁侠》 《无敌浩克》 《钢铁侠2》 《雷神》 《美国队长》 《复仇者联盟》 《钢铁侠3》 《雷神2》 《美国队长2》 《银河护卫队》 《复仇者联盟2》 《蚊人》 《美国队长3》 《奇异博士》 《银河护卫队2》 《蜘蛛侠》 《雷神3》 《黑豹》 《复仇者联盟3》 《死待》 《死待2》 《蜘蛛侠-英雄归来》 『2017-9-15』 《复仇者联盟3:无限战争》『2018-5-13』 《蚁人2:黄蜂女现身》『2018-8-24』 《毒液:致命守护者》『2018-11-11』 《蜘蛛侠》 《蜘蛛侠2》 《蜘蛛侠3》 DC 影业 《正义联盟》『2017-11-22』 《海王》『2018-12-09』 其它 《神奇动物在哪里：格林德沃之罪》『2018-11-24』 《你的名字》『2017-11-20』 《银魂》『2017-9-1』 《疯狂动物城》 《看不见的客人》 『2017-9-17』 《天才枪手》 《环太平洋 雷霆再起》『2018-6-24』 《神探》『2018-5-25』 《古墓丽影 缘起之战》『2018-6-27』 《玛丽与魔女之花》 『2018-6-28』 《泄密者》『2018-7-19』 《唐人街探案2》『2018-2-22』 《无双》","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"年度清单","slug":"年度清单","permalink":"https://blog.zucchiniy.com/tags/%E5%B9%B4%E5%BA%A6%E6%B8%85%E5%8D%95/"},{"name":"读书清单","slug":"读书清单","permalink":"https://blog.zucchiniy.com/tags/%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"},{"name":"电影清单","slug":"电影清单","permalink":"https://blog.zucchiniy.com/tags/%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/"},{"name":"电视清单","slug":"电视清单","permalink":"https://blog.zucchiniy.com/tags/%E7%94%B5%E8%A7%86%E6%B8%85%E5%8D%95/"}]},{"title":"MySQL 中三个常见的问题解决","slug":"backends/mysql/mysql-forget-root-password","date":"2018-09-27T00:01:00.000Z","updated":"2021-07-02T15:43:09.539Z","comments":true,"path":"posts/53f313a5.html","link":"","permalink":"https://blog.zucchiniy.com/posts/53f313a5.html","excerpt":"","text":"重置 root 用户密码因为长时间未使用 MySql 导致忘记了 root 密码，现在将修改 root 用户密码的方法记录下来。 修改配置1vi /etc/my.cnf 在 [mysqld] 中添加 skip-grant-tables 例如： 1234[mysqld]skip-grant-tablesdatadir=/var/lib/MySQLsocket=/var/lib/mysql/mysql.sock 重启mysql1service mysql restart 用户无密码登录1mysql -uroot -p (直接点击回车，密码为空) 选择数据库并修改密码123use mysql;update user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27;;flush privileges; 删除并重启 mysql 服务这个时候发现，确实可以用新的密码登录了， 但是操作的时候会提示：ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 。 这是因为少了一步修改导致，执行下面的命令进行修改： 1alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;youpassword&#x27;; 执行的时候发现会提示一个新的报错： ERROR 1819 (HY000): Your password does not satisfy the current policy requirements ，经过搜索，发现是因为密码有要求导致，可以选择使用一个包含大小写字母、数字和符号的密码，也可以选择更新一个简单的密码： 1set global validate_password_policy=0; 这次密码的问题就彻底解决了。 报错 10060除了可能是因为用户权限不足外，还有可能是服务器不允许请求 3306 端口，需要在服务器管理中，增加入站规则，允许 3306 端口即可。 具体的位置在： 服务器管理 =&gt; 高级安全 Windows 防火墙 =&gt; 入站规则 =&gt; 新建规则 =&gt; 端口3306 =&gt; 允许连接 清理连接数在管理 MySQL 服务器的过程中，会出现连接时间过长的问题，分析之后发现主要是之前写的操作 MySQL 的程序未正常结束，导致资源占用过高。 这时可以使用以下的方案进行自理： 123456show status like &#x27;Threads%&#x27;;show variables like &#x27;%max_connections%&#x27;;show global status like &#x27;Max_used_connections&#x27;;show status;show processlist;show OPEN TABLES where In_use &gt; 0; 这时可以找到真正占用数据库资源的进程，然后使用 kill &lt;process id&gt; 结束掉进程。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"重置 root 密码","slug":"重置-root-密码","permalink":"https://blog.zucchiniy.com/tags/%E9%87%8D%E7%BD%AE-root-%E5%AF%86%E7%A0%81/"},{"name":"报错 10060","slug":"报错-10060","permalink":"https://blog.zucchiniy.com/tags/%E6%8A%A5%E9%94%99-10060/"},{"name":"清理连接数","slug":"清理连接数","permalink":"https://blog.zucchiniy.com/tags/%E6%B8%85%E7%90%86%E8%BF%9E%E6%8E%A5%E6%95%B0/"}]},{"title":"Linux 查看端口占用情况","slug":"tools/linux/ensure-port-use-on-linux","date":"2018-09-03T18:53:00.000Z","updated":"2021-07-02T15:43:09.556Z","comments":true,"path":"posts/f8281811.html","link":"","permalink":"https://blog.zucchiniy.com/posts/f8281811.html","excerpt":"","text":"Linux 查看启动的后台进程，可以使用下面两个命令。 lsoflsof -i:&lt;port&gt; 用来查看某一端口占用情况，可以查询到对应的 COMMAND PID USER TYPE。 netstatnetstat -tunlp | grep &lt;port&gt; 用于查看指定的端口号的进程情况，可以查看端口的监听情况，最后一项则是对应的 COMMAND 和 PID。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"lsof","slug":"lsof","permalink":"https://blog.zucchiniy.com/tags/lsof/"},{"name":"netstat","slug":"netstat","permalink":"https://blog.zucchiniy.com/tags/netstat/"}]},{"title":"Git 上传文件超出最大值","slug":"tools/git/git-hung-up-unexpectedly","date":"2018-08-30T01:00:00.000Z","updated":"2021-07-02T15:43:09.553Z","comments":true,"path":"posts/a2153400.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a2153400.html","excerpt":"","text":"昨天在上传打包的程序的时候，git 意外报错了，试了一下，并不是因为有冲突什么的，仔细看了一下报错： 发现是 OpenSSL 中报的错，确认了一下 error 发现是因为上传的文件过大导致的。需要将 postbuffer 调整一下： 1git config http.postbuffer 523288000 再上传一次，果然可以了。查询一下看看到底修改了什么 1git config --list 再查看一下： 确认是修改了对应的最大 post 的请求的值。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"postbuffer","slug":"postbuffer","permalink":"https://blog.zucchiniy.com/tags/postbuffer/"},{"name":"hung up","slug":"hung-up","permalink":"https://blog.zucchiniy.com/tags/hung-up/"}]},{"title":"cmder 无法显示中文","slug":"tools/cmder-cannot-display-chinese","date":"2018-08-29T01:04:00.000Z","updated":"2021-07-02T15:43:09.548Z","comments":true,"path":"posts/d5d74de1.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d5d74de1.html","excerpt":"","text":"cmder 默认是不支持中文字符的，可以在 Setting &gt; Startup &gt; Environment 下增加一行语言设置： 1set LANG=zh_CN.UTF8 然后重启 cmder 即可。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Windows","slug":"工具环境/Windows","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Windows/"}],"tags":[{"name":"cmder","slug":"cmder","permalink":"https://blog.zucchiniy.com/tags/cmder/"}],"author":"zucchini"},{"title":"编写自己的 Hugo 主题","slug":"fronts/create-new-theme-for-hugo","date":"2018-08-21T22:38:00.000Z","updated":"2021-07-02T15:43:09.543Z","comments":true,"path":"posts/c6e7960e.html","link":"","permalink":"https://blog.zucchiniy.com/posts/c6e7960e.html","excerpt":"","text":"页面使用 hugo new theme paladin 直接创建一个新的主题，然后可以在当前博客中（已经完成了多篇文章，但是还想自己定义一个主题）或者在新主题中增加测试用的项目。 目前所实现的大概样式如下： 创建之后，在 themes 目录下可以看到整个项目结构: themes/paladin ├── LICENSE ├── archetypes │ └── default.md ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── footer.html │ └── header.html ├── readme.md ├── static │ └── css │ └── stylesheet.css └── theme.toml 6 directories, 12 files 可以看到目录下有一些已经创建好的 html 目录，有几个需要编辑的，分别是 single.html ， index.html ， 404.html ， footer.html 和 header.html 这几个文件。 _default这里放的，是主要几个网站模板，用来提交一些默认的配置的。 single.html 这个是用来渲染生成的单页文章的，主要是 content/ 下的内容，可以用来渲染页面的名称、作者、时间和文章的具体内容。 list.html 这个是用来渲染生成的列表页的，包括文章列表页或者是标签列表和分类列表页。 partials这个目录下主要是放需要利用的代码片断，通过 partial 方法调用。 header.html 这里主要定义 &lt;head&gt; 标签和导航栏 &lt;nav&gt; 相关内容。 footer.html 这里定义了网页脚标位置的相关内容。 实现主题参照了 hugo-theme-hiruko 的样式，去掉了一些用不到的功能。 主要使用了bootstrap4，其中的一些图标来源自阿里巴巴的矢量库，用起来方便快捷。 当文章过多时，可以使用连续页面的样式，如果不想使用，可以用上一页下一页的方式。通过参数 paginateOriginalStyle 来控制，如果为 true 则是上一页下一页的样子，如果是 false 则如下图： 将社交链接和logo放到到 about.html 页面中，可以方便的看到作者的相关内容。 如果想修改logo的话，需要修改主题目录下的 static/media/zlogo.png 文件即可。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"hugo","slug":"前端技术/hugo","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/hugo/"}],"tags":[{"name":"Hugo","slug":"Hugo","permalink":"https://blog.zucchiniy.com/tags/Hugo/"},{"name":"theme","slug":"theme","permalink":"https://blog.zucchiniy.com/tags/theme/"}]},{"title":"用 Python 爬取小说","slug":"backends/python/python-download-novel","date":"2018-08-14T18:41:00.000Z","updated":"2021-07-02T15:43:09.542Z","comments":true,"path":"posts/6dd2e3ae.html","link":"","permalink":"https://blog.zucchiniy.com/posts/6dd2e3ae.html","excerpt":"","text":"Python 爬取网络的内容是非常方便的，但是在使用之前，要有一些前端的知识，比如： HTML、 CSS、XPath 等知识，再会一点点 Python 的内容就可以了。 因为使用的是 Anaconda ，所以大多数的包都已经有了，但是在使用过程中也有一些小问题，但是最终程序是实现了的。 BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。非常好用，具体的 文档可以从这里跳转 ，利用这篇文章可以让你轻松的进行网页的解析。可以把仅有的一点前端知识也略去了。 requests 适合正常人类使用的一个 HTTP 解析工具 time 让网站以为你不是电脑 sys 显示和刷新 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# _*_ coding:UTF-8 _*_from bs4 import BeautifulSoupimport requestsimport timeimport sys&quot;&quot;&quot;download 《武动乾坤》 from www.biqukan.comParameters: NoneReturns: None&quot;&quot;&quot;class downloader(object): def __init__(self): self.server = &quot;http://www.biqukan.com&quot; self.target = &quot;http://www.biqukan.com/3_3012&quot; self.names = [] self.urls = [] self.nums = 0 &quot;&quot;&quot; To get Urls for download &quot;&quot;&quot; def get_download_url(self): req = requests.get(url=self.target) html = req.text div_bf = BeautifulSoup(html, &quot;html.parser&quot;) div = div_bf.find_all(&quot;div&quot;, class_=&quot;listmain&quot;) a_bf = BeautifulSoup(str(div[0]), &quot;html.parser&quot;) a = a_bf.find_all(&quot;a&quot;) self.nums = len(a[12:]) with open(&#x27;武动乾坤目录.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: for each in a[12:]: f.write(each.string) self.names.append(each.string) f.write(self.server + each.get(&quot;href&quot;)) self.urls.append(self.server + each.get(&quot;href&quot;)) &quot;&quot;&quot; To get content Parameters: target - 下载链接 Returns: content - 章节内容 &quot;&quot;&quot; def get_contents(self, target): headers = requests.utils.default_headers() headers[&#x27;User-Agent&#x27;] = &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 Firefox/61.0&#x27; req = requests.get(url=target, headers=headers) html = req.text bf = BeautifulSoup(html, &quot;html.parser&quot;) texts = bf.find_all(&quot;div&quot;, class_=&quot;showtxt&quot;) content = texts[0].text.replace(&#x27;\\xa0&#x27; * 8, &#x27;\\n\\n&#x27;) return content &quot;&quot;&quot; To save to text Parameters: name - 章节名称 path - 当前路径 + 小说名 text - 章节内容 Returns: None &quot;&quot;&quot; def writer(self, name, path, text): # writer_flag = True with open(path, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(name + &#x27;\\n&#x27;) f.writelines(text) f.write(&#x27;\\n\\n&#x27;)if __name__ == &quot;__main__&quot;: dl = downloader() dl.get_download_url() print(&quot;第&quot;, dl.nums, &quot;章&quot;) print(&quot;开始下载:&quot;) for i in range(dl.nums): time.sleep(1) dl.writer(dl.names[i], &#x27;武动乾坤.txt&#x27;, dl.get_contents(dl.urls[i])) sys.stdout.write(&quot; 已下载:%.3f%%&quot; % float(i/dl.nums*100) + &#x27;\\r&#x27;) sys.stdout.flush() print(&quot;下载完成&quot;) 几个小点需要注意： 不能访问的过快，所以在循环中进行一次等待，我这里用的是 time.sleep(1) 为了不被反爬虫识别为爬虫，需要在访问的时候，增加一个 header ，利用 headers = requests.utils.default_headers() 和 headers[&#39;User-Agent&#39;] = &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 Firefox/61.0&#39; 两行，就可以不被识别了 解析的时候，出现了一个问题，就是一开始从目录页获取的时候，只能读取 193 篇文章，经过排查，发现是在使用 BeautifulSoup 的时候解析的有点问题，将原本的 &quot;lxml&quot; 方式修改为&quot;html.parser&quot; 方式就可以了 不过因为这本小说字数真的有点多，所以下载过程有点慢，不过整体来说还是可以使用的。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"beautifusoup","slug":"beautifusoup","permalink":"https://blog.zucchiniy.com/tags/beautifusoup/"},{"name":"下载小说","slug":"下载小说","permalink":"https://blog.zucchiniy.com/tags/%E4%B8%8B%E8%BD%BD%E5%B0%8F%E8%AF%B4/"}]},{"title":"select into 和 insert into select","slug":"backends/mysql/select-into-in-mysql","date":"2018-08-06T22:21:00.000Z","updated":"2021-07-02T15:43:09.539Z","comments":true,"path":"posts/6be6380e.html","link":"","permalink":"https://blog.zucchiniy.com/posts/6be6380e.html","excerpt":"","text":"SELECT INTOSELECT INTO 语句从一个表复制数据，然后把数据插入到另一个表中。 MySQL 是不支持 select ... into ，但是可以使用 insert into ... select，当然也可以使用 create table &lt;new table&gt; select * from &lt;old tabel&gt; 可以复制所有的列插入到新表中: 123select *into newtable [in externaldb]from table 或者复制希望的列到新表中: 123select column_name(s)into newtable [in externaldb]from table; INSERT INTO SELECT这个命令可以从一个表复制到另一个表。这个表之前的数据对最后的结果不会有影响。 同 select ... into 一样，可以所有列也可以指定列。 所有数据： 12insert into table2select * from table1; 指定列： 1234insert into table2(solumn_name(s))select column_name(s)from table1;","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"select into","slug":"select-into","permalink":"https://blog.zucchiniy.com/tags/select-into/"},{"name":"insert into select","slug":"insert-into-select","permalink":"https://blog.zucchiniy.com/tags/insert-into-select/"}]},{"title":"apt-get 中 update 与 upgrade 的区别","slug":"tools/linux/apt-get-update-and-upgrade","date":"2018-08-02T01:14:00.000Z","updated":"2021-07-02T15:43:09.555Z","comments":true,"path":"posts/b38b9bda.html","link":"","permalink":"https://blog.zucchiniy.com/posts/b38b9bda.html","excerpt":"","text":"update : 更新 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的地址,这样才能获取到最新的软件包。upgrade : 升级已安装的所有软件包，升级之后的版本就是本地地址里的，因此，在执行 upgrade 之前一定要执行 update , 这样才能更新到最新的。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"apt-get","slug":"apt-get","permalink":"https://blog.zucchiniy.com/tags/apt-get/"},{"name":"apt","slug":"apt","permalink":"https://blog.zucchiniy.com/tags/apt/"}]},{"title":"Layui 表格","slug":"fronts/layui-table-paging","date":"2018-08-01T22:35:00.000Z","updated":"2021-07-02T15:43:09.544Z","comments":true,"path":"posts/91a72e5d.html","link":"","permalink":"https://blog.zucchiniy.com/posts/91a72e5d.html","excerpt":"","text":"Layui 分页是由 laypage 实现的，所以既需要分页 laypage 还需要数据表格相关的内容。 数据表格设置1234table.render(&#123;page: true...&#125;) 这样就可以进行分页了，但是如果想要修改分页的样式，可以按下面的方式进行修改： 123456789table.render(&#123; page: &#123; layout: [&#x27;limit&#x27;,&#x27;count&#x27;,&#x27;prev&#x27;,&#x27;page&#x27;,&#x27;next&#x27;,&#x27;skip&#x27;] // 分页布局 ,groups: 1 // 只显示1个连续页码 ,first: false // 不显示首页 ,last: false // 不显示尾页 ,theme: &#x27;#c00&#x27; // 可以传入颜色或者任意普通字符 &#125;&#125;) 其中 layout 中支持数据有： count 总条目输区域 prev 上一页区域 page 分页区域 next 下一页区域 limit 条目选项区域 refresh 页面刷新区域 skip 快捷跳页区域 实现复选框在后来的版本，已经提供了复选框功能了。 实现首先要在 templet 加上行号数据 123&lt;script type=&quot;text/html&quot; id=&quot;test_id&quot;&gt; &lt;input type=&quot;checkbox&quot; title=&quot;testbox&quot; id=&quot;id&#123;&#123;d.LAY_TABLE_INDEX&#125;&#125;&quot;&gt;&lt;/script&gt; 然后在 table 的表头中增加对应的内容 1234567table.render(&#123; cols: [[ //表头 field: &#x27;test&#x27; ,title: &#x27;test&#x27; ,templet: &#x27;#test_id&#x27; ]]&#125;); 然后对数据进行赋值 12345var data = res.data;for(var item in data)&#123; $(&#x27;#testbox&#x27; + data[item].LAY_TABLE_INDEX).attr(&#x27;checked&#x27;, &#x27;checked&#x27;);&#125;form.render(); 这主要是因为 table 中默认有一个数值，叫 LAY_TABLE_INDEX 是用来做为返回的组数据的行号，这里使用这个参数对每一行进行操作，就可以了。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"前端技术/JavaScript","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"layui","slug":"layui","permalink":"https://blog.zucchiniy.com/tags/layui/"}]},{"title":"Eclipse 项目层次结构设置","slug":"tools/eclipse-package-presentation","date":"2018-07-31T22:29:00.000Z","updated":"2021-07-02T15:43:09.549Z","comments":true,"path":"posts/8562600d.html","link":"","permalink":"https://blog.zucchiniy.com/posts/8562600d.html","excerpt":"","text":"Eclipse 中新建工程或者是导入一个工程，包层次默认为 Flat ，也就是完成名称，但是这种显示会让包结构非常复杂，而且非常不好找，一般我是将其配置为 Hierarchical 即分层次的。 路径在 Windows-&gt;Navigation-&gt;Show View Menu-&gt;Package Presentation-&gt;Hierarchical 下，调整后，包会按文件夹样式一层层显示。 当然，也可以使用快捷键 Ctrl + F10 打开，将 Package Presentation 调整为 Hierarchical 即可。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Eclispe","slug":"工具环境/Eclispe","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Eclispe/"}],"tags":[{"name":"presentation","slug":"presentation","permalink":"https://blog.zucchiniy.com/tags/presentation/"}],"author":"zucchini"},{"title":"in 和 exists 的不同","slug":"backends/mysql/how-difference-between-in-and-exists-in-sql","date":"2018-07-26T01:23:00.000Z","updated":"2021-07-02T15:43:09.538Z","comments":true,"path":"posts/4a975a81.html","link":"","permalink":"https://blog.zucchiniy.com/posts/4a975a81.html","excerpt":"","text":"in OR existsin 是把外表和内表做 hash 连接，而 exists 是对外表作 loop 循环，每次 loop 循环再对内表进行查询。 简单的认为 exists 比 in 的效率高的说法是不准确的。 如果两个表大小相当，则 in 和 exists 的效率是差不多的，如果两个表的一大一小，则子查询表大的用 exists，子查询表小的用 in。 1select * from a where id in(select id where b); 即我们可以理解， in 实际上是做了两个循环： 1234567for(int i=0;i&lt; a.length;i++)&#123; for(int j = 0; j &lt; b.length;j++)&#123; if(a[i].id == b[j].id)&#123; return a[i]; &#125; &#125; &#125; 所以极限点是 a.length * b.length 。 同理，可以把 exists 理解为： 12345for(int i = 0;i &lt; a.length;i++)&#123; if(exists(a[i].id))&#123; return a[i]; &#125; &#125; 这里需要说明的是： exists(a[i].id) 的过程，实际上是去数据库中查询 b 表的过程。 所以在看这两种查询的时候，如果 a 表有10000条记录，b表有100条记录，则 in 需要遍历 10000 * 100 次，但是如果 b 表有 10000000 条记录，则 in 需要 10000 * 10000000 次。同样的数据，如果是使用 exists 的话，则是需要做一个 10000 次数据库查询，所以 子查询的表较大时，最好使用 exits 去做查询。但是如果两个表差不多大，或者子查询的表较小的时候，就可以选择 in 做查询了。 not in OR not existsnot in 和 not exists 两个的选择就比较简单了，就是仅使用 not exists 即可。其原因主要有两个： not in 会出现 BUG表t1 c1 c2 1 2 1 3 表t2 c1 c2 1 2 1 先执行 not in 1select * from t1 where t2 not in(select c2 from t2); 这个时候，我们可以看到，先查询出 t2.c2 的值(2,null), 也就是，我们把这个语句变成了 select * from t1 where t2 &lt;&gt; 2 and t2 &lt;&gt; null 。 这是为什么呢？ 这主要是因为 null 是无法进行 /操作/ 的，也就是 null 的几个原则： 如果 null 参与算术运算，则该算术表达式的值为 null 。 如果 null 参与比较运算，则结果可视为 false 。 如果 null 参与聚集运算，则聚集函数都置为 null 。除 count(*) 之外。 这个时候，我们可以看到，查询回来的结果是空，但是这并不是我们想看到的。这时我们来测试一下 not exists 方法。 1select * from t1 where not exists(select c2 from t2 where t2.c2 = t1.c2); 得到的结果是 c1 c2 1 3 OK，这就是我们想要的结果。 not in 比 not exists 慢如果查询语句使用了 not in 那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。 所以，我们在选择的时候，不要使用 not in 而是需要将这些语句用 not exists 来替换。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"exists","slug":"exists","permalink":"https://blog.zucchiniy.com/tags/exists/"},{"name":"in","slug":"in","permalink":"https://blog.zucchiniy.com/tags/in/"}],"author":"zucchini"},{"title":"利用 Travis 自动部署博客","slug":"tools/deploy-blog-by-travis","date":"2018-07-14T18:27:00.000Z","updated":"2021-07-02T15:43:09.549Z","comments":true,"path":"posts/696d7205.html","link":"","permalink":"https://blog.zucchiniy.com/posts/696d7205.html","excerpt":"","text":"Travis CI 是一个非常好用持续集成工具。 集成 主要是用来将多个用户的开发模块构建成一个可运行版本；而 持续集成 则是在集成之上，尽量将每一次提交都进行一次构建，这个个过程就是 持续集成 。 Travis 自动构建Travis Ci 的自动构建周期分为两步： install Script 但是我们可以根据这两步将相关的内容分成更细的步骤： before_install install befor_script script after_success 或者 after_failure before_deploy deploy after_deploy after_script 持续集成就是把一系列的手工操作合并成一个脚本的过程。 所以可以这样实现部署脚本: 12345678910111213141516sudo: falselanguage: goos: osxinstall:brew install hugoscript: - hugo --config jane-config.tomlbranches: only: - sourceafter_success: - git add -A - git commit -m &quot;update blog&quot; - git push -u origin master 这个脚本中，我们主要工作是生成 hugo 博客这一步，如果成功了，我们就进行提交，也就完成了。 Travis GitHub Pages经过查阅之后，发现 Travis Ci 本身就支持直接部署到 GitHub Pages 上，并拥有单独的章节。 个人令牌在 GitHub 中的 Setting 下的 Developer settings 中，有一个 Personal access tokens 中，可以生成，然后配置到 Travis Ci 对应的 My Repositories 中的项目中，一般的话，使用 public_repo 权限就足够了。 如果在 My Repositories 中看不到 Settings ，可以在 More options 中找到 Settings 然后在 Environment Variables 中配置对应的令牌即可。 个人配置在项目中新增 .travis.yml ，内容如下： 12345678deploy: provider: pages skip-cleanup: true github-token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable keep-history: true on: branch: master GitHub Pages 默认的一些参数： local-dir: 推送到 GitHub Pages 的目录，当前路径的相对路径，默认为当前路径 repo: 项目仓库的地址，默认为当前项目 keep-history: 可选参数，使用递增的推送信息代替强制推送，默认为 false target-branch: 将 local-dir 内容推送的分支，默认为 gh-pages ，如果 keep-history 为 true ，则强制推送 git push -f fqdn: 可选参数，设置用户的自定义域名，默认为无自定义域名 project-name: 默认为 fqdn 的值或者是仓库的固定路径，用于元数据 email: 可选参数，提交人信息，默认为 &#x64;&#x65;&#x70;&#108;&#111;&#121;&#64;&#116;&#x72;&#97;&#x76;&#105;&#115;&#45;&#99;&#105;&#46;&#x6f;&#114;&#103; name: 可选参数，提交人，默认为 Deployment Bot committer-from-gh: 可选参数，默认为 false ，允许令牌拥有者使用，会覆盖掉 email 和 name 两个的值 allow-empty-commit: 可选参数，默认为 false ，仅在 keep-history 参数为 true 时启用 github-url: 可选参数，默认为 github.com ，是企业级自托管 GitHub 项目的 URL 地址 verbose: 可选参数，冗余的内部步骤，默认为 false 备注： 默认情况下，travis 会自动执行 git submodule init ，但是需要使用 https 的路径，否则需要配置 ssh key ，而 GITHUB_TOKEN 要保证和 travis 设置的变量一致，名称和值都要一致 fqdn 如果需要设置自定义域名，可以设置这个参数，travis 会自动生成 CNAME 文件提交，同时要设置 config.toml 中的相应的 baseURL branches: only: source 等价于 deploy: on: branch: source Environment Variables除了令牌之后，我们也可以将 name 、 email 等相关信息配置到这里，比如推送的分支，可以设置为 P_BRANCH 然后在推送的时候，使用 ${P_BRANCH} 来引用。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"travis","slug":"工具环境/travis","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/travis/"}],"tags":[{"name":"hugo","slug":"hugo","permalink":"https://blog.zucchiniy.com/tags/hugo/"},{"name":"travis","slug":"travis","permalink":"https://blog.zucchiniy.com/tags/travis/"},{"name":"自动部署博客","slug":"自动部署博客","permalink":"https://blog.zucchiniy.com/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"}],"author":"zucchini"},{"title":"新增 MySQL 用户","slug":"backends/mysql/mysql-create-new-user","date":"2018-07-11T23:17:00.000Z","updated":"2021-07-02T15:43:09.539Z","comments":true,"path":"posts/5688b61f.html","link":"","permalink":"https://blog.zucchiniy.com/posts/5688b61f.html","excerpt":"","text":"创建本地用户 1create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;password&#x27;; 创建局域网用户 1create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27;; 刷新 1flush privileges; 修改密码 1set password for &#x27;test&#x27;@&#x27;localhost&#x27; = password(&#x27;newpassword&#x27;); 如果是当前用户： 1SET PASSWORD = PASSWORD(&quot;newpassword&quot;); 授权 授权相关操作见: MySQL 数据库设置远程权限 这里补充一下 MySql 移除权限的命令： 1REVOKE privilege ON databasename.tablename FROM &#x27;username&#x27;@&#x27;localhost&#x27;; 删除用户 1drop user &#x27;username&#x27;@&#x27;localhost&#x27;","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"create user","slug":"create-user","permalink":"https://blog.zucchiniy.com/tags/create-user/"},{"name":"set password","slug":"set-password","permalink":"https://blog.zucchiniy.com/tags/set-password/"}]},{"title":"git submodule 管理子项目","slug":"tools/git/manage-submodule-by-git","date":"2018-07-06T00:40:00.000Z","updated":"2021-07-02T15:43:09.554Z","comments":true,"path":"posts/df4b5a39.html","link":"","permalink":"https://blog.zucchiniy.com/posts/df4b5a39.html","excerpt":"","text":"使用场景拆分项目，当项目越来越大之后，我们希望 子模块 可以单独管理，并由 专门 的人去维护，这个时候只可以使用 git submodule 去完成。 常用命令12345git clone &lt;repository&gt; --recursive # 递归方式克隆整个项目git submodule add &lt;repository&gt; path # 添加子模块git submodule init # 初始化子模块git submodule update # 更新子模块git submodule foreach git pull # 拉取所有子模块 使用方式添加子模块git submodule add &lt;repository&gt; path 即可添加 克隆子模块git clone &lt;repository&gt; --recursive 直接递归克隆，如果是克隆父项目，可以在克隆完成之后，使用 git submodule init 初始化子项目列表和 git submodule update 更新最新的子项目。 更新子模块如果子模块和新的修改，但是父项目没有更新到最新，则可以使用 git submodule foreach git pull 将所有的子项目中更新，如果子项目比 .gitmodules 新，则需要更新一下 .gitmodules 。 父项目中的子模块的版本是由 commit id 标识的，所以需要更新 .gitmodules 。 删除子模块首先需要 git rm --cached &lt;path&gt; ，然后依次删除对应的目录、**.gitmodules** 文件中的记录、 .git/cofig 中的记录。再提交到远程服务器，就可以删除了。 注意： 在执行 git rm --cached &lt;path&gt; 的时候，最后不可以有 / 。 修改子模块配置信息与删除相同，需要同时修改 .gitmodules 和 .git/config 两个文件中的 URL 值，然后执行 git submodule sync 来同步，然后再提交到远程即可。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"submodule","slug":"submodule","permalink":"https://blog.zucchiniy.com/tags/submodule/"}]},{"title":"iframe 滚动条","slug":"fronts/iframce-scrolling-config","date":"2018-06-20T22:43:00.000Z","updated":"2021-07-02T15:43:09.543Z","comments":true,"path":"posts/1c5bba53.html","link":"","permalink":"https://blog.zucchiniy.com/posts/1c5bba53.html","excerpt":"","text":"滚动条重复在调用框架或者多级 iframe 的时候，经常会出现多个滚动条或者左右都有的情况，需要我们进行调整，现就设置方法记录如下。 去掉全部滚动条设置scrolling属性123scrolling: auto // 在需要的时候显示滚动条scrolling: yes // 始终显示滚动条scrolling: no //始终隐藏滚动条 设置 body1body &#123;overflow: hidden&#125; 可以去看滚动条，也可以用来去看某一个滚动条时的方案。 有选择的去掉滚动条12body &#123;overflow-x: auto; overflow-y: hidden;&#125; /* 去看右边的滚动条，保留下面的 */body &#123;overflow-x: hidden; overflow-y: auto;&#125; /* 去掉底下的滚动条，保留右边 */ 代码优先级如果 scrolling: auto 或者 scrolling:yes 会依据 body 的值显示或者隐藏；如果 scrolling:no 无论什么设置都不会再显示滚动条。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"前端技术/JavaScript","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"css","slug":"css","permalink":"https://blog.zucchiniy.com/tags/css/"},{"name":"滚动条","slug":"滚动条","permalink":"https://blog.zucchiniy.com/tags/%E6%BB%9A%E5%8A%A8%E6%9D%A1/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.zucchiniy.com/tags/JavaScript/"}]},{"title":"Ajax 关闭异步请求","slug":"fronts/ajax-asyn-option","date":"2018-06-19T23:21:00.000Z","updated":"2021-07-02T15:43:09.543Z","comments":true,"path":"posts/a97db946.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a97db946.html","excerpt":"","text":"在代码中，因为进行了后台的取值操作，导致有些内容还未加载就执行到了新的地方，所以想着 ajax 的异步关闭来解决。 async 设置为 false 的时候，变成同步操作，默认( true )为异步操作。 12345$.ajax(&#123;cache: false,async: false, // 太关键了，学习了，同步和异步的参数&#125;);alert(&quot;2&quot;);","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"ajax","slug":"前端技术/ajax","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/ajax/"}],"tags":[{"name":"async","slug":"async","permalink":"https://blog.zucchiniy.com/tags/async/"},{"name":"异步请求","slug":"异步请求","permalink":"https://blog.zucchiniy.com/tags/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"}]},{"title":"JavaScript 包含某个字符串","slug":"fronts/javascript-contain-string","date":"2018-06-14T23:05:00.000Z","updated":"2021-07-02T15:43:09.544Z","comments":true,"path":"posts/a64e3e79.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a64e3e79.html","excerpt":"","text":"String 对象方法 indexOf() :::javascript var str = &quot;123&quot;; console.log(str.indexOf(&quot;3&quot;) != -1); // true console.log(str.search(&quot;3&quot;) != -1); // true console.log(str.match(reg));// true 方法返回指定字符串首次出现的位置，如果未找到，则返回 -1 。 方法用来检索字符串中指定的子串，或检索与正则表达式相配置的字符串，如果未找到配置，则返回 -1 。 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 RegExp 对象方法创建正则对象new RegExp(pattern, attributes); pattern 是一个字符串，指定了正则表达式的模式，或者其它正则。 attributes 是一个可选的字符串，包含 g 、 i 、 m 。分别是全局匹配，区分大小写和多行匹配。 正则匹配相关内容见Post not found: 工具环境/linux/wildcard-and-regex。 使用正则方法查找 test() :::javascript var str = &quot;1123&quot;; var reg = RegExp(/3/); console.log(reg.test(str)); // true console.log(reg.exec(str)); // null 数组 test() 方法用于检索字符串指定的值。返回 true 或者 false 。 exec() 用于检索字符串中正则匹配，返回一个数组，其中存放匹配的结果，如果未找到，则返回 null 。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"前端技术/JavaScript","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"substring","slug":"substring","permalink":"https://blog.zucchiniy.com/tags/substring/"},{"name":"indexOf","slug":"indexOf","permalink":"https://blog.zucchiniy.com/tags/indexOf/"},{"name":"RegExp","slug":"RegExp","permalink":"https://blog.zucchiniy.com/tags/RegExp/"}]},{"title":"grep 命令","slug":"tools/linux/grep-on-linux","date":"2018-05-30T23:28:00.000Z","updated":"2021-07-02T15:43:09.556Z","comments":true,"path":"posts/a85b713d.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a85b713d.html","excerpt":"","text":"简介grep 是一个强大的文本搜索工具，支持正则表达式搜索文本并把匹配的行打印出来。 常规用法1grep [-acinv] [--color=auto] &#x27;string to search&#x27; filename -a : 将二进制文件以 text 文件的方式搜索数据 -c : 计算找到的字符串的次数 -i : 忽略大小写的不同 -n : 输出行号 -v : 反向选择，即输出没有 「字符串」 的内容 --color=auto : 将找到的关键词部分加上颜色 示例1234567891011# 搜索 rootgrep root temp.txtcat temp.txt | grep root # 搜索 root 同时显示 这些行的行号grep -n root temp.txt# 搜索没有 root 的行grep -v root temp.txt # 搜索没有 root 和 nologin 的行 grep -v root temp.txt | grep -v nologin# 搜索 root 并显示出行号和前两行与后三行 grep -n -A3 -B2 --color=auto &#x27;root&#x27; 递归查找目录123grep &#x27;title&#x27; # 在当前目录搜索grep -r &#x27;title&#x27; # 在当前目录及其子目录搜索grep -r -l &#x27;title&#x27; # 在当前目录及其子目录下搜索但不输入匹配的行，只显示文件 grep 与正则表达式grep -n &#39;t[ea]st&#39; temp.txt&#39; : 匹配 test 和 tast 两个单词的行。grep -n &#39;[^g]oo&#39; temp.txt : 匹配含有 oo 的行，便是不能是 goo 内容。 更多内容见 通配符与正则 。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"grep","slug":"grep","permalink":"https://blog.zucchiniy.com/tags/grep/"}]},{"title":"形意拳的学与练","slug":"journal/mimicry-training","date":"2018-05-27T22:30:00.000Z","updated":"2021-07-02T15:43:09.547Z","comments":true,"path":"posts/2498c534.html","link":"","permalink":"https://blog.zucchiniy.com/posts/2498c534.html","excerpt":"","text":"劈拳手的一探一回，犹如人的一呼一吸。 炮拳以下扎的拳形来上挑。打炮拳时，后手不直线出击，而斜着撇出去。 横拳的练法，是斜着进一小步，横着退一大步，横拳等于是倒着打的。 钻拳是进一大步退一小步，横拳是进一小步退一大步。钻拳犹如螃蟹，是横着走的，左向一掌跟一拳，右向一掌跟一拳。 横拳是无形的，而有形的横拳就是蛇行，一横身子。就有了兜、裹、丢、顶。 站桩站桩的要点是 “学虫子”，冬天虫子钻进地里死了一般，等到春季，土里物理机一起，虫子就又活了。站桩就是站得这份物理机，如虫子复苏般的萌动，身上就有了精力。站桩有无穷益处，这就是练功。 其它打拳也是练功。形意拳要 『练精化气，练气化神，练神还虚』 。气不是呼吸的气，是所谓的生机勃勃。至于呼吸的气，叫作“息”，劈拳就是练息。 腿功是站桩站出来的，也是走出来的，唐维禄的徒弟尤其要走。早晨起来一走便是十里，两手背后，活动着脊椎，或带着点拳意。 站桩与打拳最关键的要点是一个，对这个要点没体会，练拳不出功夫，站桩也照样不出功夫。这就是 『桩法能融入拳法中，拳法能融入桩法中』 的道理。 练武其实是在练心智。 唐师所传的桩功，有一个要点，时常浑身抖一抖。 传说狗熊冬眠的时候，每隔几天，它就自发的浑身颤抖，否则僵滞不动，身体要有问题。同样，站桩为什么站不下去？就是缺这一rufh.tve细致很轻微的抖抖，就能够享受桩功，养生了。另外，其实比武发力。也就是这么一抖擞。 薛颠传的桩功，一个练法是，小肚子像打太极拳一般，很沉着地鼓出，再很慢很沉着地缩回，带动全身，配合上呼吸，不是意守丹田，而是气息在丹田中来去。 桩法是活动的，不是静功而是慢练。薛颠原话为 “此桩法之慢练，增力之妙法也，慢慢以神意运动，舒展四肢” ——桩法是动的，只不过动得极慢，外人看不出来。 站桩时，也要动起 步趟进、侧身而闪 的心思，外表看似不动，其实里面换着身形。要静之又静，长呼长吸尽，站空了自己。 浑圆桩足以眼神站桩，两眼要往上高瞟。练武先练眼，跟能生神，所以是练武先练神。人爬上山顶，累得疲惫不堪，但目光一远眺，身上就轻松一浑圆桩是这个原理。 所谓 “心有灵犀一点通” ，眼神就是这个灵犀。久站磨炼筋骨，但只坚实了筋骨。等于没有站桩。眼神和肉体的关系，是浑圆桩要体味的东西。有了灵犀，才能有生机，冬天过去大地回春，生机一起，土里都是香的，抓把土，粒粒都是活的，站桩也要把自己站活了。 站浑圆桩时，身子让眼睛领走了，身子不能做作。 摆拳架看似不动，其实筋骨肌肉都牵挂着，扑出去一厘米。犹如山谷有回声，身体也有回力，扑出去一厘米。再回来一厘米，要用回力来锻炼，如此易出刚劲。 站桩之苦首先是筋骨软弱的疲劳之苦，学会了这个方法，站二十分钟桩，等于打二十分钟拳，也就喜欢站桩了。 五行拳开始练劈拳，要找个开阔地带，犹如人登上高山，视野一开，会禁不住地长呼一口气。在开阔地带，气息容易放开。 劈拳的姿势是手的一探一回，犹如人的一呼一吸。 一趟四五百米地打下去，气息越来越绵长，越来越深远，精力便充沛了。 手部动作激发了全身，渐渐就会感到气息鼓荡，全身毛孔开合。薛颠说过：“练拳的人要学会体呼吸。”呼吸的妙处在打劈拳时可以体会到。 气息充沛，这是习武的基础，形意拳先练劈拳。 劈拳中本就含有钻拳的姿势，练好劈拳接着练钻拳较容易。正是“金生水”，劈拳属金，钻拳属水。而再学一个全新的拳架，如崩拳就比较困难。 劈拳养肺，人的两条胳膊对肺直接作用，是通过运动两条胳膊，来达到锻炼呼吸，强健肺部的效果。 而人的两条腿属于肾。钻拳以打法来说，是要练肘或指节的，但以练法来说，是要练腿，以活腿来养肾。 所以钻拳的步伐 不是直来直去，而是螺旋前进 。让两条腿有一个松快的余地，这样肺气足，肾水旺，上下身都修好，方可以向上进修。所以 要钻拳接着劈拳练。 在练劈拳的阶段，都会遇到这样的情况，觉得 *身上皮肤增厚，像大象皮似的，而日，觉得手指粗得像胡萝卜，两个手心像有两个小漩涡，十根手指自发地紧紧握起，不愿意打开… 这都是错觉。是因为身上的气充足了，情绪也变得活跃了，忙了这个忙那个，如小孩一样，干什么都兴致盎然。* 这是一个必经的阶段，发现自己变成这样了，就说明功夫已上路了。 此时就不必再到开阔地去练拳了。形意拳自古讲究“拳打卧牛之地”，有个能挪步的地方就练上了，到开阔地打拳只是入门的方便之法。 因为劈拳练息，这个功夫得一年才能成就，先祛病再强身。通过练息，身上的气养育起来，大脑时常会有灵感，此时学拳就真是趣味无穷了。 炮拳出手后，要向后一耸，就是上挑的枪法，所以炮拳里有两个家伙，明显的足下扎枪，隐藏的是上挑枪，一个在形上，一个在劲上，以下扎的拳形来上挑，所以才妙。炮拳要到杆子上去体会——这是以后的事情，那时候，便要扎一枪有一枪的讲究了。 横拳的练法，是斜着进一小步，横着退一大步，横拳等于是倒着打的，正好练这“踏荷叶”，脚伸在地上，要感到踏在荷叶杆上，只有一根丝能支持，要用脚的肉感，把这根丝探测出来。 练形意要养成“上虚下实”的习惯，上身永远松快不着力，功力蕴藏在下身。 劈、崩、炮的基本型都如此，而钻、横的基本型就把这个“重收”耍在动作上了，钻拳是进一大步退一小步，横拳是进一小步退一大步。 而在变化中，劈、崩、炮都有退步法。最有名的是崩拳的“退步崩”了。 炮拳前手横架在眉前，后手由面门径直打出去，攻击敌人面门，取开炮的意象，称前手为炮架，后手为炮弹，后手的出拳路线是直的，而且要有股爆炸力(开始练时可先从弹力人手)。 打炮拳时，后手不直线出击，而斜着撇出去，正是“遇敌好似火烧身”，就像往火堆里滴一滴油，不是一般地火苗跳起。 而是整簇大火都跳起，炮拳就是令全身劲力跳起，劲力不在最外的手上，而在内里的根节，手随着根节升腾起的劲力挥出。 五行拳不是练拳，而在练五种不同的劲，所以每一种拳的转身姿势都不同。转身姿势是为劲而设立的，多练转身，对领悟劲有帮助。 “崩”字怎么解释，就是一崩劲吗?其实崩拳的妙处在于张弛。 五行拳是拳母，一辈子离不开，上手就受益。将五行拳的小动都学到，方能出形意的功夫。十二形就是从五行拳罩变化出来的，而练象形术的人能变回五行拳，一练起来，就知道两者是一个脉。 形意的拳母是五行拳，而五行的拳母是横拳，横拳属土，万物归于土，土含育万物，生发着劈、崩、钻、炮，所以横拳是无形的，横拳劲是形意拳最独特的东西。 横拳是无形的，而有形的横拳就是蛇行，一横身子。就有了兜、裹、丢、顶。我年轻时与人试手(试手就是试试，较量是拼命)，一下子把人打出去了。自己却奇怪上了，这是个什么动作?回味一下觉得像是蛇行，连带着横拳也明白了。 把直来直去的拳打转了。把转着的圈打直了，这是崩拳的练法。 “崩拳有儿、钻拳有六”，钻拳的六个变招中，学会了两个就全有了。一个是前手压住对方，扯带得后手撵锥子似的撵进去。另一个是，前手一晃，你就撞在他后手上了，变魔术一般，不是障眼法，而是他换了身型。 两者的前后虚实不同。整体说来，钻拳不是钻拳，是钻身。旧时代的北京很冷，冬天商店挂着沉甸甸的棉帘子，人进商店，前手一撩门帘，身子就往里钻，身子一动，手上搭的分量卸了，人进了门，帘子也刚好落下，有道缝就进了人。这是生活里转换虚实的现象，形意拳的“换影”也是这个意思。 拳劲起自腰劲，只有头虚领了，腰里才生力，站桩首先是为了生腰力。脊椎敏感时，要让站桩法动起来，可以尝试一下薛颠的蛇形。 蛇形是肩打，“后手只在胯下藏”，后手绕在后臀胯下，贴着尾椎骨向上一提。犹如马尾巴乍起来，才能跑狂了，撑上这个劲，尾椎乍了，肩膀才能打人，这是桩法融入拳法。 从薛颠的角度讲。 劈拳起手势、半步崩拳都是猴蹲身， 这样十二形就如五行拳一样，其实这是五行拳该有的东西。 指望摆出劈、崩、钻、炮、横的架子赢人，是指望不上的。不能蛮干，否则一下子就被人借了劲。为人处事也要这样，练了功就要藏着，藏不住就会得罪人，一得罪就是一大片，藏还得深藏。关键时候露一手就行了，形意拳是留给写实用功、心地纯正的君子的。 二十形蛇形是肩打，鸡形是头打，燕形是足打 ，不是李存义传的，是他从山西学来的。其中的蛇形歌诀是“后手只在胯下藏”，后手要兜到臀后胯下，开始时，只有这样才能练出肩打的劲。 武林里讲 薛颠“能把自己练没了”，指的是他的猴形。他身法快、比武时照面一晃，就看不住他了，眼里有他，但确定不了他的角度。 “龙形搜骨”不是龙形，就是 劈拳里前脚外撇的大跨步 ，说这个步子开天辟地。打通三盘，调理百骸，是成就身子的关键。有了步子有功夫，没步子没功夫。这个步子就是内功。 只撇脚不展腿，撇脚的打法，是别住敌人的脚，但也是在擒拿时较从容的情况下使用，情况紧急一拳见生死时，就用不上了。撇前脚的大跨步，主要是练法。 前脚外撇的大跨步是形意的大步子，还有个小步子，就是崩拳步。崩拳步很微妙，步子只是向前，两膝盖是挤着的。但腿根里夹着活的动势，稍稍一调，就能随时随意地转向、转劲。所以崩拳微妙。 对于蛇形。薛颠说：“一动手，就是这事，没旁的事。” 说形意拳难看也主要是有这个猴蹲身，练拳时，处处都有只猴子蹲着，可想这一式的重要。猴蹲身之后，有张狂的招数。蹲身先练了膝盖，所以猴蹲身一变，就是扬身膝击，名猴挂印。 这一蹲一扬，正如劈拳的一起一伏，也如崩拳的一紧一弛，只不过是猴形放肆，劈崩含蓄。 猴挂印的下一变是猴摘桃，就是抓敌人脸，泼妇打架一般，这是为膝击做掩护。不抬腿是立于不败之地。抬了腿是兵行险道，得有收场、后撤的伎俩。这连抓带点，练着滑稽、打起来狼狈，但这一番乱七八糟，兴许就乱中取了胜。比武时要懂得挑事端，找头绪，无理取闹一下，也许就乱了对方的方寸。 炮拳两手有前后，马形足两只手的炮拳，两手齐出，好像呆板，但只要转起来，呆板的也就变化无穷了。 *这个左右翻身的打法，不是翻胳膊，而是要把整个身子的重量从这边翻到那边，所以马形对整劲有好处，马形有践踏之意，动了手就不停，这个打法能先发制人。* 动手想快，光抡胳膊不行，脚下得踏上劲，手上才能快。所以马形抡胳膊却练了脚。 马形成就了，脚下有弹力，随时可撩起伤人，冲着对方的胫骨、脚踝，撩上就踏，脚离地的时间越少越好。马形的腿击法，不是明目张胆，而是在抡胳膊的时候藏着。其中的巧妙，希望初学者，用“打一厘米”的方法好好揣摩，这是个容易使上的防身之技。 鸡单足立地时是抓着爪子缩脚，所以要含着抓意提膝，有了抓意，膝盖下就能生出一踹。此踹很低，脚背外斜翘起，所以名为鸡翘脚。鸡形的腿击是从膝盖生出来的，不是直接使脚，所以能够“有机会就甩一脚，没机会就藏着。” 象形术猿象的返身动作比钻拳大，因为 钻拳把由下往上的钻势压缩到一直线里了， 而猿象把这个上下钻势张扬了，蹲身时一回头就转了向，这一转比钻拳带的动静大。转了向就钻，犹如猴子一下蹿上树，人虽然没跳起来，劲要蹿起来。 象形术猿象的手指头向着人脸，形意拳猴形的猴挂印也要预备着——这个比武要点，我看书上提一句，在此特别强调，这两招是一招，少了谁都有危险，猴挂印，膝盖是一大块骨头，等于一方大印，要把这大印的分量挂到敌人胸膛里去，最佳的落点是敌人两胸尖的腹中穴。 这是个狠招。但不会返身换影，一抬膝盖便会挨打。 交手法形意拳的肩打、胯打、臀打就是一蹭， 而不是像出拳似的打出去，摆胯、凸肩、甩屁股是很难看的，这种近身打法是要蜻蜓点水一般，一闪一闪的。 世上永远是强者影响弱者，交战步法的原理也如此。你的步法强，能影响别人，别人不自觉地一学你，就败了。 对于交手的大原则，唐维禄总结为： 『身子挂在手上，眼睛盯着根节，冷静。』手上要挂着身体一二百斤的分量，拳谱有“追风赶月不放松”的话，追上敌人容易，身子能追上自己的手，就难了；肩膀为根节，敌人要有作为，肩膀必有征兆，练武人练出眼力容易，养成明察秋毫的习惯，就难了；而最难的是冷静，练功夫练得开了智。方能冷静。 腿击法是身法的发挥。所以练腿先练身。 比武就是比谁先知道。形意拳的后发制人，不是等对方动手了我再动手，而是对方的征兆一起，我就动了手。不是爱什么招就使什么招，要应着对方，适合什么用什么，平时动心思多练，有出手就足合适的。只有练拳时方方面面的心思都动到，在比武电闪雷鸣的一瞬，才能变出东西来。 跟高手比武，精神一亢奋就觉得有种东西兴旺起来，这就是力到丹田。说不清楚，只能体会，站桩就兴旺这个东西。 形意拳专有打法，那是另一种分寸。薛颠的打法，在“占先于”方面有独到之处。示范时，做徒弟的防不住他，他的手到徒弟身上，就变打为摔了，把人摔出去，又一下捞起来，在他的手里不会受伤。做徒弟的被他吓几次，反应能力都有所提高。 只有崩拳和蛇行，是我多年练武、比武自然形成的。我的崩拳、蛇行都只是看似崩拳、蛇行的东西，究竟是什么东西我也不知道，顺手就行了。 形意拳是一动就有步数，身形得换在点上。看着你的动静，变得越快越好，越小越好，犹如好朋友见而一下就搭上了肩膀，得一下就近了，敌身。 至于薛颠的马形，叫“马形炮”，手势与炮拳相似，犹如马立着前腿蹬人，也是在脚上有劲撑着。马形藏着腿击，绊子，跟着手变。形意拳是主要攻中路的拳。崩拳要坐腰，一坐腰，人就低蹿出去，正好打在敌人的胸膛、小腹。 站桩时也要揣摩提腰坐腰。微微活动着。这是拳法融在桩法中。 能硬打硬进，也不硬打硬进，一对一，可以硬碰硬，但一个对七八个时，怎么办?练武修出的劲道跟人硬拼了，那么练武修出的灵性干什么呢? 内劲是虎、身法是龙，功力足还要智慧深。 只能力胜，是俗于，能智取人，方是高人。 练法的大纲是“二十四法”，打法的大纲是“八打”，师傅们讲拳都是结合着个人体验，在这两首歌诀上发挥。“头打落意随足走，起而未起占中央” ——鸡形是头打，鸡啄米就是擒住敌人两手时，用头下“啄”鼻软骨，上顶下巴，“啄”鼻软骨能让敌人血流满面，而项下巴，能一下把敌人顶晕过去。 鸡形头打就是练头，头为一身之枢纽，头部僵硬、脚下再能变步数，转换身形时也仍然快不了。鸡总是一探头一探头地走，以头领身，鸡形就足用这个方法练身子。 形意拳在发力时，只在碰到对手身上的瞬间，手才握紧。同样的道理，只在打倒敌人的一瞬间，才露真形——这是五形拳的用法，只用一点，一点即可。大部分时间存而不用，神经上有储备就行了。《西游记》里的妖精，关键时候才显原形。“真身只在刹那”。 八卦掌尚云祥说八卦就是教人“送”，八卦像推磨，凡推过磨的人都知道，要将谷物磨得细腻。直愣愣地推肯定不行， 手上的那般劲得把磨杆“送”出去，送得“平、圆、悠、远”，还要送出一般向下的辗劲，这股另有的劲叫做“留”。 八卦掌便是有送有留，这不是靠站桩就能站出来的，所以八卦门人不站桩，都是在运动中求“送”、“留”。 八卦如推磨，除向前推，还要推出向下的辗劲， 八卦掌一迈步要有两股劲，随时转化。 明白了这两股劲的道理，就能理解八卦掌的招数为何千变万化。 程延华打八卦，劲力浑身鼓荡，感觉不到他在打，只感到他在动。大蟒蛇从头到尾都蹭着劲，才能爬动得起来，这种威势，又怎是打一拳、踹一脚所能比的? “只动不打”是程派八卦的练功口诀，“硬退硬进天遮拦”是形意的古歌诀，尚云祥还有“练拳要学瞎子走路”的窍门，说瞎子走路身子前后都提着小心，从头到脚都有反应，练拳不是练拳头。而是全身敏感。 八卦掌走偏门，一下就抢到人侧面，与练八卦掌的人交手，你就能体会到 崩拳的转身动作——狸猫上树的巧妙，狸猫上树可迎敌人攻侧面。 形意拳打法的要诀也是攻敌侧面，等于两个人打一个人。正面迎敌就吃力了。唐师腿法妙，不单善走，还能迅速抢到敌人侧面。 形意门中的偏门攻防，返身打法是李存义发扬的，从李存义开始，形意的钻拳中就融入了八卦的东西，借着八卦的动作往身侧点。唐师，尚师传我的都是这个功架。 我的钻拳基本形不是从下往上钻，而是从中往侧点。 那个借来的八卦动作，借了就不还了，融在钻拳里起了变化，还有八卦“回身掌”的形态，向体外侧一滑步，前手向外撸去，还有塌劲。胳膊撑起来，手掌是横的。 然后， 后手随着点过去，手虽有前后，但两臂要有合力。犹如弓弩，两头绷上劲，才能射出东西，松了哪头都小灵。钻拳犹如螃蟹，是横着走的，左向一掌跟一拳，右向一掌跟一拳，就练上了返身。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"形意拳","slug":"形意拳","permalink":"https://blog.zucchiniy.com/tags/%E5%BD%A2%E6%84%8F%E6%8B%B3/"}],"author":"zucchini"},{"title":".gitignore 文件配置","slug":"tools/git/git-ignore","date":"2018-05-27T19:18:00.000Z","updated":"2021-07-02T15:43:09.553Z","comments":true,"path":"posts/676ce982.html","link":"","permalink":"https://blog.zucchiniy.com/posts/676ce982.html","excerpt":"","text":"git 使用过程中，有许多文件或者文件夹是不希望更新到远程仓库了，因为他们比较占地方，这个时候我们可以利用 .gitignore 文件忽略文件。 按项目进行忽略.gitignore 文件用于忽略文件 所有空行或者以没注释符号 # 开头的行都会被 Git 忽略。 可以使用 glob 模式进行匹配。 匹配模式最后跟反斜杠 (/) 说明忽略的是目录。 要忽略指定模式以外的文件或者目录，可以在模式前加上惊叹号。 glob 模式* : 表示任意个任意字符 ? : 表示匹配一个任意字符 所以我们只需要在对应的 git 目录下，创建一个 .gitignore 文件，然后配置上 .DS_Store 即可。 12touch .gitignoreecho */.DS_Store&quot; &gt; .gitignore 然后保存，就可以生效了。 全局进行配置然后我们发现，只要是 Mac 下的 Git 项目我们都需要这样操作一次，太麻烦了，所以我们可以在 home 目录下创建一个 .gitignore_global 文件，然后按 .gitignore 文件的配置方式完成配置。 在每个项目下的 .gitignore 文件中，我们可以引用这个 global 文件。 1git config --global core.excludesfile ~/.gitignore_global 这样就可以将全局方法加载到项目配置文件中了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":".gitignore","slug":"gitignore","permalink":"https://blog.zucchiniy.com/tags/gitignore/"}]},{"title":"字符串按排序和时间戳","slug":"backends/mysql/sort-string-in-mysql","date":"2018-05-22T03:06:00.000Z","updated":"2021-07-02T15:43:09.540Z","comments":true,"path":"posts/85f1b411.html","link":"","permalink":"https://blog.zucchiniy.com/posts/85f1b411.html","excerpt":"","text":"排序自建了一个表，其中的字段为 char 或者 varchar 的类型。 我们如果直接进行的排序的话，得到的序列是字符顺序的，即 1,10,2,20,…，但是我们希望得到的是 1,2,3,4,… 这种序列，有两种方法可以实现排序。 手动转换 1select id from db.sql order by id + 0 desc 但是这种方式显得有点丑，其实 Mysql 提供了一个非常好用的函数进行操作。 使用函数 CAST() 函数和 CONVERT() 可以使用。 1select id from db.sql order by CAST(id as SIGNED) desc 1select id from db.sql order by CONVERT(id, SIGNED) desc 时间戳 创建新记录和修改现有记录都更新方式 1TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 创建的时候设置时间，后续的修改不再更新 1TIMESTAMP DEFAULT CURRENT_TIMESTAMP 创建的时候把字段设置为 0 ，以后修改才更新 1TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 创建时设置为给定值，以后更新会刷新这个时间 1TIMESTAMP DEFAULT &#x27;yyyy-mm-dd hh:mm:ss&#x27; ON UPDATE CURRENT_TIMESTAMP","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"CAST","slug":"CAST","permalink":"https://blog.zucchiniy.com/tags/CAST/"},{"name":"CONVERT","slug":"CONVERT","permalink":"https://blog.zucchiniy.com/tags/CONVERT/"},{"name":"timestamp","slug":"timestamp","permalink":"https://blog.zucchiniy.com/tags/timestamp/"}]},{"title":"通配符与正则","slug":"tools/linux/wildcard-and-regex","date":"2018-05-19T23:27:00.000Z","updated":"2021-07-02T15:43:09.557Z","comments":true,"path":"posts/a3183791.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a3183791.html","excerpt":"","text":"简述通配符和正则表达式很容易混淆，首先二者所应用的对象是不同的，通配符主要是用在 Shell 命令中，比如 find 、 ls 、 cp 等，而正则是使用在文本过滤工具（可以是字符串搜索和替换等），例如 awk ， sed 等。 通配符[a-z] […] : 匹配方括号中指定范围内的单个字符或方括号列出的其中一个字符[!9] [!..] : 不匹配方括号中的字符或指定范围内的单个字符* : 匹配 0 个字符或多个字符? : 匹配任何单个字符，且不能为空的字符 因为 Shell 会将方括号( [ 、 ] )、问号( ? )、星号( * )等内容特殊处理，因此想匹配这几个字符时，需要加转义符 \\ 。 通配符号 内容 * 万用字符，代表0个或者多个字符（包括数字） ? 万用字符，代表一定有一个字符 # 注解字符，常用在说明或者备注中 \\ 转义字符，将特殊字符还原为一般字符 &vert; 分隔字符，分隔两个管道命令 ; 连续命令界定符，用来分隔 ~ 登录用户的 home 路径 $ 变量声明字符，用来表示变量 &amp; 后台执行命令 ! 逻辑运算符非 &gt; &gt;&gt; 输出导入符，一个为取代，两个为累加 ‘ 单引号，不具有变量转换功能 “ 具有变量转换功能 `` 中间为可以先执行的指令 () 中间为子 shell 起始与结束 [] 中间为字符组合 {} 中间为命令区块的组合 正则表达式字符匹配. : 匹配任意单个字符* : 匹配其前面一个字符出现任意次? : 匹配其前面的字符1次或者0次+ : 匹配其前面的字符至少出现1次（扩展正则表达式中） 位置匹配^ : 行首$ : 行尾\\&lt; 或 \\b : 词首，其后面的任意字符必须作为单词首部出现\\&gt; 或 \\b : 词尾，其前面的任意字符必须作为单词尾部出现\\B : 非单词开头或结尾^$ : 空白行 分组(ab)* : 匹配 ab 这个分组出现任意次\\1 : 引用第一个左括号以及与之对应的右括号所包括的内容\\n : 同 \\1 特殊[:alnum:] : 任何字母和数字[:alpha:] : 任何字母[:cntrl:] : 控制字符，包括 ASCII 表中的 000 - 037 再加上 177(‘DEL’)[:digit:] : 任何数字[:punct:] : 标点符号，&#39;!&quot;#$%&amp;()*-+,./:;&lt;=&gt;?@[]\\\\^_&#123;|&#125;~[:graph:] : 打印字符，等价于 [:alnum:] + [:punct:][:lower:] : 小字字母[:upper:] : 大写字母[:print:] : 可打印字符，等价于 [:alnum:] + [punct:] + [:space:][:space:] : 空白字符，包括 tab/newline/vertical tab/form feed/carriage return/space[:xdigit:] : 任何16进制数字，相当于 [0-9a-fA-F] ^[[:space:]]*$ : 匹配没有任何内容的行 [] : 中的特殊字符( . , ***** )会失去特殊含义 正则 意义 ^word 搜索在行首的字符串 word$ 搜索在行尾的字符串 . 任意一个字符 \\ 转义字符 * 重复0个或者多个前一字符情况 {n,m} 连续 n 到 m 个的前一个字符，若为 {n} 则是连续的 n 个前一个字符，若是 {n,} 则是连续 n 个以上的前一个字符 [list] 表示字符列表集合 [ch1-ch2] 表示字符顺序列表 [^] 表示不包含字符 使用正则进行匹配的示例grep -n &#39;^#&#39; temp.txt:搜索到行首为 # 的那一行grep -n &#39;!$&#39; temp.txt:搜索行尾为 ! 的那一行grep -n &#39;e.e&#39; temp.txt:搜索字符串可以是 eve ，eae ，e e ，但是不会是 eegrep -n &#39;&#39;&#39; temp.txt:搜索含有 ‘ 的那一行grep -n &#39;ess*&#39; temp.txt:找出有 es ， ess ， esss 的一行，因为 * 是大于等0个，所以可以匹配 esgrep -n &#39;go&#123;2,3&#125;g&#39; temp.txt:在 g 和 g 之间有 2 到 3 个 o 存在，即 goog ， goooggrep -n &#39;g[ld]&#39; temp.txt:搜索含有 gl 和 gd 的那一个，注意，这里只代表一个，如 [lad]f ，只有 glf ， gaf 和 gdf 可以被搜索到，如果是 glaf 这种则是不能被找到的grep -n &#39;[0-9]&#39; temp.txt:搜索含有任意数字的一行，注意，在 [] 中的 - 是有特殊含义的，同时也可以使用 grep -n [:digit:] temp.txt来代替。而 - 中的顺序是由 ASCII 来设定的grep -n &#39;oo[^t]&#39; temp.txt:搜索不为 oot 的那一行","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"正则表达式","slug":"工具环境/正则表达式","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://blog.zucchiniy.com/tags/regex/"},{"name":"wildcard","slug":"wildcard","permalink":"https://blog.zucchiniy.com/tags/wildcard/"}]},{"title":"拼接查询结果中的字符串","slug":"backends/mysql/mysql-concat-string","date":"2018-05-15T02:59:00.000Z","updated":"2021-07-02T15:43:09.539Z","comments":true,"path":"posts/e958b1c9.html","link":"","permalink":"https://blog.zucchiniy.com/posts/e958b1c9.html","excerpt":"","text":"CONCAT 将多个结果作为字符串拼接在一起 1concat(str1,str2,...) 实例： 1select concat(o.user_name,o.user_number) from user o where user_id = &#x27;1&#x27; 但是如果查询过程中有一个字符串为 null 则整个结果都将是 null ，这时可以将 null 转换为 ‘’ 1select concat(IFNULL(o.user_name,&#x27;&#x27;),o.user_number) from user o where user_id = &#x27;1&#x27; 如果想将结果分隔，则可以使用下面的方法 1select concat(o.user_name,&#x27;,&#x27;,o.user_number) from user o where user_id = &#x27;1&#x27; 但是这种方式显得过于难用，如果字段多了，要写很多将分隔符，这时可以用 concat_ws 进行拼接。 CONCAT_WS 将多个结果拼接在一起，使用指定的分隔符 1concat_ws(separator,str1,str2,...) 实例： 1select concat_ws(&#x27;;&#x27;,o.user_name,o.user_number) from user o where user_id = &#x27;1&#x27; 这种情况下，结果中有 null 的话，也不会返回 null ，但是如果将分隔符指定为 null 则结果会全变成 null GROUP_CONCAT 将多行的字符串分组整合成一个字符串，必须配合 group 使用 1group_concat([distinct] str1 [order by asc/desc] [separator]) distinct 可以排除重复值order by 可以按升序 ( asc ) 或者降序 ( desc ) 进行排序separator 是分隔符，默认为 ‘,’ 实例： 1234567select o.class_id, group_concat(o.student_name)from student ogroup by o.class_id 上面这个 sql 是将学生按班级进行分组，然后将学生的姓名拼装到一起 更复杂一些的例子，可以将学生的名字、学生的学科和分数进行分组查询并拼接结果 123456select o.name, group_concat(concat_ws(&#x27;-&#x27;, o.subject,o.score) order by o.id asc) from student ogroup by o.name; UNIONUNION 操作符用于连接两个以上的 SELECT 语句的结果到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法格式： 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; 参数： expression1,expression2,…expression_n: 要查询的列名 tables: 要查询的表名 WHERE conditions: 可选，查询条件 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 会删除重复数据，所以对结果无影响 ALL: 可选，返回所有结果集，包含重复数据","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"concat","slug":"concat","permalink":"https://blog.zucchiniy.com/tags/concat/"},{"name":"concat_ws","slug":"concat-ws","permalink":"https://blog.zucchiniy.com/tags/concat-ws/"},{"name":"group_concat","slug":"group-concat","permalink":"https://blog.zucchiniy.com/tags/group-concat/"},{"name":"union","slug":"union","permalink":"https://blog.zucchiniy.com/tags/union/"}]},{"title":"zsh shell","slug":"tools/linux/zsh-shell-basic","date":"2018-04-28T17:25:00.000Z","updated":"2021-07-02T15:43:09.557Z","comments":true,"path":"posts/9d1e89c2.html","link":"","permalink":"https://blog.zucchiniy.com/posts/9d1e89c2.html","excerpt":"","text":"zsh 是一个非常好用的 shell ，也是 bash 的替代品中比较优秀的一个。 启用如果未安装，则可以使用对应的命令行进行安装。 brew install zsh 或者 pacman -S zsh 等方法，然后使用选择器，将默认的 shell 设置为 zsh 。 1chsh -s `which zsh` iTerm2如果是在 Mac 上，可以和 iTerm2 一起使用。 补全zsh 的命令补全功能非常强大，可以补齐路径、命令、参数等。 然后利用 tab 键可以在选项中选择，如果过多，可以使用 ctrl+b / ctrl+p / ctrl+f / ctrl+n 来进行左上右下的选择。 还有另外一种用法，对于查询到的进程，可以直接转换为 PID 进行处理。 跳转省略 cdzsh 中跳转的时候，可以省略掉 cd 这个命令，直接输入 .. 等同于 cd .. 这个命令。 session 跳转在 zsh 中，记录了你最近访问过的地址，可以使用 d 命令进行打开，然后按前面序号进行跳转。 osxcdf : 在 Finder 中打开要 cd 的目录 quick-look : 快速预览文件，类似在 Finder 中按下空格 man preview : 在 preview 中打开 man page itunes : 在命令行中操作 Itunes","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"https://blog.zucchiniy.com/tags/zsh/"}]},{"title":"SpringBoot 常用配置","slug":"backends/java/springboot-config-tips","date":"2018-04-27T23:14:00.000Z","updated":"2021-07-02T15:43:09.538Z","comments":true,"path":"posts/d3f4d776.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d3f4d776.html","excerpt":"","text":"MyBatis 模糊查询mysql1SELECT * FROM DB.SQL WHERE MYNAME LIKE CONCAT(&#x27;%&#x27; , #&#123;myName&#125; , &#x27;%&#x27;) 或者使用 ${} 来进行查询 1SELECT * FROM DB.SQL WHERE MYNAME LIKE CONCAT(&#x27;%&#x27; , &#x27;$&#123;myName&#125;&#x27; , &#x27;%&#x27;) Oracle1SELECT * FROM DB.SQL WHERE MYNAME LIKE &#x27;%&#x27;||#&#123;myName&#125;||&#x27;%&#x27; 拆分 SpringBoot 的基础 lib 包最近发现使用 Springboot 项目上传到服务器越来越慢，所以决定将项目拆分一下，将需要的 lib 包拆分开来。 首先需要按原来的内容进行打包，然后就打好的包解压，然后将 BOOT-INF 下的内容，上传到服务器，然后将 pom.xml 文件中的 org.springframework.boot 增加 configuration 的配置，增加之后如下： 12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;include&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt;&lt;/plugin&gt; 然后再重新打包，生成的内容就只有自己编写的内容了。 上传到服务器之后，先新建一个 shell 角本，然后增加执行权限： chmod x+a start.sh 然后将启动的脚本增加如果下内容： 1java -Dloader.path=./lib -jar ./xxx.jar 再启动的时候，更新了代码，打包再上传服务器，也就一分钟的事儿。 Springboot 日志级别 打印 Mybatis 中调用的 Sql 123logging: level: com.xxxx.mapper: DEBUG com.xxxx.mapper 是 Mybatis 接口的影射文件包 Logger 日志按级别打印 123logging: level: org.springframework.web: DEBUG 其中，日志级别有： ERROR WARN INFO DEBUG TRACE root 的日志级别设置 123logging: level: root: DEBUG","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"后台技术/Java","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Java/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://blog.zucchiniy.com/tags/mysql/"},{"name":"oracle","slug":"oracle","permalink":"https://blog.zucchiniy.com/tags/oracle/"},{"name":"模糊查询","slug":"模糊查询","permalink":"https://blog.zucchiniy.com/tags/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/"},{"name":"logging level","slug":"logging-level","permalink":"https://blog.zucchiniy.com/tags/logging-level/"}],"author":"zucchini"},{"title":"Homebrew 入门","slug":"tools/mac/homebrew-commands","date":"2018-04-27T01:19:00.000Z","updated":"2021-07-02T15:43:09.558Z","comments":true,"path":"posts/711ab194.html","link":"","permalink":"https://blog.zucchiniy.com/posts/711ab194.html","excerpt":"","text":"homebrew 安装使用下面的命令进行安装，但是需要先安装 curl : 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 常用命令 搜索 1brew search mysql 查询 1brew info mysql 主要看具体的信息，比如目前的版本，依赖，安装后注意事项等 更新 1brew update 这会更新 Homebrew 自己，并且使得接下来的两个操作有意义 检查过时 1brew outdated 这回列出所有安装的软件里可以升级的那些 升级 1brew upgrade 升级所有可以升级的软件们 清理 1brew cleanup 清理不需要的版本极其安装包缓存 后台启用服务brew services 命令是用来管理 Mac 系统中后台服务的，比如在 Mac 上安装了 MySQL ，当我希望将这个变成一个后台服务启动的时候，可以使用，有点像 Linux 下的 service 和 systemctl 两个命令。 具体的使用命令也非常简单： 123456brew services list # 查看使用brew安装的服务列表brew services run formula|--all # 启动服务（仅启动不注册）brew services start formula|--all # 启动服务，并注册brew services stop formula|--all # 停止服务，并取消注册brew services restart formula|--all # 重启服务，并注册brew services cleanup # 清除已卸载应用的无用的配置 配置国内镜像使用了一段时间的 Homebrew 之后，发现网络波动有点大，好多时间都是更新10多分钟，所以就想到了国内镜像问题。 其实无论是什么内容，只要是需要更新的，就有两个优先选择的，一个是清华源，一个是科大源，这两个是最好用的镜像了。 对于我的使用，主要是两个，一个是 formula 索引，另一个是 bottles 。 Homebrew 的 bottles 文件迁移到了 GitHub Packages ，镜像地址需要修改，但是使用的 清华源 和 腾讯源 都没有做更新，所以更新的时候报错 404 了，查了一下发现 科大源 已经更新了，所以就将所有的配置迁移到 科大源 之上。 看了一下帮助文档，homebrew-cask-fonts 和 homebrew-cask-drivers 两个仓库在 科大源 中是没有的，所以还是使用 清华源 作为镜像。 formula 更新使用。 12345678910# brew 程序本身，Homebrew/Linuxbrew 相同git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.gitgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.gitgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.gitgit -C &quot;$(brew --repo homebrew/cask-fonts)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.gitgit -C &quot;$(brew --repo homebrew/cask-drivers)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git# 更换后测试工作是否正常brew update bottles 镜像则需要配置到环境变量中，我使用的是 zsh shell 所以配置到 .zprofile 文件中 12echo `export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/bottles` &gt;&gt; ~/.zprofile source ~/.zprofile 如果你想临时使用的话，则需要在终端中输入 export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles ，当然如果你使用的是 bash shell 则可以将其配置到 .bash_profile 文件中。 如果不再希望使用图内的镜像，也可以重置为 GitHub 镜像。 1234567891011# brew 程序本身，Homebrew/Linuxbrew 相同git -C &quot;$(brew --repo)&quot; remote set-url origin https://github.com/Homebrew/brew.git# 以下针对 mac OS 系统上的 Homebrewgit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.gitgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.gitgit -C &quot;$(brew --repo homebrew/cask-fonts)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask-fonts.gitgit -C &quot;$(brew --repo homebrew/cask-drivers)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask-drivers.git# 更换后测试工作是否正常brew update","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"工具环境/Mac","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Mac/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"https://blog.zucchiniy.com/tags/homebrew/"}]},{"title":"使用 Mac 电脑制作 U 盘","slug":"tools/mac/create-usb-card-by-dd-in-mac","date":"2018-04-24T18:47:00.000Z","updated":"2021-07-02T15:43:09.557Z","comments":true,"path":"posts/74995ec8.html","link":"","permalink":"https://blog.zucchiniy.com/posts/74995ec8.html","excerpt":"","text":"Mac 下写入命令 找出 U 盘挂载位置 1diskutil list 将 U 盘移除 1diskutil unmountDisk /dev/disk[num] 写入 U 盘 1sudo dd if=isopath of=/dev/disk[num] bs=1m rdisk rdisk 是指定方式后，可以加快写入速度。 iso 转换为 dmg1sudo hdiutil convert -format UDRW -o linux.dmg kali.iso 弹出 U 盘1diskutil eject /dev/disk[num]","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"工具环境/Mac","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Mac/"}],"tags":[{"name":"dd","slug":"dd","permalink":"https://blog.zucchiniy.com/tags/dd/"},{"name":"diskutil","slug":"diskutil","permalink":"https://blog.zucchiniy.com/tags/diskutil/"}]},{"title":"Git 补遗","slug":"tools/git/git-tips","date":"2018-04-20T03:22:00.000Z","updated":"2021-07-02T15:43:09.554Z","comments":true,"path":"posts/afae679a.html","link":"","permalink":"https://blog.zucchiniy.com/posts/afae679a.html","excerpt":"","text":"文件退出暂存区，但是保留修改在代码或者一些内容更新完成好，进行了 git add . 或者 git add -A 操作，但是发现操作错误了，不希望进行暂存区，但是又不想移除已经修改的内容，可以执行 git reset --mixed 操作，这样将文件退出暂存区，但是修改的内容保留。 多次修改，一次 commit在进行一个功能的开发过程中，希望将整个功能仅做一次 commit ，可以在修改完成后，执行 git add . ， 然后再执行 git commit --amend ，这样可以把修改的内容分次写入到 commit 文件中，最后再进行提交。 git 移除 cache 的内容 git 删除暂存区的文件，不会移除文件，即保留工作区。 12git rm --cache fileName#fileName 为对应的文件名 删除暂存区和工作区的文件 1git rm -f fileName git 删除错误的 commitcommitId 为对应的 id 仅仅撤销已经提交的版本库，不会个性暂存区和工作区 1git reset --soft commitId 撤销已提交的版本库和暂存区，不会修改工作区 1git reset --mixed commitId 彻底将工作区、暂存区和版本库记录恢复到指定的版本 1git reset --hard commitId 如果你希望保留修改，但是撤销提交，则使用 --mixed ，如果想彻底恢复，则使用 --hard","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://blog.zucchiniy.com/tags/cache/"},{"name":"reset","slug":"reset","permalink":"https://blog.zucchiniy.com/tags/reset/"}]},{"title":"Maven 使用笔记","slug":"backends/java/maven-use-tips","date":"2018-04-17T23:06:00.000Z","updated":"2021-07-02T15:43:09.538Z","comments":true,"path":"posts/2200c068.html","link":"","permalink":"https://blog.zucchiniy.com/posts/2200c068.html","excerpt":"","text":"创建一个项目1234mvn archetype:generate -DarchetypeCatalog=internal-DgroupId=com.mycompany.app -DartifactId=my-app-DarchetypeArtifactId=maven-archetype-quickstart-DinteractiveMode=false mvn archetype:generate 固定格式 -DgroupId 组织标识，包名 -DartifactId 项目名称 -DarchetypeCatalog=internal 不要从远程服务器上取 catalog，解决新建项目卡在 Generating project in interactive mode 处的问题 -DarchetypeArtifactId 指定 ArchetypeId , maven-archetype-quickstart , 创建一个 java 项目； maven-archetype-webapp ，创建一个 web 项目 -DinteractiveMode 是否使用交互模式 修改本地仓库路径在 setting.xml 中增加下面的配置，将 本地地址 改成对应的路径即可。 1&lt;localRepository&gt;本地地址&lt;/localRepository&gt; 导出工程依赖的 jar 包 导出到默认目录下 1mvn dependency:copy-dependencies 导出到指定目录下 1mvn dependency:copy-dependencied -DoutputDirecrtory=lib 设置依赖级别，并导出到对应的目录下 1mvn dependency:copy-dependencied -DoutputDirecrtory=lib -DincludeScope=jcompile 对应的5个级别： complie: 表示 dependency 都在生命周期中使用，同时会传递到依赖项目中 provided: 表示 dependency 由 JDK 或者容器提供，只作用在编译和测试时，无传递性 runtime: 表示 dependency 不作用在编译时，但会作用在运行和测试时 test: 表示 dependency 作用在测试时，不作用在运行时，不随项目发布 system: 与 provided 类似，但是在系统中要以外部 jar 包形式提供，maven 不会在 repository 查找它 使用华为镜像在 setting.xml 文件中 mirrors 节点中添加下面的内容： &lt;mirror&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt; &lt;/mirror&gt; 另外华为的镜像站为 [https://mirrors.huaweicloud.com](https://mirrors.huaweicloud.com/)。 ## maven 常用命令 | 命令 | 作用 | |---------------------|--------------------------------------------------------| | mvn clean | 清理项目生产的临时文件，一般是模块下的 target 目录 | | mvn compile | 编译源代码，一般编译模块下的src/main/java目录 | | mvn package | 项目打包工具,会在模块下的target目录生成jar或war等文件 | | mvn install | 将打包的jar/war文件复制到你的本地仓库中,供其他模块使用 | | mvn deploy | 将打包的文件发布到远程参考,提供其他人员进行下载依赖 | | mvn site | 生成项目相关信息的网站 | | mvn dependency:tree | 打印出项目的整个依赖树 | | mvn spring-boot:run | 启动 springboot 项目 |","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"后台技术/Java","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zucchiniy.com/tags/Maven/"}],"author":"zucchini"},{"title":"Surround 笔记","slug":"tools/emacs/evil-surround-learning","date":"2018-02-12T01:09:00.000Z","updated":"2021-07-02T15:43:09.551Z","comments":true,"path":"posts/3873eb44.html","link":"","permalink":"https://blog.zucchiniy.com/posts/3873eb44.html","excerpt":"","text":"surroud 插件项目的地址如下 vim surround 原文本 命令 新文本 “Hellow world!” ds” Hellow world! [123+456]/2 cs]) (123+456)/2 “Look ma, I’m *HTML!” cs” Look ma, I’m HTML! if x &gt; 3 { ysW( if( x&gt;3 ) { my $str = whee!; vllllS’ my $str = ‘whee!’; &lt;div&gt;Yo!&lt;/div&gt; dst Yo! &lt;div&gt;Yo!&lt;/div&gt; cst&lt;p&gt; &lt;p&gt;Yo!&lt;/p&gt; 上面的示例中，添加成对的括号时，如果使用后半括号，是没有空格的，如第 2 个示例，如果使用前半个括号，则是有空格的，如第 4 个示例。另外对于一些常见的标记，需要记住： t 表示 xml 或者 html 中的 Tag w word W WORD p paragraph 命令表格Normal modeds : 删除一对配对符号 cs : 替换原来的配对符号 ys : 加一对配对符号 yS : 增加一对配对符号，并将内容新建一行，并缩进 yss : 为整行增加一对配对符号 ySs : 为整行增加一对配对符号，并新起一行，然后缩进 ySS : 同 ySs Visual modes : 增加一对匹配符号 S : 增加一对匹配符号，并新起一行，然后缩进 Insert modeC-s : 增加一对匹配符号 C-s C-s : 增加一对匹配符号，并新起一行，然后缩进 C-g s : 增加一对匹配符号 C-G S : 增加一对匹配符号，新起一行然后进行缩进 修改 surrounding 内文本为例：ci : 修改匹配符号内的文本，并进入插入模式 di : 剪切匹配符号之间的文本 yi : 复制匹配符号之间的文本 ca : 同 ci 但是也修改符号本身 da : 同 di 但是也修改符号本身 ya : 同 yi 但是也修改箱号本身 b 可以表示小括号，B 表示大括号","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"evil","slug":"evil","permalink":"https://blog.zucchiniy.com/tags/evil/"},{"name":"surround","slug":"surround","permalink":"https://blog.zucchiniy.com/tags/surround/"}]},{"title":"Mac 上执行命令报错解决方案","slug":"tools/mac/xcrun-error","date":"2017-12-06T23:31:00.000Z","updated":"2020-01-13T16:00:00.000Z","comments":true,"path":"posts/8362cb1a.html","link":"","permalink":"https://blog.zucchiniy.com/posts/8362cb1a.html","excerpt":"","text":"gitmac 执行 git 命令时候出现 invalid active developer path ： 具体如下： 123xcrun: error: invalid active developer path(/Library/Developer/CommandLineTools), missing xcrun at:/Library/Developer/CommandLineTools/usr/bin/xcrun 解决方法： 打开终端输入 1xcode-select --install 回车后，系统弹出下载 xcode，点击确认，下载完成后即可。（实际上不是下载 xcode，可能下载 xcode 有关插件，下载时长约 1 分钟） 原因 : 出现这个错误原因猜想可能是因为之前安装过 xcode 卸载后或者是因为 xcode 更失丢失内容导致的。 node-gyp安装 node-gyp 的时候报错 xcode-select: error: command line tools are already installed, use “Software Update” to install updates 。 解决办法是重新安装 CommandLineTools 工具，用下面的命令处理： 12345softwareupdate --install -a # 查看安装状态softwareupdate --list # 查看安装的列表reinstall xcode-select # 重装 xcode-selectsudo rm -rf /Library/Developer/CommandLineTools # 删除旧的版本xcode-select --install # 自动重新安装","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"工具环境/Mac","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Mac/"}],"tags":[{"name":"xcode","slug":"xcode","permalink":"https://blog.zucchiniy.com/tags/xcode/"},{"name":"xcrun","slug":"xcrun","permalink":"https://blog.zucchiniy.com/tags/xcrun/"},{"name":"node-gyp","slug":"node-gyp","permalink":"https://blog.zucchiniy.com/tags/node-gyp/"}]},{"title":"GitHub Pull Request 方案","slug":"tools/git/pull-request-in-github","date":"2017-08-06T19:08:00.000Z","updated":"2021-07-02T15:43:09.554Z","comments":true,"path":"posts/bf0a41db.html","link":"","permalink":"https://blog.zucchiniy.com/posts/bf0a41db.html","excerpt":"","text":"操作流程 登录自己的账号，然后克隆一下原始项目。 将自己账号下的项目克隆到本地。 为了追踪原始仓库的更新，需要添加要更新的分支的原始仓库为远程分支 1git remote add upstream &lt;origin&gt;/&lt;xxxx&gt; 创建私有分支 develop ，用来开发项目 1git checkout -b develop 本地 develop 分支提交 切换 master 分支，同步原始仓库 12git checkout mastergit pull upstream master 切换本地 develop 分支，合并本地 master 分支并解决冲突 提交本地 develop 分支到自己的 develop 分支 向原始仓库发起 Pull Request 请求 等待原作者回复 (接受/拒绝) 注意点 在拉取新分支时，最好使用 rebase ，需如果使用 merge 的话，会增加许多 commit 信息，这会降低更新的整洁性。 如果有许多提交，可以先将自己的修改合并的一起，再进行提交，合并方案可以参考 Post not found: 工具环境/git/git-combine-commit-messages。 如果在提交的时候与远程有冲突，或者希望在本地解决冲突问题，可以参考 Post not found: 工具环境/git/git-rebase-merge进行冲突解决。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"GitHub Pull Request","slug":"GitHub-Pull-Request","permalink":"https://blog.zucchiniy.com/tags/GitHub-Pull-Request/"},{"name":"pr","slug":"pr","permalink":"https://blog.zucchiniy.com/tags/pr/"}]},{"title":"Git 合并多次提交","slug":"tools/git/git-combine-commit-messages","date":"2017-08-02T03:33:00.000Z","updated":"2021-07-02T15:43:09.553Z","comments":true,"path":"posts/d5debf46.html","link":"","permalink":"https://blog.zucchiniy.com/posts/d5debf46.html","excerpt":"","text":"在合并分支的时候，希望将多次提交合并成一个，然后再 cherry-pick 到主分支。 合并分支develop 分支做开发，可能会进行多次提交，但是在发布或者进行 PR 的时候，我们只希望看到一次提交。这个时候，我们需要进行 git rebase 之后进行合并。 12# HEAD~3 表示将近三次提交都合并，如果是将 2 次合并则为 HEAD~2git rebase -i HEAD~3 这个时候，看到的是一上对 COMMIT 信息的提示 123456789101112131415161718192021pick 9ba5122 2017 年 8 月 2 日pick c6da035 ~~# Rebase 9b6bae1..c6da035 onto 9b6bae1 (2 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 第一列对应的是 rebase 具体的操作，其含义如下 命令 作用 pick/p git 会应用这个补丁，以同样的提交信息（commit message）保存提交 reword/r git 会应用这个补丁，但需要重新编辑提交信息 edit/e git 会应用这个补丁，但会因为 amending 而终止 squash/s git 会应用这个补丁，但会与之前的提交合并 fixup/f git 会应用这个补丁，但会丢掉提交日志 exec/x git 会在 shell 中运行这个命令 drop/d git 会移除这次 COMMIT 将第二个 pick c6da035 ~~~ 这一行修改成 squash c6da035 ~~~ ，使之与之前的提交合并。 保存之后可以看到下面的内容 12345678910111213141516171819202122232425This is a combination of 2 commits.# This is the 1st commit message:2017 年 8 月 2 日删除无用配置，提高启动速度1. 更新 zucchini-org2. 增加 CHANGELOG 用来记录每次更新3. 更新 plantuml 配置 FIXED Can&#x27;t find plantuml-jar-path4. 增加 parinfer 配置，用来优化 lisp 的编写速度# This is the commit message #2:~~# Please enter the commit message for your changes. Lines starting# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.## Date: Tue Aug 1 10:24:44 2017 +0800## interactive rebase in progress; onto 9b6bae1# Last commands done (2 commands done):&quot;~/spacemacs/spacemacs.d/.git/COMMIT_EDITMSG&quot; 36L, 1003C 修改成正确的 commit 信息之后，保存存并退出，可以看到下面的内容 1234567$ git rebase -i HEAD~2[detached HEAD 0238691] 2017 年 8 月 2 日 Date: Tue Aug 1 10:24:44 2017 +0800 5 files changed, 65 insertions(+), 34 deletions(-) create mode 100644 CHANGELOG.org rewrite local/custom.el (66%)Successfully rebased and updated refs/heads/develop. 这个时候，就已经将我们这几次的更改都合并到一次中了。 cherry-pick 分支并更新这个时候，就可以更新我们的代码了。 首先 git checkout master 分支, 然后更新我们的代码 git pull 。 然后将我们合并之后的 develop 分支的内容更新过来 1git log -b develop 看到如下内容 12345678910111213commit 02386914b9e5ab13c23451a3463813bfdecb157aAuthor: 语乱 &lt;banshiliuli1990@sina.com&gt;Date: Tue Aug 1 10:24:44 2017 +0800 2017 年 8 月 2 日 删除无用配置，提高启动速度 1. 更新 zucchini-org 2. 增加 CHANGELOG 用来记录每次更新 3. 更新 plantuml 配置 FIXED Can&#x27;t find plantuml-jar-path 4. 增加 parinfer 配置，用来优化 lisp 的编写速度 或者使用上次的操作的中的提示 [detached HEAD 0238691] 2017 年 8 月 2 日 其中的 0238691 就是我们需要 1git cherry-pick 0238691 这样我们再推送到远程就可以实现合并更新了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"rebase","slug":"rebase","permalink":"https://blog.zucchiniy.com/tags/rebase/"}]},{"title":"Org mode 中不能执行 dot 、 Python 代码","slug":"tools/emacs/emacs-dot-and-python-cannot-run-in-spacemacs","date":"2017-07-30T19:23:00.000Z","updated":"2021-07-02T15:43:09.549Z","comments":true,"path":"posts/b203efa6.html","link":"","permalink":"https://blog.zucchiniy.com/posts/b203efa6.html","excerpt":"","text":"无法执行的代码 更新之后，dot 、 plantuml 的代码段在 Org-mode 下无法执行，需要引入对应的 ob-xxx.el 才能正常执行。 可以手工重新编译或者重新下载 Org 相关 package 即可，也可以使用下面的命令进行更新。 1:spacemacs/recompile-elpa","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"spacemacs","slug":"spacemacs","permalink":"https://blog.zucchiniy.com/tags/spacemacs/"},{"name":"org babel","slug":"org-babel","permalink":"https://blog.zucchiniy.com/tags/org-babel/"}]},{"title":"Linux 的环境配置","slug":"tools/linux/linux-config-tips","date":"2017-06-08T00:49:00.000Z","updated":"2021-07-02T15:43:09.556Z","comments":true,"path":"posts/291b15f4.html","link":"","permalink":"https://blog.zucchiniy.com/posts/291b15f4.html","excerpt":"","text":"切换更新源刷新 Manjaro 源，由快到慢并指定为中国源 :::shell sudo pacman-mirrors -gb testing -c China 然后更新系统： :::shell sudo pacman -Syyu plantuml 中文乱码在 Linux 系统中，无论是官方 JDK 还是 OpenJDK 都有中文字库不全的问题。需要通过安装默认字体来解决这个问题： :::shell sudo dnf install cjkuni-uming-fonts 安装之后，重新执行 PlantUML 代码块，中文可以正常显示。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"pacman","slug":"pacman","permalink":"https://blog.zucchiniy.com/tags/pacman/"},{"name":"plantuml","slug":"plantuml","permalink":"https://blog.zucchiniy.com/tags/plantuml/"}]},{"title":"Git 解决分支冲突","slug":"tools/git/git-rebase-merge","date":"2017-05-07T01:25:00.000Z","updated":"2021-07-02T15:43:09.554Z","comments":true,"path":"posts/a7a0f436.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a7a0f436.html","excerpt":"","text":"在使用 git 进行版本管理的开发过程中，经常遇到上传或者拉取分支的时候冲突，在遇到冲突的时候，经常使用下面两个方式解决，虽然第一个方案看起来比较复杂，但是如果按我之前的文章: Post not found: 工具环境/git/git-workflow 进行工作的话，只需要执行3、4、5三步即可。 虽然提供的解决方案，但是最好还是从根源上降低冲突出现的频率才是最好的方案。 新建分支方法本文主要讨论 Git feature 与 master(develop) 分支冲突解决方案。 git pull : 同步远程分支，发现当前的开发流有了新的提交，且与自己开发的功能有冲突。 git checkout -b feature : Checkout 到 feature 分支。 git checkout master git pull origin master : 切换到 master 分支并拉取最新的内容。 git checkout feature git rebase master: 切换到 feature 分支并将 master 的修改合并，并解决冲突。 git add -A git rebase --continue : 将修改内容保存并继续 rebase 操作。 applying: xxxx : 看到这个提示表示已经完成了合并。 git checkout master git merge feature : 切换到 master 分支并将 feature 分支内容合并过来。 暂存提交方案在修改的时候，忘记新建对应的分支了，可以按上面的方案，但保存，然后创建新的分支，再将远程分支对应分支的内容 reset 回未修改的状态。或者使用 git stash 系列命令解决冲突。 git stash : 暂存修改的内容 git pull : 拉取最新的内容 git stash apply or git stash pop : 将暂存的内容合并进来 git stash 命令git stash apply : 应用暂存内容但是不删除，可以是最近的一次暂存，也可以按序号应用 git stash apply stash@&#123;0&#125;git stash drop : 移除暂存的内容git stash pop : 应用的同时从列表中移除，只能操作最近的一次 stash 的内容git stash list : 查看整个的暂存列表git stash save : 来查看对应的所有的修改，这样就可以非常方便的找到最好的实现方案git stash show -p stash@&#123;1&#125; : 不输入对应的 stash@&#123;&#125; 内容则将最近的 stash 与当前分支做比较，如果加了则用指定的暂存 Git stash apply 的时候，报错 : 12error Your local changes to the follow files would be overwritten by merge: xxxxPlease commit your changes or stash them before you merge . 可以先add 修改的文件，然后再apply 12git add test.txtgit stash apply","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"rebase","slug":"rebase","permalink":"https://blog.zucchiniy.com/tags/rebase/"},{"name":"merge","slug":"merge","permalink":"https://blog.zucchiniy.com/tags/merge/"}]},{"title":"Tar 和 Tree 命令","slug":"tools/linux/tar-and-tree-command","date":"2017-03-18T18:04:00.000Z","updated":"2021-07-02T15:43:09.557Z","comments":true,"path":"posts/9d7bc1b0.html","link":"","permalink":"https://blog.zucchiniy.com/posts/9d7bc1b0.html","excerpt":"","text":"tar 命令命令格式1tar [必要参数] [选择参数] [文件] 命令功能 用来压缩和解压文件。tar 本身不具有压缩功能。他是调用压缩功能实现的。 命令参数必要参数如下： 12345678910111213141516-A 新增压缩文件到已经存在的压缩-B 设置区块大小-c 建立新的压缩文件-d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件-t 显示压缩文件的内容-z 支持 gzip 解压文件-j 支持 bzip2 解压文件-Z 支持 compress 解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性 可选参数如下： 12345-b 设置区块数目-C 切换到指定目录-f 指定压缩文件--help 显示帮助信息--version 显示版本信息 常见解压、压缩命令 tar 解包： tar xvf FileName.tar 打包： tar cvf FileName.tar DirName .gz 解压 1： gunzip FileName.gz 解压 2： gzip -d FileName.gz 压缩 : gzip FileName .tar.gz 和 .tgz 解压： tar zxvf FileName.tar.gzip 压缩： tar zcvf FileName.tar.gz DirName .bz2 解压: bzip2 -d FileName.bz2 解压: bunzip2 FileName.bz2 压缩: bzip2 -z FileName tar.bz2 解压: tar jxvf FileName.tar.bz2 压缩: tar jcvf FileName.tar.bz2 DirName .tar.bz 解压: tar jxvf FileName.tar.bz 压缩: tar jcvf FileName.tar.bz DirName .Z 解压: uncompress FileName.Z 压缩: compress FileName .tar.Z 解压: tar Zxvf filename.tar.Z 压缩: tar Zcvf FileName.tar.Z DirName .zip 解压: unzip FileName.zip 压缩: zip FileName.zip DirName .rar 解压: rar x filename.rar 压缩: rar a filename.rar dirName tree 命令tree 命令在 Linux 里是一个非常方便的命令，可以让你方便的查看一个路径下的文件夹结构。 tree -C : 颜色显示 tree -f : 显示文件全路径 tree -L 2 : 只显示2层 tree -P *.pl : 只显示文件目录和 *.pl 为后缀的文件 tree -F : 显示目录后面的 __ ，显示可执行文件 * 功能类似 ls -F tree –help : 帮助手册","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"tar","slug":"tar","permalink":"https://blog.zucchiniy.com/tags/tar/"},{"name":"tree","slug":"tree","permalink":"https://blog.zucchiniy.com/tags/tree/"}]},{"title":"Emacs 学习之旅","slug":"journal/emacs-learning-way","date":"2017-03-01T22:38:00.000Z","updated":"2021-07-02T15:43:09.545Z","comments":true,"path":"posts/ba9b36be.html","link":"","permalink":"https://blog.zucchiniy.com/posts/ba9b36be.html","excerpt":"","text":"Emacs 的使用过程，就像是程序员的生涯一样——路漫漫其修远兮，吾将上下而求索。 万物始于 Emacs最早知道 Emacs 是从编辑器的圣战开始的，即编辑器之神——Vi，和神的编辑器——Emacs。两个编辑器在经历了几十年的战争之后，仍然是编辑世界不可超越的高峰。 但在一开始，我选择的是 Vi，因为在 *nix 中，都是有安装的，在服务器编辑文件——即使是很大的文件，Vi 也可以非常轻易的打开编辑，在一段时间内，我几乎是跪着使用 Vi 的。 后来随着想用的功能越来越多，而 Vi 只能做为编辑器使用，再加上被一些大神安利，我就选择尝试使用 Emacs 来装逼记笔记。于是下载了当时正流行的 Purcell 大神的配置，并开始尝试使用，不过没过多少就放弃了。 期间阅读了许多入门学习的内容，对 Emacs 有了一个大概的了解。 推荐阅读内容： 《一年成为 Emacs 高手（像神一样使用编辑器）》 Prelude 入门级 Emacs 配置 Purcell 大神的配置 Emacs 始于 OrgEmacs 学习的无疾而终，让我的装逼大计一度沉沦。直到我开始尝试利用 Org-mode 进行博客写和作日程管理，阅读了一些文章之后，才真正开始了 Emacs 的学习苦旅。 如果说 Emacs 是神的编辑器的话， Org 可能是神器之中的神器，随着对 Org 的学习和使用，我从最初的装逼，到后来的逼格提升真正开始利用Emacs，都是因为Org-mode 。 推荐阅读内容： mudan 大神的 Org-mode 入门级手册 mudan 大神的漂亮的文言文排版 Tisoga 大神的 Org + GitHub 的博客教学 终于 Spacemacs 的战争从最开始的学习，到现在已经习惯于使用 Emacs ，主要因为其确实是可以提升效率的，当然这里要把配置时间拿走。虽然开始使用的原因有所不同，但是大家最后的目标却都是一样的——即提高工作（学习）效率。 但是经过了 Emacs 几次强行配置之后，学习了一些 Emacs 的填坑方案。 后来加入了一个 Emacs 的微信群——毫不夸张的说，这是我加入过的群里面质量最高的，学习效果最好的，而且所有的成员都自发的维护群里的闲聊问题，每一次讨论都是提问解决和讨论的过程。 在偶然的一次机会，被安利了一把 Spacemacs，Vi 的操作加上 Emacs 的扩展，不要太吸引人！ 推荐关注的大神： Hick 高质量 Emacs 微信群群主，应该也是发起人，水的人自觉加入闲聊群，是我所有技术相关微信群中质量最高的。 子龙山人 Spacemacs Rock 视频作者，我的配置里抄的最多的就是这位大神的。 DarkSun 黑日大神，大神的文章非常多，而且质量都非常高，还维护着一个 Emacs 推广相关的项目，多读读，可以找到一些自己需要的配置。 tumashu 天然二呆，呆神，之前看到呆神在闲聊群里水，后来又看到呆神在帮忙解决问题，好奇的关注了一下 GitHub ，才发现，竟然这几个好用的 package 都是呆神写的，而且呆神竟然不是程序员靠程序吃饭！ 大神太多了，不一一推荐，如果需要，可以联系 Hick 加一下群，就都有了。 再推荐一下中文的 Emacs 论坛，可以提问，也可以讨论： Emacs China 一堆大神在维护的论坛，经常看看，非常好用。 我的 Emacs 配置初始为了更好管理配置，推荐使用 .spacemacs.d 文件夹进行管理配置，而不是使用 .spacemacs 文件。也为了方便后续的扩展。 可能会遇到的问题如果是在 Windows 下使用，需要注意几个问题： 推荐用编译版本，或者用官方网站加部分 .dll 文件来解决 使用过程中，为了配置的时候好用——更适合 Linux，我是使用在环境变量中增加默认的 HOME 的方案，也可以使用其它方法 直接下载就可以使用，维护的是 develop 分支，后续会慢慢往 master 分支中合并 最终选择在几经周折之后，最后还是选择自己从头开始配置一套 .emacs.d ，主要是因为以下几个问题： 随着使用的人越来越多，维护的东西也越来越多，项目太大了 最终希望的是使用 Vi 的快捷键方案，可以使用 evil-mode 来替代 个人使用的特性话的内容太多，完全引用项目不如借鉴项目的配置方案 我的 emacs 原生配置 我的博客地址如果想看我的博客，可以访问：hugo博客 或者 hexo博客。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://blog.zucchiniy.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"Emacs","slug":"Emacs","permalink":"https://blog.zucchiniy.com/tags/Emacs/"},{"name":"org mode","slug":"org-mode","permalink":"https://blog.zucchiniy.com/tags/org-mode/"}]},{"title":"MySQL 数据库设置远程权限","slug":"backends/mysql/mysql-authority-config","date":"2016-04-29T02:55:00.000Z","updated":"2021-07-02T15:43:09.539Z","comments":true,"path":"posts/43555396.html","link":"","permalink":"https://blog.zucchiniy.com/posts/43555396.html","excerpt":"","text":"设置访问单个数据库权限 设置用户名为 root，密码为空，可以访问数据库 test 1mysql&gt;grant all privileges on test.* to &#x27;root&#x27;@&#x27;%&#x27;; 设置访问全部数据库权限 设置用户名为 root，密码为空，可以访问所有数据库 1mysql&gt;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;; 设置指定用户名访问权限 指定用户名为 liuhui，密码为空，可以访问所有数据库 1mysql&gt;grant all privileges on *.* to &#x27;liuhui&#x27;@&#x27;%&#x27;; 设置密码访问权限 设置用户名为 liuhui，密码为 liuhui，可以访问所有数据库 1mysql&gt;grant all privileges on *.* to &#x27;liuhui&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;liuhui&#x27;; 设置指定可访问主机权限 设置用户名为 liuhui，密码为 liuhui，可以访问所有数据库，只有 10.1.1.1 这台机器有权限访问 1mysql&gt;grant all privileges on *.* to &#x27;liuhui&#x27;@&#x27;10.1.1.1&#x27;; 设置对应的密码级别参数解释1mysql&gt;show variables like &#x27;validate_password%&#x27;; validate_password_dictionary_file: 用于难密码强度的字典文件路径 validate_password_length: 密码最小长度，参数默认为 8， validate_password_mixed_case_count: 密码至少要包含的小写字母个数和大写字母个数 validate_password_number_count: 密码至少要包含的数字个数 validate_password_policy: 密码强度难 0/LOW 1/MEDIUM 2/STRONG validate_password_special_char_count: 密码至少要包含的特殊字符数","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"grant privileges","slug":"grant-privileges","permalink":"https://blog.zucchiniy.com/tags/grant-privileges/"}],"author":"zucchini"},{"title":"Git 基础命令","slug":"tools/git/git-basic-command","date":"2016-04-26T23:02:00.000Z","updated":"2021-07-03T13:13:53.099Z","comments":true,"path":"posts/c5f0918d.html","link":"","permalink":"https://blog.zucchiniy.com/posts/c5f0918d.html","excerpt":"","text":"新建代码库123456#在当前目录新建一个 git 代码库$ git init#新建一个目录，将其初始化为 git 代码库$ git init [project-name]#下载一个项目和它的整个代码历史$ git clone [url] 全局配置和项目配置git 的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） 1234567#显示当前 git 配置$ git config --list#编辑 git 配置文件$ git config -e [--global]#设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112#添加指定文件到暂存区$ git add [file1] [file2] ...#添加指定目录到暂存区，包括子目录$ git add [dir]#添加当前目录的所有文件到暂存区$ git add .#删除工作区文件，并且将这次删除放入到暂存区$ git rm [file1] [file2] ...#停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]#改名文件，并将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交12345678910111213#提交暂存区到仓库区$ git commit -m [message]#提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]#提交工作区自上次 commit 之后的变化，直接到仓库区$ git commit -a#提交时显示所有 diff 信息$ git commit -v#使用一次新的 commit,替代上一次提交#如果代码没有变化，则用来改写上一次的 commit 的提交信息$ git commit --amend -m [message]#重做上一次 commit, 并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支1234567891011121314151617181920212223242526272829303132333435#列出所有本地分支$ git branch#列出所有远程分支$ git branch -r#列出所有本地分支和远程分支$ git branch -a#新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 将原有分支名称 old branch name 修改为 new namegit branch -m &lt;old branch name&gt; &lt;new name&gt;# 修改当前分支名称为 new namegit branch -m &lt;new name&gt;#新建一个分支，并切换到当该分支$ git checkout -b [branch-name]#新建一个分支，指向指定 commit$ git branch [branch] [commit]#新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]#切换到指定分支，并更新工作区$ git checkout [branch-name]#建立追踪关系，在现有分支与指定的远程分支之前$ git branch --set-upstream [branch] [remote-branch]#合并指定分支到当前分支$ git merge [branch]#选择一个 commit,合并进当前分支$ git cherry-pick [commit]#删除分支$ git branch -d [branch-name]#删除远程分支$ git push origin --delete [branch-name]#删除与远程分支关联$ git branch -dr [remote/branch]#删除远程分支 2$ git branch -r -d origin/[branch-name]$ git push origin :[branch-name] 标签1234567891011121314151617181920212223242526#列出所有 tag$ git tag#在当前 commit，新建一个 tag$ git tag [tag]#在指定 commit，新建一个 tag$ git tag [tag] [commit]#删除本地 tag$ git tag -d [tag]#删除远程 tag$ git push origin :refs/tags/[tagName]#查看 tag 信息$ git show [tag]#提交指定的 tag$ git push [remote] [tag]#提交所有 tag$ git push [remote] --tags#新建一个分支，指向某个 tag$ git checkout -b [branch] [tag]#重命名 tag$ git tag -f [new-tagName] [old-tagName]$ git tag -d [old-tagName]#将本地 tag 推送到远程$ git push origin :refs/tags/[old-tagName]$ git push --tags# 拉取 taggit fatch origin tag tag_name 查看信息123456789101112131415161718192021222324252627282930313233#显示所有变更的文件$ git status#显示当前分支的版本历史$ git log#显示 commit 历史，以及每次 commit 发生变更的文件$ git log --stat#显示某个 commit 之后的所有变动，每个 commit 占据一行$ git log [tag] HEAD --pretty=format:%s#显示某个 commit 之后的所有变动，其“提交说明”必须符合条件$ git log [tag] HEAD --grep feature#显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]#显示指定文件相关的每一次 diff$ git log -p [file]#显示指定文件是什么人在什么时间修改过$ git blame [file]#显示暂存区与工作区的差异$ git diff#显示暂存区和上一个 commit 的差异$ git diff --cached [file]#显示工作区与当前分支最新 commit 之间的差异$ git diff HEAD#显示两次提交之间的差异$ git diff [first-branch] ... [second-branch]#显示某次提交的元数据和内容变化$ git show [commit]#显示某次提交发生的变化的文件$ git show --name-only [commit]#显示某次提交时，某个文件的内容$ git show [commit]:[filename]#显示当前分支的最近几次提交$ git reflog 远程同步12345678910111213141516#下载运程仓库的所有变动$ git fetch [remote]#显示所有远程分支$ git remote -v#显示某个远程仓库的信息$ git remote show [remote]#增加一个新的远程仓库，并命名$ git remote add [shortname] [url]#取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]#上传本地指定分支到远程仓库$ git push [remote] [branch]#强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force#推送所有分支到远程仓库$ git push [remote] --all 修改远程仓库地址1234# 先删除远程分支地址$ git remote rm origin# 然后重新增加远程分支地址$ git remote add origin [url] 撤销12345678910111213141516171819#恢复暂存区的指定文件到工作区$ git checkout [file]#恢复某个 commit 的指定文件到工作区$ git checkout [commit] [file]#恢复上一个 commit 的所有文件到工作区$ git checkout .#重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]#重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard#重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]#重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit]#重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]#新建一个 commit, 用来撤销指定 commit#后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 其它12#生成一个可供发布的压缩包$ git archive git 提升内容 储藏暂存内容 12345678# 想要切换分支，但是还不想要提交之前的工作，可以储存修改信息，将新的储藏推送到栈上$ git stash / git stash save# 在这时，能够轻易的切换分支并在其他地方工作，你的修改被存储在栈上。要查看储藏的东西，可以使用 git stash list$ git stash list# 可以将刚刚的储藏重新加载回来$ git stash apply# 也可以通过储藏的序号进行加载$ git stash apply stash@&#123;1&#125; 核武器级选项 filter-branch 1234567891011121314# 从每一个提交移除一个文件：指 git add . 的内容完整的上传到仓库，但是当希望开源这个内容的时候，需要移除一些无用的文件，--tre-filter 选项在的每一个提交后，运行指定的命令，然后重新提交结果。$ git filter-branch --tree-filter &#x27;rm -f passwords.txt&#x27; HEAD# 使一个子目录作为新的根目录：假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk/tags 等等）。如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做，再在新项目根目录是 trunk 子目录且 Git 会自动移除所有不影响子目录的提交。$ git filter-branch --subdirectory-filter trunk HEAD# 在开始工作时忘记运行 git config 来设置你的名字与邮箱地址，或者你想要开源一个项目，并且修改所有你的工作邮箱地址为你的个人邮箱地址。任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。需要小心的是只修改你自己的邮箱地址，所以使用 --commit-filter 来修改：$ git filter-branch --commit-filter &#x27; if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ]; then GIT_AUTHOR_NAME = &quot;scott Chacon&quot;; GIT_AUTHOR_EMAIL = &quot;schacon@example.com&quot;; git commit-tree &quot;$@&quot;; else git commit-tree &quot;$@&quot;; fi&#x27; HEAD","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.zucchiniy.com/tags/Git/"},{"name":"command","slug":"command","permalink":"https://blog.zucchiniy.com/tags/command/"}]},{"title":"Emacs 快捷键使用","slug":"tools/emacs/emacs-keybinds-basic","date":"2016-04-26T03:12:00.000Z","updated":"2021-07-02T15:43:09.550Z","comments":true,"path":"posts/9951df45.html","link":"","permalink":"https://blog.zucchiniy.com/posts/9951df45.html","excerpt":"","text":"设置 Emacs 的默认编码格式 1(prefer-coding-system &#x27;utf-8-unix) 改变文件编码格式 C-x C-m f utf-8-unix RET : 将当前文件转换为 utf-8 编码 C-x C-m c RET C-x C-w RET : 将当前文件另存为指定编码 查看需要的库文件 M-: image-library-alist RET : 查看 emacs 支持需要的库文件 123456789101112((xpm &quot;libxpm.dll&quot; &quot;xpm4.dll&quot; &quot;libXpm-nox4.dll&quot;)(png &quot;libpng16.dll&quot; &quot;libpng16-16.dll&quot;)(tiff &quot;libtiff-5.dll&quot; &quot;libtiff3.dll&quot; &quot;libtiff.dll&quot;)(jpeg &quot;libjpeg-9.dll&quot;)(gif &quot;libgif-7.dll&quot;)(svg &quot;librsvg-2-2.dll&quot;)(gdk-pixbuf &quot;libgdk_pixbuf-2.0-0.dll&quot;)(glib &quot;libglib-2.0-0.dll&quot;)(gobject &quot;libgobject-2.0-0.dll&quot;)(gnutls &quot;libgnutls-28.dll&quot; &quot;libgnutls-26.dll&quot;)(libxml2 &quot;libxml2-2.dll&quot; &quot;libxml2.dll&quot;)(zlib &quot;zlib1.dll&quot; &quot;libz-1.dll&quot;))","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"coding system","slug":"coding-system","permalink":"https://blog.zucchiniy.com/tags/coding-system/"},{"name":"image library","slug":"image-library","permalink":"https://blog.zucchiniy.com/tags/image-library/"},{"name":"keybind","slug":"keybind","permalink":"https://blog.zucchiniy.com/tags/keybind/"}]},{"title":"Git 工作流","slug":"tools/git/git-workflow","date":"2016-03-17T00:43:00.000Z","updated":"2021-07-02T15:43:09.554Z","comments":true,"path":"posts/fea0ccee.html","link":"","permalink":"https://blog.zucchiniy.com/posts/fea0ccee.html","excerpt":"","text":"中心化的工作流优势 首先它让每个开发者都有自己的本地的完整项目副本。隔离的环境使得每个开发都的工作独立于项目的其它修改 —— 他们可以在自己的本地仓库中添加提交，完全无视上游的开发，直到需要的时候。 其次，它让你接触到了 Git 分支和合并模型。Git 分支被设计为故障安全的机制，用来在仓库之间整合代码和共享更改。 如何工作 中心化的工作将中央仓库作为项目中所有修改的唯一入口。默认的开发分支叫做 master，所有的更改都被提交到这个分支。这种工作流不需要 master 之外的其它分支。 开发者将中央仓库克隆到本地后开始工作。在他们的本地项目副本中，他们可以像 SVN 一样修改文件和提交更改；不过这些新的提交被保存在本地 —— 它们和中央仓库完全隔离。这使得开发者可以将和上游的同步推迟到他们方便的时候。 为了向官方项目发布修改，开发者将他们本地 master 分支“推送”到中央仓库。这一步等同于 svn commit，除了 Git 添加的是所有不在中央 master 分支上的提交。 管理冲突 中央仓库代码官方项目，因此它的提交历史应该被视为不可更改的。如果开发者的本地提交和中央仓库分叉了，Git 会拒绝将它们的修改推送上去，因为这会覆盖官方提交。 在开发在提交功能之前，需要 fetch 更新中央提交，在它们之上 rebase 自己的更改。 如果本地修改和上游提交的冲突时，Git 会暂停 rebase 流程，给你机会手工解决这些冲突。Git 很赞的一点是，它将 git status 和 git add 命令同时用来生成提交和解决合并冲突。这使得开发能够轻而易举的管理他们的合并。另外，如果他们改错了什么，Git 能让他们轻易的退出 rebase 过程，然后重试。 例子 项目管理员生成一个空的版本库 :::shell ssh user@host git init --bare /path/to/repo.git 三个人 A, B, C 同时编写同一个项目，需要先在本地创建一个完整的项目副本。 :::shell git clone ssh://user@host/path/to/repo.git 此时，Git 自动添加了一个名为 origin 的运程连接，指向中央仓库，以方便提交。A 可以使用标准 Git 提交流程开发功能：编辑、缓存、提交。 :::shell git status git add &lt;some file&gt; git commit 同时，B 也在本地进行自己的开发工作。 A 发布了他们修改 :::shell git push origin master 此时中央仓库会将 master -&gt; origin/master B 试图发布修改 :::shell git push origin master 但是因为 A 已经提交了功能到中央仓库，导致 B 的本地历史和中央仓库分叉，Git 会拒绝本次提交。 B 如果想提交，必须要先 rebase 本地仓库 可以使用 git pull 来拉取并修改， :::shell git pull --rebase origin master –rebase 命令告诉 Git，在同步中央仓库的修改之后，将 B 的所有提交移到 master 分支的顶端。 如果没有冲突的文件，B 就可以直接进行提交了，但是如果存在冲突，可以根据提示查找冲突的文件，修改之后，可以继续 rebase 操作。 :::shell git add &lt;some-file&gt; git rebase --continue 同样的，如果此时不知道自己做了什么，可以回滚一次操作。 :::shell git rebase --abort 然后再进行 push 就可以提交到中央版本库了。 基于功能人分支的工作流Feature 分支工作流 掌握了中心化工作流的使用姿势，在你的开发流程中添加功能分支是一个简单的方式，来促进协作和开发者之间的交流。这种封装使得多个开发专注自己的功能，而不会打扰主代码库。它还能保证 master 分支永远不会包含损坏的代码，给持续集成环境带来了很大的好处。 封装功能的开发使得 pull request 的使用成为可能，用来启动围绕一个分支的讨论。它给了其他开发者在功能并入主项目之前参与决策的机会。或者，如果你开发功能时卡在一半，可以发起一个 pull request，向同事寻求建议。重点是：pull request 使得团队在评论其他人的工作时，变得非常简单。 如何工作 Feature 分支工作流同样使用中央仓库，master 同样代码官方的项目历史。但是与其直接提交在本地的 master 分支，开发者每次进行新的工作时创建一个新的分支。Feature 分支应该包含描述性的名称，比如 animated-menu-items(菜单项动画)或 issue-*1061。每个分支都应该有一个清晰、高度集中的目的。 Git 在技术上无法区别 master 和功能分支，所以开发者可以在 feature 分支上编辑、缓存、提交，就和中心化工作流中一样。 此外，feature 分支可以被推送到中央仓库。这使得你和其他开发者共享这个功能，而又不改变官方代码。既然 master 只是一个“特殊”的分支，在中央仓库中储存多个 feature 分支不会引出什么问题。当然，这也是备份每个开发者本地提交的好办法。 Pull Request 除了隔离功能开发之外，分支使得通过 pull request 讨论修改成为可能。一旦有人完成了一个功能，他们不会立即将它并入 master。他们将 feature 分支推送到中央服务器上，发布一个 pull request，请求将他们的修改并入 master。这给了其他开发者在修改并入主代码库之前审查的机会。 代码审查是 pull request 的主要好处，但他们事实上被设计成为讨论代码的一般场所。你可以把 pull request 看作是专注某个分支的讨论版。也就是说他们可以用于开发流程之前。比如，一个开发者在某个功能上需要帮助，他只需要发起一个 pull request。感兴趣的小伙伴会自动收到通知，看到相关提交中的问题。 一旦 pull request 被接受了，发布功能的行为和中心化的工作流是一样的。首先，确定你本地的 master 和上游的 master 已经同步。然后，将 feature 分支并入 master 已经同步。然后可以将 feature 分支并入 master，将更新的 master 推送回中央仓库。 Gitflow 工作流 GitFlow 工作流围绕项目发布定义了一个严格的分支模型。有些地方比功能分支工作流更复杂，为管理大型项目提供了框架。 和功能分支工作流相比，这种工作流没有增加任何新的概念或命令。它给不同的分支指定了特定的角色，定义它们应该如何、什么时候交流。除了功能分支之外，它还为准备发布、维护发布、记录发布分别使用了单独的分支。当然，还能享受到功能分支工作流带来的所有好处：pull request、隔离实验和更高效的协作。 如何工作 GitFlow 工作流仍然使用中央仓库作为开发者沟通的中心。和其它工作流一样，开发者在本地工作，将分支推送到中央仓库。唯一的区别在于项目的分支结构。 历史分支 和单独的 master 分支不同，这种工作流使用两个分支来记录项目历史。master 分支储存官方发布历史，develop 分支用来整合功能分支。同时，这还方便了在 master 分支上给所有提交打上版本号标签。 工作流剩下的部分围绕这两个分支的差别展开。 功能分支 每个新功能都放置在自己的分支中，可以在备份/协作时推送到中央仓库。但是与其合并到 master，功能分支将开发分支作为父分支。当一个功能完成时，它将被合并回 develop。功能永远不应该支持在 master 上交互。 功能分支加上 develop 分支就是我们之前据说的功能分支工作流。 发布分支 一旦 develop 分支的新功能足够发布，你可以从 develop 分支 fork 一个发布分支。这个分支的创建开始了下个发布周期，只有和发布相关的任务应该在这个分支进行，如修复 bug、生成文档等。一旦准备好发布，发布分支将合并进 master，打上版本号的标签。另外，它也应该合并回 develop，后者可能在发布启动之后有了新的进展。 使用一个专门的分支来准备发布确保一个团队完善当前的发布，其它团队可以继续开发下一个发布的功能。它还建立了清晰的开发阶段。 通常约定： 从 develop 创建分支 合并进 master 分支 命名规范 release-* 或者 release/* 维护分支 维护或者“紧急修复”分支用来快速给产品发布打上补丁。这是唯一可以从 master 上 fork 的分支。一旦修复完成了，它应该被并入 master 和 develop 分支，master 应该打上更新的版本号的标签。 有一个专门的 bug 修复开发线使得团队能够处理 issue，而不打断其它工作流或是要等到下一个发布周期。你可以将维护分支看作在 master 分支上工作的临时发布分支。 例子创建一个开发分支 为默认的 master 分支创建一个互补的 develop 分支。最简单的办法是在本地创建一个空的 develop 分支，将他推送到服务器上： :::shell git branch develop git push -u origin develop 这个分支将会包含项目中所有的历史，而 master 将包含不完全的版本。其他开发者应该将中央仓库克隆到本地，创建一个分支来追踪 develop 分支： :::shell git clone http://xxx/xx/repo.git git checkout -b develop origin/develop 开始了新的功能 当两个人都需要在不同分支上开始工作，即为自己的功能创建单独的分支。且他们的分支都是基于 develop 而不是 master： :::shell git checkout -b some-feature develop 他们都使用“编辑、缓存、提交”的一般约定来向功能分支添加提交： :::shell git status git add &lt;some-file&gt; git commit 完成功能 添加了一些提交后，可以使用 pull request，现在正是发起的好时机，请求将新功能并入 develop 分支。否则可以先并入本地的 develop 分支，推送到中央仓库： :::shell git pull origin develop git checkout develop git merge some-feature git push git branch -d some-feature 第一个命令在尝试并入功能分支之前确保 develop 分支已经是最新的。注意，功能绝不该直接并入 master。冲突的处理方式和中心化工作流相同。 发布新功能 当另外的开发人员，仍在他自己的分支上工作时，开始准备项目的第一个官方发布。和开发功能一样，新建一个分支来封装发布的准备工作。这也正是发布的版本号创建的第一步： :::shell git checkout -b release-0.1 develop 这个分支用来整理提交，充分测试，更新文档，为即将到来的发布做各种准备。它就像是一个专门用来完善发布的功能分支。 一旦发布准备稳妥，即将其并入 master 和 develop，然后删除发布分支。合并回 develop 很重要，因为可能已经有关键的更新添加到发布分支上，而开发新功能需要用到它们。同样的，如果团队重视代码审查，现在将是发起 pull request 的完美时机。 :::shell git checkout master git merge release-0.1 git push git checkout develop git merge release-0.1 git push git branch -d release-0.1 发布分支是功能开发（develop）分支和公开发布（master）之间的过渡阶段。不论什么时候，将提交并入 msater 时，你应该为提交打上方便引用的标签： :::shell git tag -a 0.1 -m &quot;Initial public release&quot; master git push --tags Git 提供了许多钩子，即仓库中特定事件发生时被执行的脚本。当你向中央仓库推送 master 分支或者标签时，你可以配置一个钩子来自动化构建公开发布。 终端用户发现一个 Bug 正式发布之后，两个开发一起为下一个发布开发功能。这时，一个终端用户开了一个 issue 抱怨说当前发布中存在一个 Bug。为了解决这个 bug，先从 master 创建一个维护分支，用几个提交修复这个 issue，然后直接合并回 master。 :::shell git checkout -b issue*001 master ##Fix the bug git checkout master git merge issue-*001 git push 和发布分支一样，维护分支包含了 develop 中需要的重要更新，因此需要执行同样的合并。接下来，可以删除这个分支： :::shell git checkout develop git merge issue-*001 git push git branch -d issue-*001 各分支的意义 feature (多个) 主要是自己玩了，差不多的时候要合并回 develop 去。不与 master 交互。 develop (同时间一个) 主要是和 feature 以及 release 交互 release (同时间一个) 总是基于 develop，最后又合并回 develop。当然对应的 tag 要合并到 master 分支，生命周期短，仅是为了发布程序 hotfix (同一时间一个) 总是基于 master，并最后合并到 master 和 develop。生命同期较短，用来修复 bug 或小粒度修改发布 master (仅一个) 关联 tag 和发布 模型中各个模块内容的使用 在这个模型中，master 和 develop 都具有象征意义。master 分支上的代码总是稳定的 (stable build)，随时可以发布出去。develop 上的代码总是从 feature 上合并过来的，可以进行 Nightly Builds，但不直接在 develop 上进行开发。当 develop 上的 featur 足够多以致于可以进行新版本的发布时，可以创建 release 分支。 release 分支基于 develop，进行委阴简单的修改后就被合并到 master，并打上 tag，表示可以发布了。紧接着 release 将被合并到 develop；此时 Develop 可能往前跑了一段，出现合并冲突，需要手工解决冲突后再次合并，这步完成后就删除 release 分支 当从已发布版本中发现 bug 要修复时，就应用到 hotfix 分支了。hotfix 基于 master 分支，完成 bug 修复或者紧急修改后，要 merge 回 master，打上一个新的 tag，并 merge 回 develop，删除 hotfix 分支。 由此可见 release 和 hotfix 的生命周期都较短，而 master 和 develop 虽然总是存在，但去不常使用。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"workflow","slug":"workflow","permalink":"https://blog.zucchiniy.com/tags/workflow/"},{"name":"工作流","slug":"工作流","permalink":"https://blog.zucchiniy.com/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}]},{"title":"Pandoc 命令","slug":"tools/pandoc-command","date":"2016-01-19T01:08:00.000Z","updated":"2021-07-02T15:43:09.558Z","comments":true,"path":"posts/4032e239.html","link":"","permalink":"https://blog.zucchiniy.com/posts/4032e239.html","excerpt":"","text":"org 转换为 docx 基本命令 1pandoc xxx.org -o xxx.docx 利用 css 进行配置着色 1pandoc 01-chapter2.markdown -o chapter2.docx -c Github.css org 转换为 letex 使用指定字体 1pandoc pandocCh.org -o pandocCh.pdf --latex-engine=xelatex -V mainfont=&quot;SimSun&quot; 使用指定模板 1pandoc pandocCh.org -o pandocCh.pdf --latex-engine=xelatex -template=pm-template.latex org 转换为 html1pandoc 01-chapter2.org -o chapter2.html -c Github.css ``` org 转换为 Markdown1pandoc -f org -t markdown -o output.md input.org","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Pandoc","slug":"工具环境/Pandoc","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Pandoc/"}],"tags":[{"name":"org","slug":"org","permalink":"https://blog.zucchiniy.com/tags/org/"},{"name":"docx","slug":"docx","permalink":"https://blog.zucchiniy.com/tags/docx/"},{"name":"markdown","slug":"markdown","permalink":"https://blog.zucchiniy.com/tags/markdown/"}]},{"title":"Graphviz dot 笔记","slug":"tools/emacs/emacs-graphviz-dot","date":"2016-01-07T23:39:00.000Z","updated":"2021-07-02T15:43:09.550Z","comments":true,"path":"posts/8ebf9d4.html","link":"","permalink":"https://blog.zucchiniy.com/posts/8ebf9d4.html","excerpt":"","text":"Dot 生成图的默认命令dot -T&lt;type&gt; -o &lt;outfile&gt; &lt;infile.dot&gt; dot 可以替换为circo等其他算法，详细见命令的选择章节。 输入文件是 &lt;infile.dot&gt; ，生成的格式由 指定，生成的文件是 。其中 -T 包括： 12345678910-Tps (PostScript)-Tsvg -Tsvgz (Structured Vector Graphics)-Tfig (XFIG graphics)-Tmif (FrameMaker graphics)-Thpgl (HP pen plotters)-Tpcl (Laserjet printers)-Tpng -Tgif (bitmap graphics)-Tdia (GTK+ based diagrams)-Timap (imagemap files for httpd servers for each node or edge that has a non-null &quot;href&quot; attribute.)-Tcmapx (client-side imagemap for use in html and xhtml) rankrank 约束了子图的节点位置，有向图中，一个箭头的指向，带有级别，一般是尾端高于尖端，即 a-&gt;b a 的级别要高于 b 的级别。 same : 所有节点在同一级别的节点处 min : 所有节点在最小级别节点处 source : 所有节点在最低级别，且只有子图属性为 source 或者 min 的时候，才能使用同样的级别 max : 类似于 source sink : 类似于 source NOTE: 最低级别，可以是 最上 、 最下 、 最左 、 最右 rankdir TB : top-to-bottom LR : left-to-right BT : bottom-to-top RL : right-to-left dot 线条12345splines = ortho #直角拆线splines = spline #曲线（不遮挡）splines = cuvved #曲线（可遮挡）splines = line #直线（可遮挡）splines = polyline #直线（不遮挡） 命令的选择 命令 介绍 dot 渲染图具有明确的方向性 neato 图缺乏方向性 twopi 图采用放射性布局 circo 图采用环形布局 fdp 图缺乏方向性 sfdp 用来渲染大型图，且图片缺乏方向性 静默执行代码1(setq org-confirm-babel-evaluate nil) ;;执行静默语句块 dot 实例 绘制流程图: 12345678digraph structs &#123; node[shape=record] struct1 [label=&quot;&lt;f0&gt; left|&lt;f1&gt; mid\\ dle|&lt;f2&gt; right&quot;]; struct2 [label=&quot;&#123;&lt;f0&gt; one|&lt;f1&gt; two\\n\\n\\n&#125;&quot; shape=Mrecord]; struct3 [label=&quot;hello\\nworld |&#123; b |&#123;c|&lt;here&gt; d|e&#125;| f&#125;| g | h&quot;]; struct1:f1 -&gt; struct2:f0; struct1:f0 -&gt; struct3:f1;&#125; 12345678910111213141516171819202122232425262728293031323334353637digraph g &#123;size=&quot;8,6&quot;ratio=expandedge [dir=both]plcnet [shape=box, label=&quot;plc network&quot;]subgraph cluster_wrapline &#123; label=&quot;wrapline control system&quot; color=purple subgraph &#123; rank=same exec sharedmem [style=filled, fillcolor=lightgrey, shape=box] &#125; edge[style=dotted, dir=none] exec -&gt; opserver exec -&gt; db plc -&gt; exec edge [style=line, dir=both] exec -&gt; sharedmem sharedmem -&gt; db plc -&gt; sharedmem sharedmem -&gt; opserver&#125;plcnet -&gt; plc [constraint=false]millwide [shape=box, label=&quot;millwide system&quot;]db -&gt; millwidesubgraph cluster_opclients &#123; color=blue label=&quot;operator client&quot; rankdir=lr labelloc=b node[label=client] opserver -&gt; client1 opserver -&gt; client2 opserver -&gt; client3&#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243digraph G &#123;rankdir=LRnode [shape=plaintext]a [label=&lt;&lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;1&quot; CELLSPACING=&quot;0&quot;&gt;&lt;TR&gt;&lt;TD ROWSPAN=&quot;3&quot; BGCOLOR=&quot;yellow&quot;&gt;class&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD PORT=&quot;here&quot; BGCOLOR=&quot;lightblue&quot;&gt;qualifier&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&gt;]b [shape=ellipse style=filledlabel=&lt;&lt;TABLE BGCOLOR=&quot;bisque&quot;&gt;&lt;TR&gt;&lt;TD COLSPAN=&quot;3&quot;&gt;elephant&lt;/TD&gt;&lt;TD ROWSPAN=&quot;2&quot; BGCOLOR=&quot;chartreuse&quot;VALIGN=&quot;bottom&quot; ALIGN=&quot;right&quot;&gt;two&lt;/TD&gt; &lt;/TR&gt;&lt;TR&gt;&lt;TD COLSPAN=&quot;2&quot; ROWSPAN=&quot;2&quot;&gt;&lt;TABLE BGCOLOR=&quot;grey&quot;&gt;&lt;TR&gt; &lt;TD&gt;corn&lt;/TD&gt; &lt;/TR&gt;&lt;TR&gt; &lt;TD BGCOLOR=&quot;yellow&quot;&gt;c&lt;/TD&gt; &lt;/TR&gt;&lt;TR&gt; &lt;TD&gt;f&lt;/TD&gt; &lt;/TR&gt;&lt;/TABLE&gt; &lt;/TD&gt;&lt;TD BGCOLOR=&quot;white&quot;&gt;penguin&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt; &lt;TD COLSPAN=&quot;2&quot; BORDER=&quot;4&quot; ALIGN=&quot;right&quot; PORT=&quot;there&quot;&gt;4&lt;/TD&gt; &lt;/TR&gt;&lt;/TABLE&gt;&gt;]c [label=&lt;long line 1&lt;BR/&gt;line 2&lt;BR ALIGN=&quot;LEFT&quot;/&gt;line 3&lt;BR ALIGN=&quot;RIGHT&quot;/&gt;&gt;]subgraph &#123; rank=same b c &#125;a:here -&gt; b:there [dir=both arrowtail = diamond]c -&gt; bd [shape=triangle]d -&gt; c [label=&lt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD BGCOLOR=&quot;red&quot; WIDTH=&quot;10&quot;&gt; &lt;/TD&gt;&lt;TD&gt;Edge labels&lt;BR/&gt;also&lt;/TD&gt;&lt;TD BGCOLOR=&quot;blue&quot; WIDTH=&quot;10&quot;&gt; &lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&gt;]&#125;","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"dot","slug":"dot","permalink":"https://blog.zucchiniy.com/tags/dot/"},{"name":"graphviz","slug":"graphviz","permalink":"https://blog.zucchiniy.com/tags/graphviz/"}]},{"title":"CSS  语法入门","slug":"fronts/css-learning-notes","date":"2016-01-05T22:45:00.000Z","updated":"2021-07-02T15:43:09.543Z","comments":true,"path":"posts/1e4744b6.html","link":"","permalink":"https://blog.zucchiniy.com/posts/1e4744b6.html","excerpt":"","text":"CSS 是前端开发的基础。CSS 規則由兩個主要的部分構成:選擇器，以及一條或者多條聲明。CSS 是前端开发的基础，主要由两个部分构成： 选择器 声明，可以是单条，也可以是多条 1selector &#123; declaration1; declaration2; ... declarationN;&#125; 选择器通常是 HTML 中的元素。每条声明都是由一个属性和一个值构成，属性是希望设置的样式、属性，每个属性都有一个值，并用冒号分开。 1selector &#123;property: value&#125; 下面代码的作用是将 h1 元素内的文字的颜色定义为红色，同时将字体的大小设置为 14 像素。 在这个例子中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。 1h1 &#123;color : red; font-size: 14px;&#125; 如果值是多个词组，可以给值增加引号。 1p &#123; font-family: &quot;sans serif&quot;;&#125; 如果林定义不止一个声明，则需要用分号将每个声明隔开。 下面的示例是将段落的字体定义为红色且居中。 虽然最后一个属性是不需要增加分号的，但是为了以后修改，最好在每条属性后面都增加分号分隔符。 12345p &#123; text-align: center; color: black; font-family: arial;&#125; 子元素总是继承你元素的属性。 123body &#123; font-family: Vrdana, sans-serif;&#125; 这样，在 body 属性下的元素：p, td, ul, ol, li, dl, dt, dd 等都会继承 body 中定义的字体，同样继承来的值也可以进行重写。 12body &#123; font-family: Vrdana;&#125;p &#123; font-family: Times;&#125; 选择器、派生选择器：通过依据元素位置的上下文件关系来定义的样式。 1234li strong &#123; font-style: italic; font-weight: normal;&#125; ID 选择器：可以为标有特定 ID 的元素指定样式。 1#red &#123; color: red;&#125; ID 选择器也可以和派生选择器一起使用。 12345# sidebar p&#123;font-style: italic;text-align: right;margin-top: 0.5em;&#125; 单独选择器：可以单独发挥作用的选择器。 1234#sidebar &#123;border: 1px dotted #000;padding: 10px;&#125; 类选择器：以一个点号作为开头。 1.center &#123; text-align: center;&#125; 也可以用作派生选择器上。 1234.fancy td &#123; color: #f60; background: #666;&#125; 元素也可以基于它们的类而被选择。 1234td.fancy &#123; color: #f60; background: #666;&#125; 上面的两个示例中，第一个是类名为 fancy 的元素内容属性设置，下面的则是指 &lt;td class=&#39;fancy&#39;&gt; 的元素的属性设置。 选择器 描述 [attribut] 用于选取带有指定属性的元素 [attribut=value] 用于选取带有指定属性和值的元素 [attribut~=value] 用于选取属性值中包含指定词条的元素 [attribut&vert;=value] 用于选取带有以指定开头的属性值的元素，该值必须是整个单词 [attribut^=value] 匹配属性值以指定值开头的每个元素 [attribut$=value] 匹配属性值以指定值结尾的每个元素 [attribut*=value] 匹配属性值中包含指定值的每个元素 CSS 允许应用纯色做为背景，也允许使用背景图片创建一个繁杂的效果。 可以使用 background-color 指定背景色，这个属性接受任务合法的颜色值。可以利用这个将背景色配置为灰色。background-color 是不能被继承的。 12p &#123; background-color: gray;&#125;p &#123; background-color: gray; padding:20px;&#125;","categories":[{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"css","slug":"前端技术/css","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://blog.zucchiniy.com/tags/css/"}]},{"title":"gcc/g++ 命令","slug":"tools/gcc-g++-command","date":"2015-12-22T18:26:00.000Z","updated":"2021-07-02T15:43:09.552Z","comments":true,"path":"posts/a4921194.html","link":"","permalink":"https://blog.zucchiniy.com/posts/a4921194.html","excerpt":"","text":"gcc -E sourcefile.c : -E，只执行到预编译，直接输出预编译结果 gcc -S sourcefile.c : -S，只执行到源代码到汇编代码的转换，输出汇编代码 gcc -c sourcefile.c : -c，只执行到编译，输出目标文件 gcc (-E/-S/-c) sourcefile.c -o output-file : -o，指定输出文件名，可以使用以上三种标签中的一种。 -o 参数可以被省略，这种情况下编译器按以下默认名方式输出: -E 预编译结果将被输出到标准输出端口-S 生成名为 sourcefile.s 的汇编文件-c 生成名为 sourcefile.o 的目标文件 无标签的时候，生成名为 a.out 的可执行文件 gcc -g sourcefile.c-g 生成供调用的可执行文件，可以在 gdb 中运行。由于文件中包含了调试信息，因此运行效率很低，且文件也大了不少。这里可以用 strip 把文件中的 debug 信息删除。 strip a.out gcc -s sourcefile.c-s 直接生成与运用 strip 同样的效果的可执行文件gcc -O sourcefile.c-O 编译器对代码进行自动化编译，输出效率更高的可执行文件&lt;p class=&quot;verse&quot;&gt; -O2 可以跟上数字表示优化等级 gcc -O2 sourcefile.c 数字越大越加优化。但是也会有出 bug 的风险&lt;br /&gt; &lt;/p&gt; gcc -Wall sourcefile.c-W 在编译中开启一些额外的警告信息。-Wall，将所有的警告信息全开。gcc sourcefile.c -L/path/to/lib -lxxx -l/path/to/include - -l 指定所使用到的函数库，本例中是尝试链接名为 libxxx.a 的函数库 - -L 指定函数库所在的文件，本例中链接器会尝试搜索/path/to/lib 文件夹 - -I 指定文件所在的文件夹，本例中预编译器会尝试搜索/path/to/include 文件夹","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"GCC","slug":"工具环境/GCC","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/GCC/"}],"tags":[{"name":"gcc","slug":"gcc","permalink":"https://blog.zucchiniy.com/tags/gcc/"},{"name":"g++","slug":"g","permalink":"https://blog.zucchiniy.com/tags/g/"}],"author":"zucchini"}],"categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"},{"name":"生活总结","slug":"生活总结","permalink":"https://blog.zucchiniy.com/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"},{"name":"后台技术","slug":"后台技术","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"},{"name":"Hexo","slug":"工具环境/Hexo","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Hexo/"},{"name":"GitHub","slug":"工具环境/GitHub","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/GitHub/"},{"name":"前端技术","slug":"前端技术","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"xpath","slug":"前端技术/xpath","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/xpath/"},{"name":"hexo","slug":"工具环境/hexo","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/hexo/"},{"name":"hexo","slug":"前端技术/hexo","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/hexo/"},{"name":"Google","slug":"工具环境/Google","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Google/"},{"name":"Mac","slug":"工具环境/Mac","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Mac/"},{"name":"Android","slug":"工具环境/Android","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Android/"},{"name":"Java","slug":"后台技术/Java","permalink":"https://blog.zucchiniy.com/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Java/"},{"name":"Windows","slug":"工具环境/Windows","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Windows/"},{"name":"hugo","slug":"前端技术/hugo","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/hugo/"},{"name":"JavaScript","slug":"前端技术/JavaScript","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/JavaScript/"},{"name":"Eclispe","slug":"工具环境/Eclispe","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Eclispe/"},{"name":"travis","slug":"工具环境/travis","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/travis/"},{"name":"ajax","slug":"前端技术/ajax","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/ajax/"},{"name":"正则表达式","slug":"工具环境/正则表达式","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Pandoc","slug":"工具环境/Pandoc","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Pandoc/"},{"name":"css","slug":"前端技术/css","permalink":"https://blog.zucchiniy.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/css/"},{"name":"GCC","slug":"工具环境/GCC","permalink":"https://blog.zucchiniy.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/GCC/"}],"tags":[{"name":"find","slug":"find","permalink":"https://blog.zucchiniy.com/tags/find/"},{"name":"delete","slug":"delete","permalink":"https://blog.zucchiniy.com/tags/delete/"},{"name":"git","slug":"git","permalink":"https://blog.zucchiniy.com/tags/git/"},{"name":"git-filter-repo","slug":"git-filter-repo","permalink":"https://blog.zucchiniy.com/tags/git-filter-repo/"},{"name":"焦虑","slug":"焦虑","permalink":"https://blog.zucchiniy.com/tags/%E7%84%A6%E8%99%91/"},{"name":"面对焦虑","slug":"面对焦虑","permalink":"https://blog.zucchiniy.com/tags/%E9%9D%A2%E5%AF%B9%E7%84%A6%E8%99%91/"},{"name":"conda","slug":"conda","permalink":"https://blog.zucchiniy.com/tags/conda/"},{"name":"conda activate","slug":"conda-activate","permalink":"https://blog.zucchiniy.com/tags/conda-activate/"},{"name":"Plotly express","slug":"Plotly-express","permalink":"https://blog.zucchiniy.com/tags/Plotly-express/"},{"name":"保存成图片","slug":"保存成图片","permalink":"https://blog.zucchiniy.com/tags/%E4%BF%9D%E5%AD%98%E6%88%90%E5%9B%BE%E7%89%87/"},{"name":"Django admin","slug":"Django-admin","permalink":"https://blog.zucchiniy.com/tags/Django-admin/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://blog.zucchiniy.com/tags/Matplotlib/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://blog.zucchiniy.com/tags/Leetcode/"},{"name":"微信读书清单","slug":"微信读书清单","permalink":"https://blog.zucchiniy.com/tags/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"},{"name":"股票数据","slug":"股票数据","permalink":"https://blog.zucchiniy.com/tags/%E8%82%A1%E7%A5%A8%E6%95%B0%E6%8D%AE/"},{"name":"MySQL 安装","slug":"MySQL-安装","permalink":"https://blog.zucchiniy.com/tags/MySQL-%E5%AE%89%E8%A3%85/"},{"name":"librime","slug":"librime","permalink":"https://blog.zucchiniy.com/tags/librime/"},{"name":"emacs-rime","slug":"emacs-rime","permalink":"https://blog.zucchiniy.com/tags/emacs-rime/"},{"name":"liberime","slug":"liberime","permalink":"https://blog.zucchiniy.com/tags/liberime/"},{"name":"SOLID","slug":"SOLID","permalink":"https://blog.zucchiniy.com/tags/SOLID/"},{"name":"post link","slug":"post-link","permalink":"https://blog.zucchiniy.com/tags/post-link/"},{"name":"post path","slug":"post-path","permalink":"https://blog.zucchiniy.com/tags/post-path/"},{"name":"图床","slug":"图床","permalink":"https://blog.zucchiniy.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"jsdelivr","slug":"jsdelivr","permalink":"https://blog.zucchiniy.com/tags/jsdelivr/"},{"name":"github","slug":"github","permalink":"https://blog.zucchiniy.com/tags/github/"},{"name":"定位节点","slug":"定位节点","permalink":"https://blog.zucchiniy.com/tags/%E5%AE%9A%E4%BD%8D%E8%8A%82%E7%82%B9/"},{"name":"正则匹配","slug":"正则匹配","permalink":"https://blog.zucchiniy.com/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"},{"name":"org mode","slug":"org-mode","permalink":"https://blog.zucchiniy.com/tags/org-mode/"},{"name":"use-sub-superscripts","slug":"use-sub-superscripts","permalink":"https://blog.zucchiniy.com/tags/use-sub-superscripts/"},{"name":"ditaa","slug":"ditaa","permalink":"https://blog.zucchiniy.com/tags/ditaa/"},{"name":"Evil Multiple cursors","slug":"Evil-Multiple-cursors","permalink":"https://blog.zucchiniy.com/tags/Evil-Multiple-cursors/"},{"name":"turn evil mode off","slug":"turn-evil-mode-off","permalink":"https://blog.zucchiniy.com/tags/turn-evil-mode-off/"},{"name":"markdown-it","slug":"markdown-it","permalink":"https://blog.zucchiniy.com/tags/markdown-it/"},{"name":"emoji","slug":"emoji","permalink":"https://blog.zucchiniy.com/tags/emoji/"},{"name":"tasks","slug":"tasks","permalink":"https://blog.zucchiniy.com/tags/tasks/"},{"name":"keybinds","slug":"keybinds","permalink":"https://blog.zucchiniy.com/tags/keybinds/"},{"name":"gdb","slug":"gdb","permalink":"https://blog.zucchiniy.com/tags/gdb/"},{"name":"grep","slug":"grep","permalink":"https://blog.zucchiniy.com/tags/grep/"},{"name":"du","slug":"du","permalink":"https://blog.zucchiniy.com/tags/du/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.zucchiniy.com/tags/hexo/"},{"name":"hugo","slug":"hugo","permalink":"https://blog.zucchiniy.com/tags/hugo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://blog.zucchiniy.com/tags/GitHub-Pages/"},{"name":"年度清单","slug":"年度清单","permalink":"https://blog.zucchiniy.com/tags/%E5%B9%B4%E5%BA%A6%E6%B8%85%E5%8D%95/"},{"name":"读书清单","slug":"读书清单","permalink":"https://blog.zucchiniy.com/tags/%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"},{"name":"电影清单","slug":"电影清单","permalink":"https://blog.zucchiniy.com/tags/%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/"},{"name":"电视清单","slug":"电视清单","permalink":"https://blog.zucchiniy.com/tags/%E7%94%B5%E8%A7%86%E6%B8%85%E5%8D%95/"},{"name":"valine","slug":"valine","permalink":"https://blog.zucchiniy.com/tags/valine/"},{"name":"Code 504","slug":"Code-504","permalink":"https://blog.zucchiniy.com/tags/Code-504/"},{"name":"阅读","slug":"阅读","permalink":"https://blog.zucchiniy.com/tags/%E9%98%85%E8%AF%BB/"},{"name":"阅读分组","slug":"阅读分组","permalink":"https://blog.zucchiniy.com/tags/%E9%98%85%E8%AF%BB%E5%88%86%E7%BB%84/"},{"name":"google adsense","slug":"google-adsense","permalink":"https://blog.zucchiniy.com/tags/google-adsense/"},{"name":"pandas","slug":"pandas","permalink":"https://blog.zucchiniy.com/tags/pandas/"},{"name":"Python","slug":"Python","permalink":"https://blog.zucchiniy.com/tags/Python/"},{"name":"学习计划","slug":"学习计划","permalink":"https://blog.zucchiniy.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"markdown","slug":"markdown","permalink":"https://blog.zucchiniy.com/tags/markdown/"},{"name":"django","slug":"django","permalink":"https://blog.zucchiniy.com/tags/django/"},{"name":"markdown-deux","slug":"markdown-deux","permalink":"https://blog.zucchiniy.com/tags/markdown-deux/"},{"name":"时间管理","slug":"时间管理","permalink":"https://blog.zucchiniy.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"},{"name":"时间使用效率","slug":"时间使用效率","permalink":"https://blog.zucchiniy.com/tags/%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87/"},{"name":"透视表","slug":"透视表","permalink":"https://blog.zucchiniy.com/tags/%E9%80%8F%E8%A7%86%E8%A1%A8/"},{"name":"read_excel()","slug":"read-excel","permalink":"https://blog.zucchiniy.com/tags/read-excel/"},{"name":"简历","slug":"简历","permalink":"https://blog.zucchiniy.com/tags/%E7%AE%80%E5%8E%86/"},{"name":"技能水平","slug":"技能水平","permalink":"https://blog.zucchiniy.com/tags/%E6%8A%80%E8%83%BD%E6%B0%B4%E5%B9%B3/"},{"name":"tmux","slug":"tmux","permalink":"https://blog.zucchiniy.com/tags/tmux/"},{"name":"keymap","slug":"keymap","permalink":"https://blog.zucchiniy.com/tags/keymap/"},{"name":"super","slug":"super","permalink":"https://blog.zucchiniy.com/tags/super/"},{"name":"hyper","slug":"hyper","permalink":"https://blog.zucchiniy.com/tags/hyper/"},{"name":"install Emacs","slug":"install-Emacs","permalink":"https://blog.zucchiniy.com/tags/install-Emacs/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://blog.zucchiniy.com/tags/Mac-OS/"},{"name":"总结","slug":"总结","permalink":"https://blog.zucchiniy.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"子弹笔记","slug":"子弹笔记","permalink":"https://blog.zucchiniy.com/tags/%E5%AD%90%E5%BC%B9%E7%AC%94%E8%AE%B0/"},{"name":"手帐体系","slug":"手帐体系","permalink":"https://blog.zucchiniy.com/tags/%E6%89%8B%E5%B8%90%E4%BD%93%E7%B3%BB/"},{"name":"安卓系统","slug":"安卓系统","permalink":"https://blog.zucchiniy.com/tags/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F/"},{"name":"手动更新手机系统","slug":"手动更新手机系统","permalink":"https://blog.zucchiniy.com/tags/%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"知识管理","slug":"知识管理","permalink":"https://blog.zucchiniy.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"},{"name":"reflex","slug":"reflex","permalink":"https://blog.zucchiniy.com/tags/reflex/"},{"name":"Field","slug":"Field","permalink":"https://blog.zucchiniy.com/tags/Field/"},{"name":"Selenium","slug":"Selenium","permalink":"https://blog.zucchiniy.com/tags/Selenium/"},{"name":"下拉框","slug":"下拉框","permalink":"https://blog.zucchiniy.com/tags/%E4%B8%8B%E6%8B%89%E6%A1%86/"},{"name":"modifier keys","slug":"modifier-keys","permalink":"https://blog.zucchiniy.com/tags/modifier-keys/"},{"name":"Emacs","slug":"Emacs","permalink":"https://blog.zucchiniy.com/tags/Emacs/"},{"name":"生活","slug":"生活","permalink":"https://blog.zucchiniy.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"减法生活","slug":"减法生活","permalink":"https://blog.zucchiniy.com/tags/%E5%87%8F%E6%B3%95%E7%94%9F%E6%B4%BB/"},{"name":"重置 root 密码","slug":"重置-root-密码","permalink":"https://blog.zucchiniy.com/tags/%E9%87%8D%E7%BD%AE-root-%E5%AF%86%E7%A0%81/"},{"name":"报错 10060","slug":"报错-10060","permalink":"https://blog.zucchiniy.com/tags/%E6%8A%A5%E9%94%99-10060/"},{"name":"清理连接数","slug":"清理连接数","permalink":"https://blog.zucchiniy.com/tags/%E6%B8%85%E7%90%86%E8%BF%9E%E6%8E%A5%E6%95%B0/"},{"name":"lsof","slug":"lsof","permalink":"https://blog.zucchiniy.com/tags/lsof/"},{"name":"netstat","slug":"netstat","permalink":"https://blog.zucchiniy.com/tags/netstat/"},{"name":"postbuffer","slug":"postbuffer","permalink":"https://blog.zucchiniy.com/tags/postbuffer/"},{"name":"hung up","slug":"hung-up","permalink":"https://blog.zucchiniy.com/tags/hung-up/"},{"name":"cmder","slug":"cmder","permalink":"https://blog.zucchiniy.com/tags/cmder/"},{"name":"Hugo","slug":"Hugo","permalink":"https://blog.zucchiniy.com/tags/Hugo/"},{"name":"theme","slug":"theme","permalink":"https://blog.zucchiniy.com/tags/theme/"},{"name":"beautifusoup","slug":"beautifusoup","permalink":"https://blog.zucchiniy.com/tags/beautifusoup/"},{"name":"下载小说","slug":"下载小说","permalink":"https://blog.zucchiniy.com/tags/%E4%B8%8B%E8%BD%BD%E5%B0%8F%E8%AF%B4/"},{"name":"select into","slug":"select-into","permalink":"https://blog.zucchiniy.com/tags/select-into/"},{"name":"insert into select","slug":"insert-into-select","permalink":"https://blog.zucchiniy.com/tags/insert-into-select/"},{"name":"apt-get","slug":"apt-get","permalink":"https://blog.zucchiniy.com/tags/apt-get/"},{"name":"apt","slug":"apt","permalink":"https://blog.zucchiniy.com/tags/apt/"},{"name":"layui","slug":"layui","permalink":"https://blog.zucchiniy.com/tags/layui/"},{"name":"presentation","slug":"presentation","permalink":"https://blog.zucchiniy.com/tags/presentation/"},{"name":"exists","slug":"exists","permalink":"https://blog.zucchiniy.com/tags/exists/"},{"name":"in","slug":"in","permalink":"https://blog.zucchiniy.com/tags/in/"},{"name":"travis","slug":"travis","permalink":"https://blog.zucchiniy.com/tags/travis/"},{"name":"自动部署博客","slug":"自动部署博客","permalink":"https://blog.zucchiniy.com/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"},{"name":"create user","slug":"create-user","permalink":"https://blog.zucchiniy.com/tags/create-user/"},{"name":"set password","slug":"set-password","permalink":"https://blog.zucchiniy.com/tags/set-password/"},{"name":"submodule","slug":"submodule","permalink":"https://blog.zucchiniy.com/tags/submodule/"},{"name":"css","slug":"css","permalink":"https://blog.zucchiniy.com/tags/css/"},{"name":"滚动条","slug":"滚动条","permalink":"https://blog.zucchiniy.com/tags/%E6%BB%9A%E5%8A%A8%E6%9D%A1/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.zucchiniy.com/tags/JavaScript/"},{"name":"async","slug":"async","permalink":"https://blog.zucchiniy.com/tags/async/"},{"name":"异步请求","slug":"异步请求","permalink":"https://blog.zucchiniy.com/tags/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"},{"name":"substring","slug":"substring","permalink":"https://blog.zucchiniy.com/tags/substring/"},{"name":"indexOf","slug":"indexOf","permalink":"https://blog.zucchiniy.com/tags/indexOf/"},{"name":"RegExp","slug":"RegExp","permalink":"https://blog.zucchiniy.com/tags/RegExp/"},{"name":"形意拳","slug":"形意拳","permalink":"https://blog.zucchiniy.com/tags/%E5%BD%A2%E6%84%8F%E6%8B%B3/"},{"name":".gitignore","slug":"gitignore","permalink":"https://blog.zucchiniy.com/tags/gitignore/"},{"name":"CAST","slug":"CAST","permalink":"https://blog.zucchiniy.com/tags/CAST/"},{"name":"CONVERT","slug":"CONVERT","permalink":"https://blog.zucchiniy.com/tags/CONVERT/"},{"name":"timestamp","slug":"timestamp","permalink":"https://blog.zucchiniy.com/tags/timestamp/"},{"name":"regex","slug":"regex","permalink":"https://blog.zucchiniy.com/tags/regex/"},{"name":"wildcard","slug":"wildcard","permalink":"https://blog.zucchiniy.com/tags/wildcard/"},{"name":"concat","slug":"concat","permalink":"https://blog.zucchiniy.com/tags/concat/"},{"name":"concat_ws","slug":"concat-ws","permalink":"https://blog.zucchiniy.com/tags/concat-ws/"},{"name":"group_concat","slug":"group-concat","permalink":"https://blog.zucchiniy.com/tags/group-concat/"},{"name":"union","slug":"union","permalink":"https://blog.zucchiniy.com/tags/union/"},{"name":"zsh","slug":"zsh","permalink":"https://blog.zucchiniy.com/tags/zsh/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.zucchiniy.com/tags/mysql/"},{"name":"oracle","slug":"oracle","permalink":"https://blog.zucchiniy.com/tags/oracle/"},{"name":"模糊查询","slug":"模糊查询","permalink":"https://blog.zucchiniy.com/tags/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/"},{"name":"logging level","slug":"logging-level","permalink":"https://blog.zucchiniy.com/tags/logging-level/"},{"name":"homebrew","slug":"homebrew","permalink":"https://blog.zucchiniy.com/tags/homebrew/"},{"name":"dd","slug":"dd","permalink":"https://blog.zucchiniy.com/tags/dd/"},{"name":"diskutil","slug":"diskutil","permalink":"https://blog.zucchiniy.com/tags/diskutil/"},{"name":"cache","slug":"cache","permalink":"https://blog.zucchiniy.com/tags/cache/"},{"name":"reset","slug":"reset","permalink":"https://blog.zucchiniy.com/tags/reset/"},{"name":"Maven","slug":"Maven","permalink":"https://blog.zucchiniy.com/tags/Maven/"},{"name":"evil","slug":"evil","permalink":"https://blog.zucchiniy.com/tags/evil/"},{"name":"surround","slug":"surround","permalink":"https://blog.zucchiniy.com/tags/surround/"},{"name":"xcode","slug":"xcode","permalink":"https://blog.zucchiniy.com/tags/xcode/"},{"name":"xcrun","slug":"xcrun","permalink":"https://blog.zucchiniy.com/tags/xcrun/"},{"name":"node-gyp","slug":"node-gyp","permalink":"https://blog.zucchiniy.com/tags/node-gyp/"},{"name":"GitHub Pull Request","slug":"GitHub-Pull-Request","permalink":"https://blog.zucchiniy.com/tags/GitHub-Pull-Request/"},{"name":"pr","slug":"pr","permalink":"https://blog.zucchiniy.com/tags/pr/"},{"name":"rebase","slug":"rebase","permalink":"https://blog.zucchiniy.com/tags/rebase/"},{"name":"spacemacs","slug":"spacemacs","permalink":"https://blog.zucchiniy.com/tags/spacemacs/"},{"name":"org babel","slug":"org-babel","permalink":"https://blog.zucchiniy.com/tags/org-babel/"},{"name":"pacman","slug":"pacman","permalink":"https://blog.zucchiniy.com/tags/pacman/"},{"name":"plantuml","slug":"plantuml","permalink":"https://blog.zucchiniy.com/tags/plantuml/"},{"name":"merge","slug":"merge","permalink":"https://blog.zucchiniy.com/tags/merge/"},{"name":"tar","slug":"tar","permalink":"https://blog.zucchiniy.com/tags/tar/"},{"name":"tree","slug":"tree","permalink":"https://blog.zucchiniy.com/tags/tree/"},{"name":"grant privileges","slug":"grant-privileges","permalink":"https://blog.zucchiniy.com/tags/grant-privileges/"},{"name":"Git","slug":"Git","permalink":"https://blog.zucchiniy.com/tags/Git/"},{"name":"command","slug":"command","permalink":"https://blog.zucchiniy.com/tags/command/"},{"name":"coding system","slug":"coding-system","permalink":"https://blog.zucchiniy.com/tags/coding-system/"},{"name":"image library","slug":"image-library","permalink":"https://blog.zucchiniy.com/tags/image-library/"},{"name":"keybind","slug":"keybind","permalink":"https://blog.zucchiniy.com/tags/keybind/"},{"name":"workflow","slug":"workflow","permalink":"https://blog.zucchiniy.com/tags/workflow/"},{"name":"工作流","slug":"工作流","permalink":"https://blog.zucchiniy.com/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"name":"org","slug":"org","permalink":"https://blog.zucchiniy.com/tags/org/"},{"name":"docx","slug":"docx","permalink":"https://blog.zucchiniy.com/tags/docx/"},{"name":"dot","slug":"dot","permalink":"https://blog.zucchiniy.com/tags/dot/"},{"name":"graphviz","slug":"graphviz","permalink":"https://blog.zucchiniy.com/tags/graphviz/"},{"name":"gcc","slug":"gcc","permalink":"https://blog.zucchiniy.com/tags/gcc/"},{"name":"g++","slug":"g","permalink":"https://blog.zucchiniy.com/tags/g/"}]}